<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Databases on 博客</title><link>https://chenkai0520.github.io/database/</link><description>Recent content in Databases on 博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Jul 2021 15:37:56 +0800</lastBuildDate><atom:link href="https://chenkai0520.github.io/database/index.xml" rel="self" type="application/rss+xml"/><item><title>pg 分词</title><link>https://chenkai0520.github.io/database/pg_to_tsvector/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_to_tsvector/</guid><description>分词例子 to_tsvector()生成的分词带有位置信息，tsvector没有位置信息
select to_tsvector(&amp;#39;陈 锴 A S F a a a 1 2 3 4&amp;#39;); select to_tsvector(&amp;#39;simple&amp;#39;, &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39;); select to_tsvector(&amp;#39;english&amp;#39;, &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39;); `&amp;#39;1&amp;#39;:8 &amp;#39;12&amp;#39;:3 &amp;#39;2&amp;#39;:9 &amp;#39;3&amp;#39;:10 &amp;#39;4&amp;#39;:11 &amp;#39;a&amp;#39;:1,5,6,7 &amp;#39;apple&amp;#39;:2 &amp;#39;f&amp;#39;:4` select &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39; :: tsvector; `&amp;#39;,&amp;#39; &amp;#39;1&amp;#39; &amp;#39;12&amp;#39; &amp;#39;2&amp;#39; &amp;#39;3&amp;#39; &amp;#39;4&amp;#39; &amp;#39;A&amp;#39; &amp;#39;F&amp;#39; &amp;#39;a&amp;#39; &amp;#39;apple&amp;#39; &amp;#39;一个&amp;#39; &amp;#39;锴&amp;#39; &amp;#39;陈&amp;#39;`</description></item><item><title>pgpool</title><link>https://chenkai0520.github.io/database/pgpool/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pgpool/</guid><description>什么是pgpool pgpool-II 是一个位于 PostgreSQL 服务器和 PostgreSQL 数据库客户端之间的中间件，它提供以下功能：
连接池 pgpool-II 保持已经连接到 PostgreSQL 服务器的连接，并在使用相同参数（例如：用户名，数据库，协议版本）连接进来时重用它们。它减少了连接开销，并增加了系统的总体吞吐量。 复制 pgpool-II 可以管理多个 PostgreSQL 服务器。激活复制功能并使在2台或者更多 PostgreSQL 节点中建立一个实时备份成为可能，这样，如果其中一台节点失效，服务可以不被中断继续运行。 负载均衡 如果数据库进行了复制，则在任何一台服务器中执行一个 SELECT 查询将返回相同的结果。pgpool-II 利用了复制的功能以降低每台 PostgreSQL 服务器的负载。它通过分发 SELECT 查询到所有可用的服务器中，增强了系统的整体吞吐量。在理想的情况下，读性能应该和 PostgreSQL 服务器的数量成正比。负载均衡功能在有大量用户同时执行很多只读查询的场景中工作的效果最好。 并行查询 使用并行查询时，数据可以被分割到多台服务器上，所以一个查询可以在多台服务器上同时执行，以减少总体执行时间。并行查询在查询大规模数据的时候非常有效。 现有的数据库应用程序基本上可以不需要修改就可以使用 pgpool-II start ## 安装pgpool-ii brew install pgpool-ii ## 安装扩展 create extension pgpool_recovery; ## If you are using PostgreSQL 9.4 or later, you can skip this section. create extension pgpool_regclass; ## 修改配置文件 常用命令 &amp;lt;!</description></item><item><title>pg中为存储过程添加进度</title><link>https://chenkai0520.github.io/database/pg_how_to_add_process_in_function/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_how_to_add_process_in_function/</guid><description>有时我们可能需要知道长时间调用存储过程的进度。
通过外部表 首先我想到通过修改一张外部表更新存储过程的进度，后来发现这样是不行的。存储过程执行中对数据库的改变在外部是获取不到的，它只有在执行完毕提交后，我们才能获取结果，所以这种方式我们获取到的进度可能全都是100%。
raise RAISE语句可以在sql运行过程中向程序抛出消息或错误，文档
用法如下所示： sql
RAISE INFO &amp;#39;model_progress:%&amp;#39;,json_build_object(&amp;#39;job_uid&amp;#39;,job_uid,&amp;#39;job_progress&amp;#39;,progress); 程序中我们还可以获取到存储过程抛出的消息：如node实现所示
const pool = new Pg.Pool(Config.db); pool.on(&amp;#39;connect&amp;#39;, (cl) =&amp;gt; { cl.on(&amp;#39;notice&amp;#39;, (msg)=&amp;gt; { //获取sql抛出的信息 DbNoticeHandler.handle(msg); }); });</description></item><item><title>pg中如何取消正在执行的存储过程</title><link>https://chenkai0520.github.io/database/cancel_runing_function/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/cancel_runing_function/</guid><description>如果存储过程执行过程，需要添加可以取消的功能，这里我们需要用到两个函数。
pg_backend_pid: 查询当前会话的服务器进程的进程ID， pg_cancel_backend(pid int): 取消后端的当前查询。如果调用角色是其后端被取消或已授予调用角色的角色的成员，则也允许这样做pg_signal_backend，但是只有超级用户可以取消超级用户后端。 demo 在函数中查询当前的pid create or replace function pg_cancel_backend() returns void as $$ declare backend_pid bigint; begin --查询当前pid backend_pid = pg_backend_pid(); loop raise notice &amp;#39;%&amp;#39;, format(&amp;#39;%1$s : backend_pid: %2$s&amp;#39;, now(),backend_pid); perform pg_sleep(2); end loop; end; $$ language plpgsql; -- 2019-07-25 03:47:30.783608+00 : backend_pid: 13677 根据pid取消当前进程 select pg_cancel_backend(13677);</description></item><item><title>pg中如何查询Geometry类型字段的坐标系</title><link>https://chenkai0520.github.io/database/pg_get_geometry_type/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_get_geometry_type/</guid><description>查询坐标系的方式 如没有显示指定 geometry(${geometryType},3857)
-- 查询到的坐标系是正确 select ST_SRID(the_geom_webmercator) from data.t_caa6d99c6eb14495b2238b4c0d56f051 -- 查询到的坐标系是0 select Find_SRID(&amp;#39;data&amp;#39;,&amp;#39;t_bcccd400c5bc8025aa0eed5fd5816de5&amp;#39;,&amp;#39;the_geom_webmercator&amp;#39;); select * from geometry_columns where f_table_name = &amp;#39;t_bcccd400c5bc8025aa0eed5fd5816de5e&amp;#39;</description></item><item><title>pg中对中文字段的排序</title><link>https://chenkai0520.github.io/database/pg_chinese_order/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_chinese_order/</guid><description>PostgreSQL中对字段排序时中文并不会按照拼音排序，在不同的字符集中，汉字的编码可能不一样，比如UTF8和GBK，其中GBK大致是按拼音的顺序进行编码的，而UTF8则不是。所以如果你的数据库使用了UTF8编码，对中文字段进行排序时，得到的并不是按拼音排序的结果。 PostgreSQL中，中文按拼音排序的编码包括GB18030, EUC_CN, GBK, BIG5, EUC_TW 等。为了得到拼音排序，可以使用编码转换后的值来排序，如convert_to(name,'GBK')。
对于多音字、生僻字排序结果不太准确：如根据汉字内码扩展规范(GBK) 在GBK编码10进制濮编码为58791，总编码为55260,</description></item><item><title>pg中的数据库时区</title><link>https://chenkai0520.github.io/database/pg_timezone/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_timezone/</guid><description>原因 系统主机与数据库时间不一致； 数据库配置文件中timezone与镜像系统里面设置的时区不一致
解决办法 修改数据库/var/lib/postgresql/data/postgresql.conf中的timezone或者镜像时区保持一致后重启数据库
timestamp with time zone，内部存储的值始终为UTC（通用协调时间，传统上称为格林威治标准时间）。具有指定显式时区的输入值将使用该时区的适当偏移量转换为UTC。如果输入字符串中未指定时区，则假定它位于系统的timezone参数指示的时区中，并使用区域的偏移量转换为UTC 。当一个timestamp with time zone值被输出，它总是从UTC转换成当前timezone区域，并作为在该区域中的本地时间显示。
步骤 查看数据库时区
show time zone; 查看系统时间与时区
date Thu Nov 19 09:39:58 CST 2015 date -R Thu, 19 Nov 2015 09:40:33 +0800 视图pg_timezone_names保存了所有可供选择的时区
select * from pg_timezone_names; 查看配置文件中时区设置，要想永久生效，此时需要修改配置文件
[grep timezone postgresql.conf log_timezone = 'US/Pacific' timezone = 'US/Pacific' 修改完配置时重新加载
[postgres@rudy_01 ~]$ pg_ctl reload server signaled [postgres@rudy_01 ~]$ psql postgres=# show time zone; TimeZone</description></item><item><title>pg的数据库配置</title><link>https://chenkai0520.github.io/database/pg_config/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_config/</guid><description>config一般文件在数据data目录下面如:/usr/local/var/postgres，如果你忘记了目录地址可以SHOW data_directory;查询出来,或者
select setting from pg_settings where name = &amp;#39;config_file&amp;#39;; -- 查询配置 table pg_hba_file_rules -- 使配置生效 SELECT pg_reload_conf(); pg_hba.conf文件介绍
pg_hba.conf文件 客户端认证是由一个配置文件(通常名为pg_hba.conf)控制的， 它存放在数据库集群的数据目录里。HBA的意思是&amp;quot;host-based authentication&amp;rdquo;， 也就是基于主机的认证。在initdb初始化数据目录的时候， 它会安装一个缺省的pg_hba.conf文件。不过我们也可以把认证配置文件放在其它地方； 参阅hba_file配置参数。 g_hba.conf文件的常用格式是一组记录，每行一条。空白行将被忽略， 井号#开头的注释也被忽略。记录不能跨行存在。 一条记录是由若干用空格和/或制表符分隔的字段组成。如果字段用引号包围，那么它可以包含空白。 在数据库、用户或地址文件中引用一个关键词（如，all 或 replication） 使这个词失去它的特殊含义，只是用这个名字匹配一个数据库、用户或主机。
每条记录声明一种连接类型、一个客户端 IP 地址范围(如果和连接类型相关的话)、 一个数据库名、一个用户名字、对匹配这些参数的连接使用的认证方法。第一条匹配连接类型、 客户端地址、连接请求的数据库名和用户名的记录将用于执行认证。这个处理过程没有 &amp;ldquo;跨越&amp;quot;或者&amp;quot;回头&amp;quot;的说法：如果选择了一条记录而且认证失败， 那么将不再考虑后面的记录。如果没有匹配的记录，那么访问将被拒绝。
每条记录可以是下面七种格式之一
local database user auth-method [auth-options] host database user address auth-method [auth-options] hostssl database user address auth-method [auth-options] hostnossl database user address auth-method [auth-options] host database user IP-address IP-mask auth-method [auth-options] hostssl database user IP-address IP-mask auth-method [auth-options] hostnossl database user IP-address IP-mask auth-method [auth-options] `` ## demo 允许在本机上的任何用户使用 Unix 域套接字(本地连接的缺省) 以任何数据库用户身份连接任何数据库 TYPE DATABASE USER ADDRESS METHOD local all all trust</description></item><item><title>pg触发器</title><link>https://chenkai0520.github.io/database/pg_trigger/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_trigger/</guid><description>触发器 一个触发器声明了当执行一种特定类型的操作时数据库应该自动执行一个特殊的函数。触发器可以被附加到表（分区的或者不分区的）、视图和外部表。 在表和外部表上，触发器可以被定义为在 INSERT、UPDATE或 DELETE操作之前或之后被执行， 可以为每个SQL语句被执行一次或者为每个修改的行 被执行一次。UPDATE 触发器可以进一步地设置为只针对UPDATE 语句的SET子句的特定列出发。触发器也可以被 TRUNCATE语句触发。如果一个触发器事件发生， 触发器函数会在适当的事件被调用来处理该事件。
触发器函数必须在触发器本身被创建之前被定义好。触发器函数必须被定义成一个没有参数的函数，并且返回类型为trigger（触发器函数通过一个特殊传递的TriggerData结构作为其输入，而不是以普通函数参数的形式）。 一旦一个合适的触发器函数被创建，就可以使用CREATE TRIGGER建立触发器。同一个触发器函数可以被用于多个触发器。
触发器函数规则 当一个PL/pgSQL函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：
NEW 数据类型是RECORD；该变量为行级触发器中的INSERT/UPDATE操作保持新数据行。在语句级别的触发器以及DELETE操作，这个变量是null。 OLD 数据类型是RECORD；该变量为行级触发器中的UPDATE/DELETE操作保持新数据行。在语句级别的触发器以及INSERT操作，这个变量是null。 TG_NAME 数据类型是name；该变量包含实际触发的触发器名。 TG_WHEN 数据类型是text；是值为BEFORE、AFTER或INSTEAD OF的一个字符串，取决于触发器的定义。 TG_LEVEL 数据类型是text；是值为ROW或STATEMENT的一个字符串，取决于触发器的定义。 TG_OP 数据类型是text；是值为INSERT、UPDATE、DELETE或TRUNCATE的一个字符串，它说明触发器是为哪个操作引发。 TG_RELID 数据类型是oid；是导致触发器调用的表的对象 ID。 TG_RELNAME 数据类型是name；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用TG_TABLE_NAME替代。 TG_TABLE_NAME 数据类型是name；是导致触发器调用的表的名称。 TG_TABLE_SCHEMA 数据类型是name；是导致触发器调用的表所在的模式名。 TG_NARGS 数据类型是integer；在CREATE TRIGGER语句中给触发器函数的参数数量。 TG_ARGV[] 数据类型是text数组；来自CREATE TRIGGER语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于tg_nargs）会导致返回一个空值。 一个触发器函数必须返回NULL或者是一个与触发器为之引发的表结构完全相同的记录/行值。 一个 PL/pgSQL 触发器函数 触发器函数说明文档
这个例子触发器保证：任何时候一个行在表中被插入或更新时，当前用户名和时间也会被标记在该行中。并且它会检查给出了一个雇员的姓名以及薪水是一个正值。
CREATE TABLE emp ( empname text, salary integer, last_date timestamp, last_user text ); CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$ BEGIN -- 检查给出了 empname 以及 salary IF NEW.</description></item><item><title>postgres 有用的sql</title><link>https://chenkai0520.github.io/database/pg_useful_sql/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_useful_sql/</guid><description>数据库迁移备份 备份：pg_dump -U postgres -d myDBname -f dump.sql 还原：
pg_dump -U postgres -d g-default -f g-default.sql
忽略某些schema psql -N data -N public_data -d g-default -U postgres -f g-default.sql
将mydb数据库转储到一个 SQL 脚本文件：pg_dump mydb &amp;gt; db.sql 将上述脚本导入一个(新建的)数据库newdb：psql -d newdb -f db.sql
将数据库转储为自定义格式的归档文件pg_dump -Fc mydb &amp;gt; db.dump 将数据库转储为目录格式归档：pg_dump -Fd mydb -f dumpdir 将数据库转储为目录格式归档，并行5个worker工作：pg_dump -Fd mydb -j 5 -f dumpdir 将归档文件导入一个(新建的)数据库newdb：pg_restore -d newdb db.dump
转储一个名为mytab的表：pg_dump -t mytab mydb &amp;gt; db.sql 转储detroit模式中所有以emp开头的表， 但是不包括employee_log表：pg_dump -t 'detroit.</description></item><item><title>postgresql中的sequence</title><link>https://chenkai0520.github.io/database/pg_sequence/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_sequence/</guid><description>sequence号是数据库系统按照一定规则自增的数字序列 sequence操作函数
Function Return Type Description currval(regclass) bigint Return value most recently obtained with nextval for specified sequence lastval() bigint Return value most recently obtained with nextval for any sequence nextval(regclass) bigint Advance sequence and return new value setval(regclass, bigint) bigint Set sequence&amp;#39;s current value setval(regclass, bigint, boolean) bigint Set sequence&amp;#39;s current value and is_called flag 创建sequence postgre文档
sequence操作函数定义
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] name [ AS data_type ] [ INCREMENT [ BY ] increment ] [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ] [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ] [ OWNED BY { table_name.</description></item><item><title>postgre中的复合类型</title><link>https://chenkai0520.github.io/database/pg_composite_type/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_composite_type/</guid><description>声明复合类型 Composite Types:复合类型Composite Types表示行或记录的结构; 它本质上只是一个字段名称及其数据类型。 PostgreSQL允许复合类型像用简单类型相同的方式使用。 例如，表的列可以声明为复合类型。 语法与CREATE TABLE相当，只是可以指定字段名称和类型; 目前不能包含任何约束（例如NOT NULL）。 请注意，AS关键字是必不可少的; 没有它，系统会认为有一种不同的CREATE TYPE命令，你会得到奇怪的语法错误。 以下是定义复合类型的两个简单示例：
CREATE TYPE complex AS ( r double precision, i double precision ); CREATE TYPE inventory_item AS ( name text, supplier_id integer, price numeric ); 定义了类型后，我们可以使用它们：
CREATE TABLE on_hand ( item inventory_item, count integer ); INSERT INTO on_hand VALUES (ROW(&amp;#39;fuzzy dice&amp;#39;, 42, 1.99), 1000); CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric AS &amp;#39;SELECT $1.price * $2&amp;#39; LANGUAGE SQL; SELECT price_extension(item, 10) FROM on_hand; 每当您创建表时，也会自动创建一个复合类型，其名称与表的名称相同，以表示表的行类型。</description></item><item><title>ubuntu添加pgrouting扩展</title><link>https://chenkai0520.github.io/database/pg_ubuntu_add_pgrouting/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/pg_ubuntu_add_pgrouting/</guid><description>sudo apt-add-repository -y ppa:ubuntugis/ppa sudo apt-add-repository -y ppa:georepublic/pgrouting sudo apt-get update ubuntu apt 官方存储库没有pgrouting。所以需要添加存储库 在Ubuntu或Debian上安装软件的众多方法之一是使用PPA（个人包存档），如果要添加新的PPA存储库，则必须以下列方式使用add-apt-repository命令
add-apt-repository ppa:some/ppa 在Debian中，基本操作系统和 有时 在Ubuntu上，您将看到缺少add-apt-repository命令的错误。
但是如果你尝试使用sudo apt-get install add-apt-repository，它将无法正常工作。 这是因为，你需要安装这个软件包才能安装add-apt-repository。修复add-apt-repository-command-not-found错误
apt-get update apt-get install software-properties-common 一旦安装了software-properties-common，您现在可以轻松地使用add-apt-repository或apt-add-repository命令来添加PPA
查询pgrouting版本
apt search pgrouting 安装对应版本的pgrouting
apt-get install postgresql-10-pgrouting 数据库中添加pgrouting扩展
CREATE EXTENSION pgrouting;</description></item><item><title>数据库关系类型</title><link>https://chenkai0520.github.io/database/db_relational/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai0520.github.io/database/db_relational/</guid><description>关联映射：一对一 一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。 数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。
一对一外键关联，图示如下：
一对一主键关联：要求两个表的主键必须完全一致，通过两个表的主键建立关联关系。图示如下： 关联映射：一对多/多对一 存在最普遍的映射关系，简单来讲就如球员与球队的关系； 一对多：从球队角度来说一个球队拥有多个球员 即为一对多 多对一：从球员角度来说多个球员属于一个球队 即为多对一数据表间一对多关系如下图：
关联映射：多对多 多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。 数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多。 数据表间多对多关系如下图： 对于Postgresql也有通过数组表示多对多关系，参考下面文章 https://medium.com/@leshchuk/mtm-on-arrays-in-postgresql-a97f3c50b8c6</description></item></channel></rss>