<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nodejs on CK's Blog</title><link>https://chenkai.life/nodejs/</link><description>Recent content in Nodejs on CK's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 21 Jul 2024 10:36:40 +0800</lastBuildDate><atom:link href="https://chenkai.life/nodejs/index.xml" rel="self" type="application/rss+xml"/><item><title>nodejs stream to buffer</title><link>https://chenkai.life/nodejs/stream-to-buffer/</link><pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/stream-to-buffer/</guid><description>/** * * @param {ReadableStream} stream */ async function streamToBuffer(stream) { return new Promise((resolve, reject) =&amp;gt; { const buffers = []; stream.on(&amp;#39;data&amp;#39;, (chunk) =&amp;gt; { buffers.push(chunk); }); stream.on(&amp;#39;end&amp;#39;, () =&amp;gt; { resolve(Buffer.concat(buffers)) }) stream.on(&amp;#39;error&amp;#39;, (error) =&amp;gt; { reject(error) }) }); } asyncIterator stream实现了异步迭代协议所以
/** * * @param {ReadableStream} stream */ async function streamToBuffer2(stream) { const buffers = []; for await (const data of stream) { buffers.push(data); } return Buffer.concat(buffers); } 或者 Array.</description></item><item><title>JsonWebToken</title><link>https://chenkai.life/nodejs/jsonwebtoken/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/jsonwebtoken/</guid><description>什么是 JSON Web Token？ JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑且独立的方式，用于在各方之间用 SON 对象安全地传输信息。此信息可以通过数字签名进行验证和信任。 JWT 可以使用加密算法（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。
什么时候应该使用 JSON Web 令牌 以下是 JSON Web 令牌有用的一些场景：
授权：这是使用 JWT 的最常见方案。一旦用户登录，每个后续请求将包括 JWT，允许用户访问该令牌允许的路由，服务和资源。 Single Sign On 是一种现在广泛使用 JWT 的功能，因为它的开销很小，并且能够在不同的域中轻松使用。
信息交换：JSON Web 令牌是在各方之间安全传输信息的好方法。因为 JWT 可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。
JSON Web 令牌结构 JSON Web Tokens 由.分隔的三个部分组成，它们是：
头 有效载荷 签名 因此，JWT 通常如xxxxx.yyyyy.zzzzz所示. 头 标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。
{ &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 然后，这个 JSON 被编码为 Base64Url，形成 JWT 的第一部分。</description></item><item><title>koa中间件源码解析</title><link>https://chenkai.life/nodejs/koa-middleware-analys/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/koa-middleware-analys/</guid><description>中间件是koa的核心，koa的中间件机制是一个剥洋葱式的模型，多个中间件通过use放进一个数组队列然后从外层开始执行，遇到next后进入队列中的下一个中间件，所有中间件执行完后开始回帧，执行队列中之前中间件中未执行的代码部分。
源码 koa在koa-compose中实现了中间件部分，
function compose (middleware) { // compose首先会对middleware进行参数检验，middleware必须是一个函数数组， if (!Array.isArray(middleware)) throw new TypeError(&amp;#39;Middleware stack must be an array!&amp;#39;) for (const fn of middleware) { if (typeof fn !== &amp;#39;function&amp;#39;) throw new TypeError(&amp;#39;Middleware must be composed of functions!&amp;#39;) } /** * @param {Object} context * @return {Promise} * @api public */ return function (context, next) { // last called middleware # let index = -1 return dispatch(0) async function dispatch (i) { // 多次调用next函数会导致1 &amp;lt;= index if (i &amp;lt;= index) return Promise.</description></item><item><title>koa跨域</title><link>https://chenkai.life/nodejs/koa-cross-domain/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/koa-cross-domain/</guid><description>跨域 为什么会有跨域问题？ 这是浏览器的同源策略所造成的，同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
一定要注意跨域是浏览器的限制，其实你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。
如何解决跨域? jsonp: 带有src属性的标签都可以用来， 但是只能处理GET请求 document.domain + iframe跨域 location.hash + iframe window.name + iframe postMessage跨域 Nginx配置反向代理 CORS（跨域资源共享）：支持所有类型的HTTP请求 相信大家对于以上的解决方法都很熟悉，这里不再对每一种方法展开讲解，接下来主要讲一下CORS； 简单请求和非简单请求 浏览器将CORS跨域请求分为简单请求和非简单请求；
如果你使用nginx反向代理解决的跨域问题，则不会有跨域请求这个说法了，因为nginx反向代理就使得前后端是同一个域了，就不存在跨域问题了。
只要同时满足一下两个条件，就属于简单请求 (1)使用下列方法之一：
head get post (2)请求的Heder是
Accept Accept-Language Content-Language Content-Type: 只限于三个值： application/x-www-form-urlencoded multipart/form-data text/plain 不同时满足上面的两个条件，就属于非简单请求。 浏览器对这两种的处理，是不一样的。
简单请求 例子 对于简单请求，浏览器直接发出CORS请求。具体来说，就是头信息之中，增加一个Origin字段。
上面这个例子，post``Content-Type``application/x-www-form-urlencoded``Access-Control-Allow-Origin: http://127.0.0.1:3000``Origin``Origin
CORS请求相关的字段，都以 Access-Control-开头 Access-Control-Allow-Origin
：必选
请求头Origin字段的值 *：接受任何域名 Access-Control-Allow-Credentials
：可选，
true: 表示允许发送cookie，此时Access-Control-Allow-Origin不能设置为*，必须指定明确的，与请求网页一致的域名。 不设置该字段：不需要浏览器发送cookie Access-Control-Expose-Headers
：可选
响应报头指示哪些报头可以公开为通过列出他们的名字的响应的一部分。默认情况下，只显示6个简单的响应标头： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 如果想要让客户端可以访问到其他的首部信息，可以将它们在 Access-Control-Expose-Headers 里面列出来。 withCredentials 属性 CORS请求默认不发送Cookie和HTTP认证信息，如果要把Cookie发到服务器，一方面需要服务器同意，设置响应头Access-Control-Allow-Credentials: true,另一方面在客户端发出请求的时候也要进行一些设置;</description></item><item><title>node Promise 转换</title><link>https://chenkai.life/nodejs/node-promise/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-promise/</guid><description>如果你曾经使用 Javascript，你必须有经验的回调。Javascript 以其内置的异步哲学而闻名。从标准内置模块到其他框架和库，回调无处不在。这就是在 Javascript 中完成异步编程。但是回调有一个黑暗的一面。这叫 Callback Hells。
回调地狱的解决方案是 Promises。而不是通过回调同步返回值或传递结果，我们可以返回一个 Promise，我们将来会返回一些值或错误。 有许多像好的库如 Bluebird 和 Q 可以用来处理 Promise。但是内置的模块和很多其他库不能使用 Promises。这些库能够将传统的回调方法转换为 Promise，在 Node v8 中我们现在可以使用 util.promisify 来处理回调方法。根据 Node.js 的文档： util.promisify(original)
original Returns: const util = require(&amp;#34;util&amp;#34;); const fs = require(&amp;#34;fs&amp;#34;); const stat = util.promisify(fs.stat); stat(&amp;#34;.&amp;#34;) .then((stats) =&amp;gt; { // Do something with `stats` }) .catch((error) =&amp;gt; { // Handle the error. }); 或者; const util = require(&amp;#34;util&amp;#34;); const fs = require(&amp;#34;fs&amp;#34;); const stat = util.</description></item><item><title>node中的多进程</title><link>https://chenkai.life/nodejs/node-child-process/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-child-process/</guid><description>javascript 是单线程的并且只在一个进程中跑，
child_process child_process 模块提供了衍生子进程的能力，此功能主要由 child_process.spawn() 函数提供：
const { spawn } = require(&amp;#34;child_process&amp;#34;); const ls = spawn(&amp;#34;ls&amp;#34;, [&amp;#34;-lh&amp;#34;, &amp;#34;/usr&amp;#34;]); ls.stdout.on(&amp;#34;data&amp;#34;, (data) =&amp;gt; { console.log(`stdout: ${data}`); }); ls.stderr.on(&amp;#34;data&amp;#34;, (data) =&amp;gt; { console.error(`stderr: ${data}`); }); ls.on(&amp;#34;close&amp;#34;, (code) =&amp;gt; { console.log(`子进程退出，使用退出码 ${code}`); }); child_process.spawn() 方法异步地衍生子进程，且不阻塞 Node.js 事件循环。 child_process.spawnSync() 函数则以同步的方式提供了等效的功能，但会阻塞事件循环直到衍生的进程退出或终止。为方便起见， child_process 模块提供了 child_process.spawn() 和 child_process.spawnSync() 的一些同步和异步的替代方法。 这些替代方法中的每一个都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。
[child_process.spawn()]: 方法使用给定的 command 衍生一个新进程，并带上 args 中的命令行参数。 如果省略 args，则其默认为一个空数组。 [child_process.exec()]: 衍生一个 shell 然后在该 shell 中执行 command，并缓冲任何产生的输出。 [child_process.</description></item><item><title>node复用原始接口下载表格</title><link>https://chenkai.life/nodejs/node-download-biaoge-sheji/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-download-biaoge-sheji/</guid><description>我们在做后台开发时可能有很多接口的数据需要下载下来,如果从头开发无疑会有很多重复代码如参数校验、权限验证等，接下来我谈谈我是如何利用现有的 node 接口下载表格
json 数组转表格 一般我们的接口返回的是 json 数组,我们很容易想到只需要把返回数据的 json 转为表格下载就可以了其他逻辑都是一样的，node 有很多现成的库可以处理如xlsx
function frows2XlsxBufferile(formatData) { const ws = xlsx.utils.json_to_sheet(formatData); const wb = xlsx.utils.book_new(); xlsx.utils.book_append_sheet(wb, ws, &amp;#34;SheetJS&amp;#34;); return xlsx.write(wb, { type: &amp;#34;buffer&amp;#34;, bookType: &amp;#34;xlsx&amp;#34; }); } 在 ctx 上下文添加下载文件的方法 默认情况下返回的是文本数据这里需要处理,我这里需要在header中声明返回的内容是一个需要下载的文件
function file(name, data) { // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition // 说明浏览器应该将内容下载到本地；filename 的值预填为下载后的文件名 this.response.set(&amp;#34;Content-disposition&amp;#34;, `attachment;filename=&amp;#34;${name}&amp;#34;`); // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type // 说明返回的是一个二进制流数据 this.response.set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/octet-stream&amp;#34;); return (this.response.body = data); } 返回表格 我们将上面封装下，方便调用,
async download() { const { ctx } = this; const result = await this.</description></item><item><title>node程序放入docker</title><link>https://chenkai.life/nodejs/node-docker/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-docker/</guid><description>准备 demo 程序 index.js &amp;#34;use strict&amp;#34;; const express = require(&amp;#34;express&amp;#34;); // Constants const PORT = 6677; const HOST = &amp;#34;0.0.0.0&amp;#34;; // App const app = express(); app.get(&amp;#34;/&amp;#34;, (req, res) =&amp;gt; { res.send(&amp;#34;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&amp;#34;); }); app.listen(PORT, HOST); console.log(`Running on http://${HOST}:${PORT}`); 根目录新建Dockerfile文件 ## 定义我们需要从哪个镜像进行构建 FROM node:8 ## 在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ &amp;#34;node&amp;#34;, &amp;#34;index.js&amp;#34; ] .dockerignore 文件 这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中 node_modules npm-debug.</description></item><item><title>使用koa创建基于http2的服务</title><link>https://chenkai.life/nodejs/koa-http2/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/koa-http2/</guid><description>使用koa创建服务 使用koa我们可以很容易创建一个http服务
const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.body = &amp;#39;Hello World&amp;#39;; }); app.listen(3000); 其中app.listen(...) 方法只是以下内容的糖：
const http = require(&amp;#39;http&amp;#39;); const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.body = &amp;#39;Hello World&amp;#39;; }); http.createServer(app.callback()).listen(3000) 创建一个http2服务 想当然的我们可能会首先尝试使用一下代码创建一个http2服务
const http2 = require(&amp;#39;http2&amp;#39;); const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.body = &amp;#39;Hello World&amp;#39;; }); http2.</description></item></channel></rss>