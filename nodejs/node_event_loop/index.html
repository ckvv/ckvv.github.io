<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=description content="事件循环    事件循环是 Node.js 处理非阻塞 I/O 操作的机制，事件循环使Node.js可以通过将操作转移到系统内核中来执行非阻塞I/O操作，由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会告诉Node.js，将适当的回调添加到轮询队列中以最终执行。
事件轮询机制解析    面的图表展示了事件循环操作顺序的简化概览,每个框被称为事件循环机制的一个阶段。每个阶段都有一个FIFO队列来执行回调。当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。
 ┌───────────────────────────┐ ┌─>│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │<─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ 阶段概述"><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="node事件循环"><meta name=twitter:description content="事件循环    事件循环是 Node.js 处理非阻塞 I/O 操作的机制，事件循环使Node.js可以通过将操作转移到系统内核中来执行非阻塞I/O操作，由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会告诉Node.js，将适当的回调添加到轮询队列中以最终执行。
事件轮询机制解析    面的图表展示了事件循环操作顺序的简化概览,每个框被称为事件循环机制的一个阶段。每个阶段都有一个FIFO队列来执行回调。当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。
 ┌───────────────────────────┐ ┌─>│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │<─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ 阶段概述"><meta property="og:title" content="node事件循环"><meta property="og:description" content="事件循环    事件循环是 Node.js 处理非阻塞 I/O 操作的机制，事件循环使Node.js可以通过将操作转移到系统内核中来执行非阻塞I/O操作，由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会告诉Node.js，将适当的回调添加到轮询队列中以最终执行。
事件轮询机制解析    面的图表展示了事件循环操作顺序的简化概览,每个框被称为事件循环机制的一个阶段。每个阶段都有一个FIFO队列来执行回调。当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。
 ┌───────────────────────────┐ ┌─>│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │<─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ 阶段概述"><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai0520.github.io/nodejs/node_event_loop/"><meta property="article:published_time" content="2021-07-09T15:37:56+08:00"><meta property="article:modified_time" content="2021-07-09T15:37:56+08:00"><title>node事件循环 · CK's Blog</title><link rel=canonical href=https://chenkai0520.github.io/nodejs/node_event_loop/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.2b4a48c7f9f55547746a8263b9a071145bdce989003e514b08231c227b976bbb.css integrity="sha256-K0pIx/n1VUd0aoJjuaBxFFvc6YkAPlFLCCMcInuXa7s=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.cd9d629837ad7459d8d165a86c9b6cfa9b60dc06f02a6322bd4c0d2558782224.css integrity="sha256-zZ1imDetdFnY0WWobJts+ptg3AbwKmMivUwNJVh4IiQ=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.72.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/index.xml>RSS</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=google>Google</button>
<button class=search-btn data-type=github>GitHub</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai0520.github.io/nodejs/node_event_loop/>node事件循环</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title target=_blank href=https://github.com/chenkai0520/chenkai0520.github.io/edit/main/content/nodejs/node_event_loop.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2021-07-09T15:37:56+08:00>2021-07-09</time></span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><span class=tag><a href=/tags/node/>node</a></span></div></div><h2 id=事件循环>事件循环
<a class=heading-link href=#%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af><i class="fa fa-link" aria-hidden=true></i></a></h2><p>事件循环是 Node.js 处理非阻塞 I/O 操作的机制，事件循环使Node.js可以通过将操作转移到系统内核中来执行非阻塞I/O操作，由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会告诉Node.js，将适当的回调添加到轮询队列中以最终执行。</p><h2 id=事件轮询机制解析>事件轮询机制解析
<a class=heading-link href=#%e4%ba%8b%e4%bb%b6%e8%bd%ae%e8%af%a2%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90><i class="fa fa-link" aria-hidden=true></i></a></h2><p>面的图表展示了事件循环操作顺序的简化概览,每个框被称为事件循环机制的一个阶段。每个阶段都有一个FIFO队列来执行回调。当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p><pre><code>   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
</code></pre><p>阶段概述</p><h2 id=timers>timers
<a class=heading-link href=#timers><i class="fa fa-link" aria-hidden=true></i></a></h2><p>本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。，计时器指定可以执行所提供回调的阈值，在指定的一段时间间隔后，计时器回调将被尽可能早地运行，操作系统调度或其它正在运行的回调可能会延迟它们。<strong>轮询阶段控制何时定时器执行</strong></p><h2 id=pending-callbacks>pending callbacks
<a class=heading-link href=#pending-callbacks><i class="fa fa-link" aria-hidden=true></i></a></h2><p>待定回调：执行延迟到下一个循环迭代的 I/O 回调。此阶段对某些系统操作（如 TCP 错误类型）执行回调。例如，如果 TCP 套接字在尝试连接时接收到 ECONNREFUSED，则某些 *nix 的系统希望等待报告错误。这将被排队以在挂起的回调阶段执行。</p><h2 id=idle-prepare>idle, prepare
<a class=heading-link href=#idle-prepare><i class="fa fa-link" aria-hidden=true></i></a></h2><p>仅系统内部使用</p><h2 id=poll>poll
<a class=heading-link href=#poll><i class="fa fa-link" aria-hidden=true></i></a></h2><p>检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
轮询 阶段有两个重要的功能：</p><ul><li>计算应该阻塞和轮询I/O的时间。</li><li>然后处理轮询队列里的事件</li></ul><p>当事件循环进入轮询阶段且没有被调度的计时器时</p><ul><li>如果 轮询 队列 不是空的 ，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。</li><li>如果 轮询 队列 是空的<ul><li>如果脚本被 setImmediate() 调度，则事件循环将结束 轮询 阶段，并继续 检查 阶段以执行那些被调度的脚本。</li><li>如果脚本 未被 setImmediate()调度，则事件循环将等待回调被添加到队列中，然后立即执行。</li></ul></li></ul><p>一旦 轮询 队列为空，事件循环将检查 <em>已达到时间阈值的计时器</em>。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。</p><h2 id=check>check
<a class=heading-link href=#check><i class="fa fa-link" aria-hidden=true></i></a></h2><p>此阶段允许人员在轮询阶段完成后立即执行回调，setImmediate() 回调函数在这里执行</p><h2 id=close-callbacks>close callbacks
<a class=heading-link href=#close-callbacks><i class="fa fa-link" aria-hidden=true></i></a></h2><p>如果套接字或处理函数突然关闭（例如 socket.destroy()），则&rsquo;close&rsquo; 事件将在这个阶段发出。否则它将通过 process.nextTick() 发出。</p><h2 id=libuv>libuv
<a class=heading-link href=#libuv><i class="fa fa-link" aria-hidden=true></i></a></h2><p>libuv是跨平台支持库，最初是为Node.js编写的。它是基于事件驱动的异步I/O模型设计的。该库提供的不只是对不同I/O轮询机制的简单抽象：“句柄”和“流”为套接字和其他实体提供了高级抽象；还提供跨平台文件I/O和线程功能。提供事件循环以及基于回调的I / O和其他活动的通知。libuv提供了一些核心实用程序，例如计时器，无阻塞网络支持，异步文件系统访问，子进程等等。</p><p>libuv事件循环遵循通常的单线程异步I/O方法：所有（网络）I/O在非阻塞套接字上执行，套接字使用给定平台上可用的最佳机制进行轮询：Linux上的epoll，OSX上的kqueue和其他BSD，SunOS上的事件端口和Windows上的IOCP。
<img src=http://docs.libuv.org/en/v1.x/_images/architecture.png alt=dd></p><p>libuv是一个多平台支持库，主要关注异步I/O。它最初是为供Node.js使用而开发的，但也由Luvit，Julia，pyuv等使用。</p><ul><li>由epoll，kqueue，IOCP和事件端口支持的功能齐全的事件循环</li><li>Asynchronous TCP and UDP sockets</li><li>Asynchronous DNS resolution</li><li>Asynchronous file and file system operations</li><li>File system events</li><li>ANSI escape code controlled TTY</li><li>IPC with socket sharing, using Unix domain sockets or named pipes (Windows)</li><li>Child processes</li><li>Thread pool</li><li>Signal handling</li><li>High resolution clock</li><li>Threading and synchronization primitives</li></ul><h2 id=事件循环-1>事件循环
<a class=heading-link href=#%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af-1><i class="fa fa-link" aria-hidden=true></i></a></h2><p>libuv处理从操作系统收集事件或监视其他事件源的责任，并且用户可以注册事件发生时要调用的回调。
系统程序最常见的活动是处理输入和输出，而不是大量的数字运算。与使用常规的输入/输出函数（的问题read，fprintf等等）是它们 阻塞。与处理器的速度相比，实际写入硬盘或从网络读取花费的时间不成比例。在完成任务之前，函数不会返回，因此您的程序什么也不做。对于需要高性能的程序，这是主要障碍，因为其他活动和其他I / O操作一直处于等待状态。</p><p>标准解决方案之一是使用线程。每个阻塞的I / O操作均在单独的线程（或线程池）中启动。当阻塞函数在线程中被调用时，处理器可以安排另一个线程运行，这实际上需要CPU。</p><p>libuv遵循的方法使用另一种样式，即异步，非阻塞样式。大多数现代操作系统都提供事件通知子系统。例如，read套接字上的常规调用将阻塞，直到发送者实际发送了一些东西为止。而是，应用程序可以请求操作系统监视套接字并将事件通知放入队列中。应用程序可以方便地检查事件（也许在最大程度地使用处理器之前进行一些数字运算）并获取数据。之所以是异步的，是因为应用程序在某一时刻表达了兴趣，然后又在另一点（时间和空间）使用了数据。它是 非阻塞的因为应用程序进程可以自由执行其他任务。这与libuv的事件循环方法非常吻合，因为可以将操作系统事件视为另一个libuv事件。非阻塞确保其他事件可以像它们进入[1]一样快地继续处理。</p><blockquote><p>参考<a href=https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/>nodejs</a>
<a href=http://docs.libuv.org/en/v1.x/guide/basics.html#event-loops>libuv</a></p></blockquote><div id=vcomments></div></article></section></div></main><script src=/js/coder.min.a350362441276ec5c1671926420497bb8e52b63ead1d51d3c9bc4342d0039526.js integrity="sha256-o1A2JEEnbsXBZxkmQgSXu45Stj6tHVHTybxDQtADlSY="></script><script src=/js/custom.js></script></body></html>