<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=theme-color content="#ffffff"><meta name=color-scheme content="light dark"><meta name=description content="js 中 this 指当前执行代码的环境对象，this 不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了 this 的值
全局环境 浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &#34;MDN&#34;; console.log(window.b); // &#34;MDN&#34; console.log(b); // &#34;MDN&#34; node 环境中 this 是一个空对象
console.log(this); // {} 函数（运行内）环境 在函数内部，this 的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1() { return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined"><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="js中的this"><meta name=twitter:description content="js 中 this 指当前执行代码的环境对象，this 不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了 this 的值
全局环境 浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &#34;MDN&#34;; console.log(window.b); // &#34;MDN&#34; console.log(b); // &#34;MDN&#34; node 环境中 this 是一个空对象
console.log(this); // {} 函数（运行内）环境 在函数内部，this 的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1() { return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined"><meta property="og:title" content="js中的this"><meta property="og:description" content="js 中 this 指当前执行代码的环境对象，this 不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了 this 的值
全局环境 浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &#34;MDN&#34;; console.log(window.b); // &#34;MDN&#34; console.log(b); // &#34;MDN&#34; node 环境中 this 是一个空对象
console.log(this); // {} 函数（运行内）环境 在函数内部，this 的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1() { return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined"><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/javascript/js-this/"><meta property="article:section" content="javascript"><meta property="article:published_time" content="2021-07-09T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-26T15:00:12+08:00"><title>js中的this · CK's Blog</title><link rel=canonical href=https://chenkai.life/javascript/js-this/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.56610f8c63ea4ca06cdac03f4fafe3e818c64566f988301b72895eb047082c51.css integrity="sha256-VmEPjGPqTKBs2sA/T6/j6BjGRWb5iDAbcolesEcILFE=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/favicon.ico><link rel=apple-touch-icon type=image/png sizes=256x256 href=/images/favicon-512x512.png><meta name=generator content="Hugo 0.101.0"><link rel=manifest href=/manifest.webmanifest></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><details id=table-of-contents-wapper><summary><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></summary></details><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/marks/>Marks</a></li><li class=navigation-item><a class=navigation-link href=https://github.com/ckvv/ckvv.github.io/new/main/content>Create</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=github>GitHub</button>
<button class=search-btn data-type=google>Google</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/javascript/js-this/>js中的this</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title rel=noopener target=_blank href=https://github.com/ckvv/ckvv.github.io/edit/main/content/javascript/js-this.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2021-07-09T00:00:00Z>2021-07-09</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/javascript/>JavaScript</a></span></div></div><p>js 中 this 指当前执行代码的环境对象，this 不能在执行期间被赋值如<code>this = null</code>，在绝大多数情况下，函数的调用方式决定了 this 的值</p><h2 id=全局环境>全局环境
<a class=heading-link href=#%e5%85%a8%e5%b1%80%e7%8e%af%e5%a2%83><i class="fa fa-link" aria-hidden=true></i></a></h2><p>浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 在浏览器中, window 对象同时也是全局对象：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span> <span style=color:#f92672>===</span> window); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>37</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(window.<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// 37
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;MDN&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(window.<span style=color:#a6e22e>b</span>); <span style=color:#75715e>// &#34;MDN&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>b</span>); <span style=color:#75715e>// &#34;MDN&#34;
</span></span></span></code></pre></div><p>node 环境中 this 是一个空对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>); <span style=color:#75715e>//  {}
</span></span></span></code></pre></div><h2 id=函数运行内环境>函数（运行内）环境
<a class=heading-link href=#%e5%87%bd%e6%95%b0%e8%bf%90%e8%a1%8c%e5%86%85%e7%8e%af%e5%a2%83><i class="fa fa-link" aria-hidden=true></i></a></h2><p>在函数内部，this 的值取决于函数被调用的方式</p><p>因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f1</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//在浏览器中：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>f1</span>() <span style=color:#f92672>===</span> window; <span style=color:#75715e>//在浏览器中，全局对象是window
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//在Node中：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>f1</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>global</span>;
</span></span></code></pre></div><p>严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#e6db74>&#34;use strict&#34;</span>; <span style=color:#75715e>// 这里是严格模式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f2</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>f2</span>() <span style=color:#f92672>===</span> <span style=color:#66d9ef>undefined</span>; <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>window.<span style=color:#a6e22e>f2</span>(); <span style=color:#75715e>//  window
</span></span></span></code></pre></div><p>如果要想把 this 的值从一个环境传到另一个，就要用 call 或 apply 方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Custom&#34;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这个属性是在global对象定义的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Global&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>whatsThis</span>(<span style=color:#a6e22e>arg</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span>; <span style=color:#75715e>// this的值取决于函数的调用方式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>whatsThis</span>(); <span style=color:#75715e>// &#39;Global&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>whatsThis</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>obj</span>); <span style=color:#75715e>// &#39;Custom&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>whatsThis</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>obj</span>); <span style=color:#75715e>// &#39;Custom&#39;
</span></span></span></code></pre></div><p>当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自 Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>d</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第一个参数是作为‘this’使用的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 后续参数作为参数传递给函数调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>add</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>o</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>); <span style=color:#75715e>// 1 + 3 + 5 + 7 = 16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第一个参数也是作为‘this’使用的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 第二个参数是一个数组，数组里的元素用作函数调用中的参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>add</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>o</span>, [<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>]); <span style=color:#75715e>// 1 + 3 + 10 + 20 = 34
</span></span></span></code></pre></div><p>使用 call 和 apply 函数的时候要注意，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。因此，如果传递的值是一个原始值比如 7 或 &lsquo;foo&rsquo;，那么就会使用相关构造函数将它转换为对象，所以原始值 7 会被转换为对象，像 new Number(7) 这样，而字符串 &lsquo;foo&rsquo; 转化成 new String(&lsquo;foo&rsquo;) 这样，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bar</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//原始值 7 被隐式转换为对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bar</span>.<span style=color:#a6e22e>call</span>(<span style=color:#ae81ff>7</span>); <span style=color:#75715e>// Number {7}
</span></span></span></code></pre></div><p>ECMAScript 5 引入了 Function.prototype.bind。调用 f.bind(someObject)会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>bind</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;azerty&#34;</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>g</span>()); <span style=color:#75715e>// azerty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>bind</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;yoo&#34;</span>,
</span></span><span style=display:flex><span>}); <span style=color:#75715e>// bind只生效一次！
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>h</span>()); <span style=color:#75715e>// azerty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>37</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>f</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>f</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>g</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>g</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>h</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>h</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>(), <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>g</span>(), <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>h</span>()); <span style=color:#75715e>// 37, azerty, azerty
</span></span></span></code></pre></div><h2 id=箭头函数>箭头函数
<a class=heading-link href=#%e7%ae%ad%e5%a4%b4%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>在箭头函数中，this 与封闭词法环境的 this 保持一致。在全局代码中，它将被设置为全局对象,无论如何，foo 的 this 被设置为他被创建时的环境</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>globalObject</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> () =&gt; <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>globalObject</span>); <span style=color:#75715e>// true
</span></span></span></code></pre></div><p>如果将 this 传递给 call、bind、或者 apply，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为 null。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>foo</span> };
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>foo</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>globalObject</span>); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 尝试使用call来设定this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>obj</span>) <span style=color:#f92672>===</span> <span style=color:#a6e22e>globalObject</span>); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 尝试使用bind来设定this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#a6e22e>obj</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>globalObject</span>); <span style=color:#75715e>// true
</span></span></span></code></pre></div><p>箭头函数的 this 被设置为封闭的词法环境,一个赋值给了 obj.bar 的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 A 调用时，函数 B 的 this 被永久设置为 obj.bar（函数 A）的 this。当返回的函数（函数 B）被调用时，它 this 始终是最初设置的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 创建一个含有bar方法的obj对象，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// bar返回一个函数，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 这个函数返回this，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 这个返回的函数是以箭头函数创建的，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 所以它的this被永久绑定到了它外层函数的this。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// bar的值可以在调用中设置，这反过来又设置了返回函数的值。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>bar</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> () =&gt; <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 将返回的函数的引用赋值给fn。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>bar</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 直接调用fn而不设置this，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 通常(即不使用箭头函数的情况)默认为全局对象
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 若在严格模式则为undefined
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>fn</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>obj</span>); <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 但是注意，如果你只是引用obj的方法，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 而没有调用它
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fn2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>bar</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>fn2</span>()() <span style=color:#f92672>==</span> window); <span style=color:#75715e>// true
</span></span></span></code></pre></div><h2 id=作为对象的方法>作为对象的方法
<a class=heading-link href=#%e4%bd%9c%e4%b8%ba%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h2><p>当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象;
当 o.f()被调用时，函数内的 this 将绑定到 o 对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>prop</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>37</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>f</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>prop</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>()); <span style=color:#75715e>// logs 37
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>window.<span style=color:#a6e22e>prop</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span>(); <span style=color:#75715e>//3
</span></span></span></code></pre></div><p><strong>注意</strong>
这样的行为，根本不受函数定义方式或位置的影响。在前面的例子中，我们在定义对象 o 的同时，将函数内联定义为成员 f 。但是，我们也可以先定义函数，然后再将其附属到 o.f。这样做会导致相同的行为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>prop</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>37</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>independent</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>prop</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>independent</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>()); <span style=color:#75715e>// logs 37
</span></span></span></code></pre></div><p><strong>这表明函数是从 o 的 f 成员调用的才是重点</strong></p><p>this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 g 当作对象 o.b 的函数调用。在这次执行期间，函数中的 this 将指向 o.b。事实证明，这与他是对象 o 的成员没有多大关系，最靠近的引用才是最重要的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>g</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>independent</span>, <span style=color:#a6e22e>prop</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>42</span> };
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>g</span>()); <span style=color:#75715e>// 42
</span></span></span></code></pre></div><h2 id=原型链中的-this>原型链中的 this
<a class=heading-link href=#%e5%8e%9f%e5%9e%8b%e9%93%be%e4%b8%ad%e7%9a%84-this><i class="fa fa-link" aria-hidden=true></i></a></h2><p>如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法在对象上一样</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>f</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>o</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>f</span>()); <span style=color:#75715e>// 5
</span></span></span></code></pre></div><p>在这个例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。虽然在对 f 的查找过程中，最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p。也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p。这是 JavaScript 的原型继承中的一个有趣的特性。</p><h2 id=getter-与-setter-中的-this>getter 与 setter 中的 this
<a class=heading-link href=#getter-%e4%b8%8e-setter-%e4%b8%ad%e7%9a%84-this><i class="fa fa-link" aria-hidden=true></i></a></h2><p>再次，相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>sum</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>c</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>c</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>average</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>c</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>o</span>, <span style=color:#e6db74>&#34;sum&#34;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>get</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>sum</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>enumerable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>configurable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>average</span>, <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>sum</span>); <span style=color:#75715e>// logs 2, 6
</span></span></span></code></pre></div><h2 id=作为构造函数>作为构造函数
<a class=heading-link href=#%e4%bd%9c%e4%b8%ba%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>当一个函数用作构造函数时（使用 new 关键字），它的 this 被绑定到正在构造的新对象。虽然构造器返回的默认值是 this 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 this 对象）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 构造函数这样工作:
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * function MyConstructor(){
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   // 函数实体写在这里
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   // 根据需要在this上创建属性，然后赋值给它们，比如：
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   this.fum = &#34;nom&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   // 等等...
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   // 如果函数具有返回对象的return语句，
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   // 则该对象将是 new 表达式的结果。
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   // 否则，表达式的结果是当前绑定到 this 的对象。
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   //（即通常看到的常见情况）。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * }
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>C</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>37</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>C</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// logs 37
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>C2</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>37</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>38</span> };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>C2</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// logs 38
</span></span></span></code></pre></div><h2 id=作为一个-dom-事件处理函数>作为一个 DOM 事件处理函数
<a class=heading-link href=#%e4%bd%9c%e4%b8%ba%e4%b8%80%e4%b8%aa-dom-%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>当函数被用作事件处理函数时，它的 this 指向触发事件的元素（一些浏览器在使用非 addEventListener 的函数动态添加监听函数时不遵守这个约定)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 被调用时，将关联的元素变成蓝色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bluify</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>currentTarget</span>); <span style=color:#75715e>// 总是 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 当 currentTarget 和 target 是同一个对象时为 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>target</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>style</span>.<span style=color:#a6e22e>backgroundColor</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;#A5D9F3&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取文档中的所有元素的列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>elements</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementsByTagName</span>(<span style=color:#e6db74>&#34;*&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>elements</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>elements</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#34;click&#34;</span>, <span style=color:#a6e22e>bluify</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=作为一个内联事件处理函数>作为一个内联事件处理函数
<a class=heading-link href=#%e4%bd%9c%e4%b8%ba%e4%b8%80%e4%b8%aa%e5%86%85%e8%81%94%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>当代码被内联 on-event 处理函数调用时，它的 this 指向监听器所在的 DOM 元素</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onclick</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;alert(this.tagName.toLowerCase());&#34;</span>&gt;Show this&lt;/<span style=color:#f92672>button</span>&gt;
</span></span></code></pre></div><p>注意只有外层代码中的 this 是这样设置的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onclick</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;alert((function(){return this})());&#34;</span>&gt;Show inner this&lt;/<span style=color:#f92672>button</span>&gt;
</span></span></code></pre></div><p>在这种情况下，没有设置内部函数的 this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置 this 时指向的默认对象）</p><div id=cusdis_thread data-host=https://cusdis.com data-app-id=c2b015f9-9a4b-4997-b66f-f9c6ca26ebdd data-page-id=3e1d641aee55b2b23b938ed449bcc04f data-page-url=https://chenkai.life/javascript/js-this/ data-page-title=js中的this data-iframe=/js/cusdis/iframe.umd.js data-style=/js/cusdis/style.css></div></article></section></div></main><script src=/js/coder.min.cb0c595e02234420f3ad3886bf4a9bd2874d0e1e78e090138a9ef158b35aaf17.js integrity="sha256-ywxZXgIjRCDzrTiGv0qb0odNDh544JATip7xWLNarxc="></script>
<script src=/js/custom.js></script>
<script src=/js/font.min.js></script></body><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></html>