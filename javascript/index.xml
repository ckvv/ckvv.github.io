<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascripts on CK's Blog</title><link>https://chenkai.life/javascript/</link><description>Recent content in Javascripts on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Jul 2021 15:37:56 +0800</lastBuildDate><atom:link href="https://chenkai.life/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>axios核心源码解读</title><link>https://chenkai.life/javascript/axios_analyse/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/axios_analyse/</guid><description>转载自axios 核心源码解读
介绍axios 一直在使用axios库，在享受它带来的便利的同时，总感觉不读读它的源码有点对不起它，刚好网上介绍axios源码的文章较少，所以写下这篇文章，权当抛砖引玉。
axios是同构的JavaScript的异步请求库，它可以在浏览器端和NodeJS环境里使用。
VueJS的作者尤大也推荐这个工具，它除了异步请求网络资源功能，还有如下功能：
提供代理功能 提供了拦截器（类似中间件），可以注册在请求发出去之前和收到响应之后的操作 可以获取上传进度和下载进度 提供的adapter选项可以模拟响应数据 自定义引起报错的响应码范围 提供了取消请求的功能 axios的GitHub地址。
那么，它是怎么办到的呢？ 首先说说为什么它可以在浏览器端和NodeJS环境中使用 在axios中，使用适配器设计模式来屏蔽平台的差异性，让使用者可以在浏览器端和NodeJS环境中使用同一套API发起http请求。
axios的默认配置里的adapter是通过getDefaultAdapter()方法来获取的，它的逻辑如下：
function getDefaultAdapter() { var adapter; // Only Node.JS has a process variable that is of [[Class]] process if (typeof process !== &amp;#39;undefined&amp;#39; &amp;amp;&amp;amp; Object.prototype.toString.call(process) === &amp;#39;[object process]&amp;#39;) { // For node use HTTP adapter adapter = require(&amp;#39;./adapters/http&amp;#39;); } else if (typeof XMLHttpRequest !</description></item><item><title>defineProperty</title><link>https://chenkai.life/javascript/js_defineproperty/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_defineproperty/</guid><description>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
Object.defineProperty(obj, prop, descriptor) obj:要在其上定义属性的对象。 prop:要定义或修改的属性的名称。 descriptor:将被定义或修改的属性描述符。 描述符可以有以下属性：
configurable：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false enumerable： 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中，default：false value： 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined writable： 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 get： 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象 set： 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 @return:传递给函数的对象。
example // 数组拦截 /** * * @param {array} data */ function observe(data) { if (!Array.isArray(data)) { return; } // 取出所有数组遍历 data.forEach(function(val,index) { Object.defineProperty(data, index, { enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() { return val; }, set: function(newVal) { console.</description></item><item><title>get和set</title><link>https://chenkai.life/javascript/js_get_and_set/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_get_and_set/</guid><description>你可以在支持添加新属性的任何标准的内置对象或用户定义的对象内定义getter(访问方法)和setter(设置方法)。使用对象字面量语法定义getters和setters方法。
get get语法将对象属性绑定到查询该属性时将被调用的函数,有时需要允许访问返回动态计算值的属性，或者你可能需要反映内部变量的状态，而不需要使用显式方法调用。在JavaScript中，可以使用 getter 来实现。虽然可以使用 getter 和 setter 来创建一个伪属性类型，但是不可能同时将一个 getter 绑定到一个属性并且该属性实际上具有一个值
使用get语法时应注意以下问题：
可以使用数值或字符串作为标识； 必须不带参数； 它不能与另一个 get 或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 { get x() { }, get x() { } } 和 { x: &amp;hellip;, get x() { } }）。 可通过 delete 操作符删除 getter。 在新对象初始化时定义一个getter 这会为obj创建一个伪属性latest，它会返回log数组的最后一个元素,注意，尝试为latest分配一个值不会改变它。
var obj = { log: [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;], get latest() { if (this.log.length == 0) { return undefined; } return this.</description></item><item><title>JavaScript脚手架</title><link>https://chenkai.life/javascript/js_cli_jiaoshoujia/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_cli_jiaoshoujia/</guid><description>什么是脚手架 脚手架是为了保证各施工过程顺利进行而搭设的工作平台。在项目开发中我们把创建项目结构模版的工具也称之为脚手架。如vue-cli，create-react-app等。这些脚手架等原理都一样，即用Node.js命令行程序生成项目模版。
第一个Node.js命令行脚本 编写脚手架其实就是Node.js命令行开发,和写shell脚本类似，使用JavaScript语言，写一个可执行脚本 hello wold过程如下： 新建一个hello文件，其中#!/usr/bin/env node不可少，其作用是它告诉系统这个脚本需要用node解释器来执行，语法与node一样。
#!/usr/bin/env node console.log('hello world'); 然后,修改的权限
chmod 755 hello 执行脚本
./hello 如果想把 hello 前面的路径去除，可以将 hello 的路径加入环境变量 PATH。但是，另一种更好的做法，是在当前目录下新建 package.json ，写入下面的内容。
{ &amp;#34;name&amp;#34;: &amp;#34;hello&amp;#34;, &amp;#34;bin&amp;#34;: { &amp;#34;hello&amp;#34;: &amp;#34;hello&amp;#34; } } 然后执行 npm link 命令。
npm link 执行脚本
hello 写一个脚手架 脚手架开发与上面过程类似，有一些npm库可以帮助我们开发命令行工具如shelljs、commander，它们封装了node命令行命令可以更方便命令行开发。 文件目录结构
. ├── bin │ └── ckoa.js ├── package-lock.json ├── package.json └── utils └── download.js ckoa.js Node.</description></item><item><title>js中的this</title><link>https://chenkai.life/javascript/js_this/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_this/</guid><description>js中this指当前执行代码的环境对象，this不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了this的值
全局环境 浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &amp;#34;MDN&amp;#34;; console.log(window.b) // &amp;#34;MDN&amp;#34; console.log(b) // &amp;#34;MDN&amp;#34; node环境中this是一个空对象
console.log(this) // {} 函数（运行内）环境 在函数内部，this的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1(){ return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined
&amp;#34;use strict&amp;#34;; // 这里是严格模式 function f2(){ return this; } f2() === undefined; // true window.</description></item><item><title>js的Class的继承</title><link>https://chenkai.life/javascript/js_class/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_class/</guid><description>转载自https://es6.ruanyifeng.com/#docs/class-extends
简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
class Point { } class ColorPoint extends Point { } 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。
class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + &amp;#39; &amp;#39; + super.toString(); // 调用父类的toString() } } 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
class Point { /* ... */ } class ColorPoint extends Point { constructor() { } } let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</description></item><item><title>js的prototype</title><link>https://chenkai.life/javascript/js_prototype/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_prototype/</guid><description>什么是原型链 首先我们需要知道什么是原型，在javascript中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型（prototype）,我们可以添加一些属性到原型上面,然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个的实例。每个实例对象都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）. 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。
如何利用原型链实现继承 假设这里有两个类
// 交通工具 function Transportation(name){ this.name = name; // 该属性没有定义到原型链上,可以通过Object.keys获取 this.say = function(){ console.log(`Transportation： ${this.name}是交通工具`); } } Object.assign(Transportation.prototype,{ move : function (){ console.log(`Transportation: ${this.name}会移动`); }, }); // 汽车 function Car(name){ // 调用Transportation构造函数，绑定this变量 我们也可以 // this.name = name; Transportation.call(this, name); } 此时Car的原型是
new Car() ----&amp;gt; Car.prototype ----&amp;gt; Object.prototype ----&amp;gt; null 要实现继承我们需要将该对象的原型指向要继承对象的原型，如
new Car() ----&amp;gt; Car.</description></item><item><title>js的迭代器</title><link>https://chenkai.life/javascript/js_iterator/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_iterator/</guid><description>什么是迭代器 ECMAScript 2015的几个补充，并不是新的内置实现或语法，而是协议。这些协议可以被任何遵循某些约定的对象来实现。有两个协议：可迭代协议和迭代器协议。 JavaScript 提供了许多迭代集合的方法，从简单的 for 循环到 map() 和 filter()，迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for&amp;hellip;of 循环的行为
var myIterator = { next: function() { // ... }, [Symbol.iterator]: function() { return this } } 可迭代协议 为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性:
[Symbol.iterator] 返回一个对象的无参函数，被返回对象符合迭代器协议。
当一个对象需要被迭代的时候（比如开始用于一个for..of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。
class people{ constructor(index){ this.index = index; } next(){ this.index++; return{ done: this.index &amp;gt; 10, value: this.index } } [Symbol.</description></item><item><title>js聊聊JS的二进制家族：Blob、ArrayBuffer和Buffer</title><link>https://chenkai.life/javascript/js_binary_blob_arraybuffer_buffer/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_binary_blob_arraybuffer_buffer/</guid><description>转载自知乎-外婆的彭湖湾
前端较少涉及对二进制数据的处理，但即便如此，我们偶尔总能在角落里看见它们的身影，今天我们就来聊一聊JS的二进制家族：Blob、ArrayBuffer和Buffer（Buffer由Node.js提供）
概述 Blob: 前端的一个专门用于支持文件操作的二进制对象 ArrayBuffer：前端的一个通用的二进制缓冲区，类似数组，但在API和特性上却有诸多不同 Buffer：Node.js提供的一个二进制缓冲区，常用来处理I/O操作 这篇文章的内容主要就聊一聊这一家子的人际关系展开。
复杂的人际关系网.jpg
下面就来一一介绍
Blob 我们首先来介绍Blob，Blob是用来支持文件操作的。简单的说：在JS中，有两个构造函数 File 和 Blob, 而File继承了所有Blob的属性。
所以在我们看来，File对象可以看作一种特殊的Blob对象。
在前端工程中，我们在哪些操作中可以获得File对象呢？ 请看：
（备注：目前 File API规范的状态为Working Draft）
我们上面说了，File对象是一种特殊的Blob对象，那么它自然就可以直接调用Blob对象的方法。让我们看一看Blob具体有哪些方法，以及能够用它们实现哪些功能
Blob实战 通过window.URL.createObjectURL方法可以把一个blob转化为一个Blob URL，并且用做文件下载或者图片显示的链接。
Blob URL所实现的下载或者显示等功能，仅仅可以在单个浏览器内部进行。而不能在服务器上进行存储，亦或者说它没有在服务器端存储的意义。
下面是一个Blob的例子，可以看到它很短
blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 和冗长的Base64格式的Data URL相比，Blob URL的长度显然不能够存储足够的信息，这也就意味着它只是类似于一个浏览器内部的“引用“。从这个角度看，Blob URL是一个浏览器自行制定的一个伪协议
Blob实现下载文件
我们可以通过window.URL.createObjectURL，接收一个Blob（File）对象，将其转化为Blob URL,然后赋给 a.download属性，然后在页面上点击这个链接就可以实现下载了
&amp;lt;!-- html部分 --&amp;gt; &amp;lt;a id=&amp;#34;h&amp;#34;&amp;gt;点此进行下载&amp;lt;/a&amp;gt; &amp;lt;!-- js部分 --&amp;gt; &amp;lt;script&amp;gt; var blob = new Blob([&amp;#34;Hello World&amp;#34;]); var url = window.</description></item><item><title>Reflect和Proxy</title><link>https://chenkai.life/javascript/js_reflect_and_proxy/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_reflect_and_proxy/</guid><description>Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，
new Proxy()表示生成一个Proxy实例， target参数表示所要拦截的目标对象， handler参数也是一个对象，用来定制拦截行为。 var proxy = new Proxy({}, { get: function(target, property) { return 35; } }); proxy.time // 35 proxy.name // 35 proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。
如果handler没有设置任何拦截，那就等同于直接通向原对象。
let peo = {}; let proxyP = new Proxy(peo,{}); proxyP.name = &amp;#39;ck&amp;#39;; peo.name //&amp;#39;ck&amp;#39; 下面是 Proxy 支持的拦截操作一览，一共 13 种。</description></item><item><title>了解什么是polyfill</title><link>https://chenkai.life/javascript/polyfill/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/polyfill/</guid><description>什么是polyfill 初次了解polyfill这个词,是在一次面试中，题目是使用数组的reduse方式实现map方法，全世界使用着许多不同的浏览器和版本的浏览器，每个浏览器都具有与其他浏览器完全不同的功能集。这会使浏览器开发成为一项艰巨的任务。流行浏览器的最新版本可以完成许多旧浏览器无法完成的任务-但您可能仍必须支持旧浏览器。通过尝试使用polyfills重新创建缺少的功能，Polyfill.io使支持不同的浏览器变得更简单：您可以在支持或不支持的浏览器中利用最新和最强大的功能。
如vue中对bind的polyfill代码如下
function polyfillBind (fn, ctx) { function boundFn (a) { var l = arguments.length; return l ? l &amp;gt; 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx) } boundFn._length = fn.length; return boundFn } function nativeBind (fn, ctx) { return fn.bind(ctx) } var bind = Function.prototype.bind ? nativeBind : polyfillBind; 常用对polyfill方法 babel-polyfill 提供完整的ES2015+环境
polyfill.io polyfill.io它是一个接口，它接受一组浏览器功能的请求，并仅返回请求浏览器所需的polyfill</description></item><item><title>介绍几个表达式和运算符</title><link>https://chenkai.life/javascript/js_operator/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_operator/</guid><description>空值合并运算符 ??是一个逻辑操作符，当左侧的表达式结果为 null或者 undefined时，其返回右侧表达式的结果，否则返回左侧表达式的结果。
以前，如果想为一个变量赋默认值，通常的做法是使用逻辑或操作符|| 然而，由于 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， ''， NaN， null， undefined）都不会被返回。这导致如果你使用0，''或NaN作为有效值，就会出现不可预料的后果。空值合并操作符可以避免这种陷阱，其只在第一个操作数为null 或 undefined 时（而不是其它假值）返回第二个操作数
let myText = &amp;#39;&amp;#39;; // An empty string (which is also a falsy value) let notFalsyText = myText || &amp;#39;Hello world&amp;#39;; console.log(notFalsyText); // Hello world let preservingFalsy = myText ?? &amp;#39;Hi neighborhood&amp;#39;; console.log(preservingFalsy); // &amp;#39;&amp;#39; (as myText is neither undefined nor null) //因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的 null || undefined ?? &amp;#34;foo&amp;#34;; // 抛出 SyntaxError (null || undefined ) ?</description></item><item><title>前端下载文本</title><link>https://chenkai.life/javascript/brower_download_text/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/brower_download_text/</guid><description>前端保存文本 function download( text, filename) { var element = document.createElement(&amp;#39;a&amp;#39;); element.setAttribute(&amp;#39;href&amp;#39;, &amp;#39;data:text/plain;charset=utf-8,&amp;#39; + encodeURIComponent(text)); element.setAttribute(&amp;#39;download&amp;#39;, filename); element.style.display = &amp;#39;none&amp;#39;; document.body.appendChild(element); element.click(); document.body.removeChild(element); } download(&amp;#34;data.txt&amp;#34;, &amp;#34;hello word!&amp;#34;);　// 调用</description></item><item><title>展开语法和剩余参数</title><link>https://chenkai.life/javascript/js_spread_and_rest/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/javascript/js_spread_and_rest/</guid><description>展开语法 展开语法(Spread syntax),只能用于可迭代对象, 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开
a={name: &amp;#34;mdn&amp;#34;} b=[1,2,3] console.log({...a}) console.log([...b]) //函数参数 function sum(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); console.log(sum.apply(null, numbers)); //构造 var parts = [&amp;#39;shoulders&amp;#39;, &amp;#39;knees&amp;#39;]; var lyrics = [&amp;#39;head&amp;#39;, ...parts, &amp;#39;and&amp;#39;, &amp;#39;toes&amp;#39;]; // [&amp;#34;head&amp;#34;, &amp;#34;shoulders&amp;#34;, &amp;#34;knees&amp;#34;, &amp;#34;and&amp;#34;, &amp;#34;toes&amp;#34;] var obj1 = { foo: &amp;#39;bar&amp;#39;, x: 42 }; var obj2 = { foo: &amp;#39;baz&amp;#39;, y: 13 }; var clonedObj = { .</description></item></channel></rss>