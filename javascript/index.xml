<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascripts on CK's Blog</title><link>https://chenkai.life/javascript/</link><description>Recent content in Javascripts on CK's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 19 Jul 2024 21:39:57 +0800</lastBuildDate><atom:link href="https://chenkai.life/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>defineProperty</title><link>https://chenkai.life/javascript/js-defin-property/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-defin-property/</guid><description>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
Object.defineProperty(obj, prop, descriptor) obj:要在其上定义属性的对象。 prop:要定义或修改的属性的名称。 descriptor:将被定义或修改的属性描述符。 描述符可以有以下属性：
configurable：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false enumerable： 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中，default：false value： 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined writable： 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 get： 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象 set： 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 @return:传递给函数的对象。
example // 数组拦截 /** * * @param {array} data */ function observe(data) { if (!Array.isArray(data)) { return; } // 取出所有数组遍历 data.forEach(function(val,index) { Object.defineProperty(data, index, { enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() { return val; }, set: function(newVal) { console.</description></item><item><title>get和set</title><link>https://chenkai.life/javascript/js-get-and-set/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-get-and-set/</guid><description>你可以在支持添加新属性的任何标准的内置对象或用户定义的对象内定义getter(访问方法)和setter(设置方法)。使用对象字面量语法定义getters和setters方法。
get get语法将对象属性绑定到查询该属性时将被调用的函数,有时需要允许访问返回动态计算值的属性，或者你可能需要反映内部变量的状态，而不需要使用显式方法调用。在JavaScript中，可以使用 getter 来实现。虽然可以使用 getter 和 setter 来创建一个伪属性类型，但是不可能同时将一个 getter 绑定到一个属性并且该属性实际上具有一个值
使用get语法时应注意以下问题：
可以使用数值或字符串作为标识； 必须不带参数； 它不能与另一个 get 或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 { get x() { }, get x() { } } 和 { x: &amp;hellip;, get x() { } }）。 可通过 delete 操作符删除 getter。 在新对象初始化时定义一个getter 这会为obj创建一个伪属性latest，它会返回log数组的最后一个元素,注意，尝试为latest分配一个值不会改变它。
var obj = { log: [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;], get latest() { if (this.log.length == 0) { return undefined; } return this.log[this.log.length - 1]; } } obj.latest = &amp;#39;test&amp;#39;; console.</description></item><item><title>JavaScript中的prototype</title><link>https://chenkai.life/javascript/js-prototype/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-prototype/</guid><description>什么是原型链 首先我们需要知道什么是原型，在 javascript 中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型（prototype）,我们可以添加一些属性到原型上面,然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个的实例。每个实例对象都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）. 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。
如何利用原型链实现继承 假设这里有两个类
// 交通工具 function Transportation(name) { this.name = name; // 该属性没有定义到原型链上,可以通过Object.keys获取 this.say = function () { console.log(`Transportation： ${this.name}是交通工具`); }; } Object.assign(Transportation.prototype, { move: function () { console.log(`Transportation: ${this.name} 会移动`); }, }); // 汽车 function Car(name) { // 调用Transportation构造函数，绑定this变量 我们也可以 // this.name = name; Transportation.call(this, name); } 此时 Car 的原型是
new Car() ----&amp;gt; Car.prototype ----&amp;gt; Object.prototype ----&amp;gt; null 要实现继承我们需要将该对象的原型指向要继承对象的原型，如</description></item><item><title>JavaScript可选链操作符</title><link>https://chenkai.life/javascript/operators-optional-chaining/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/operators-optional-chaining/</guid><description>可选链操作符 可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。
当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。
语法 obj?.prop; obj?.[expr]; arr?.[index]; func?.(args); 描述 通过连接的对象的引用或函数可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。
比如，思考一个存在嵌套结构的对象 obj。不使用可选链的话，查找一个深度嵌套的子属性时，需要验证之间的引用，例如：
let nestedProp = obj.first &amp;amp;&amp;amp; obj.first.second; 为了避免报错，在访问obj.first.second之前，要保证 obj.first 的值既不是 null，也不是 undefined。如果只是直接访问 obj.first.second，而不对 obj.first 进行校验，则有可能抛出错误。
有了可选链操作符（?.），在访问 obj.first.second 之前，不再需要明确地校验 obj.first 的状态，再并用短路计算获取最终结果：
let nestedProp = obj.first?.second; 通过使用 ?. 操作符取代 . 操作符，JavaScript 会在尝试访问 obj.first.second 之前，先隐式地检查并确定 obj.first 既不是 null 也不是 undefined。如果obj.first是 null 或者 undefined，表达式将会短路计算直接返回 undefined。
这等价于以下表达式，但实际上没有创建临时变量：</description></item><item><title>js中的this</title><link>https://chenkai.life/javascript/js-this/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-this/</guid><description>js 中 this 指当前执行代码的环境对象，this 不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了 this 的值
全局环境 浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &amp;#34;MDN&amp;#34;; console.log(window.b); // &amp;#34;MDN&amp;#34; console.log(b); // &amp;#34;MDN&amp;#34; node 环境中 this 是一个空对象
console.log(this); // {} 函数（运行内）环境 在函数内部，this 的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1() { return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined</description></item><item><title>js的迭代器</title><link>https://chenkai.life/javascript/js-iterator/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-iterator/</guid><description>什么是迭代器 ECMAScript 2015的几个补充，并不是新的内置实现或语法，而是协议。这些协议可以被任何遵循某些约定的对象来实现。有两个协议：可迭代协议和迭代器协议。 JavaScript 提供了许多迭代集合的方法，从简单的 for 循环到 map() 和 filter()，迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for&amp;hellip;of 循环的行为
var myIterator = { next: function() { // ... }, [Symbol.iterator]: function() { return this } } 可迭代协议 为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性:
[Symbol.iterator] 返回一个对象的无参函数，被返回对象符合迭代器协议。
当一个对象需要被迭代的时候（比如开始用于一个for..of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。
class people{ constructor(index){ this.index = index; } next(){ this.index++; return{ done: this.index &amp;gt; 10, value: this.index } } [Symbol.iterator](){ return this; } } let a = new people(3); for (let val of a){ console.</description></item><item><title>Reflect和Proxy</title><link>https://chenkai.life/javascript/js-reflect-and-proxy/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-reflect-and-proxy/</guid><description>Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，
new Proxy()表示生成一个 Proxy 实例， target参数表示所要拦截的目标对象， handler参数也是一个对象，用来定制拦截行为。 var proxy = new Proxy( {}, { get: function (target, property) { return 35; }, } ); proxy.time; // 35 proxy.name; // 35 proxy.title; // 35 上面代码中，作为构造函数，Proxy 接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回 35，所以访问任何属性都得到 35。 注意，要使得 Proxy 起作用，必须针对Proxy实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。
如果 handler 没有设置任何拦截，那就等同于直接通向原对象。
let peo = {}; let proxyP = new Proxy(peo, {}); proxyP.</description></item><item><title>一个关于Promise的问题</title><link>https://chenkai.life/javascript/one-question-about-promise/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/one-question-about-promise/</guid><description>一道题带来的疑问 掘金上的一道题： JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个，一个解法如下：
const timeout = (time) =&amp;gt; new Promise((resolve) =&amp;gt; { setTimeout(resolve, time); }); class Scheduler { constructor() { this.awaitArr = []; this.count = 0; } async add(promiseCreator) { if (this.count &amp;gt;= 2) { await new Promise((resolve) =&amp;gt; { this.awaitArr.push(resolve); }); } this.count++; const res = await promiseCreator(); this.count--; if (this.awaitArr.length) { this.awaitArr.shift()(); } return res; } } const scheduler = new Scheduler(); const addTask = (time, order) =&amp;gt; { scheduler.</description></item><item><title>介绍几个表达式和运算符</title><link>https://chenkai.life/javascript/js-operator/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-operator/</guid><description>空值合并运算符 ??是一个逻辑操作符，当左侧的表达式结果为 null 或者 undefined 时，其返回右侧表达式的结果，否则返回左侧表达式的结果。
以前，如果想为一个变量赋默认值，通常的做法是使用逻辑或操作符|| 然而，由于 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， ''， NaN， null， undefined）都不会被返回。这导致如果你使用0，''或NaN作为有效值，就会出现不可预料的后果。空值合并操作符可以避免这种陷阱，其只在第一个操作数为null 或 undefined 时（而不是其它假值）返回第二个操作数
let myText = &amp;#39;&amp;#39;; // An empty string (which is also a falsy value) let notFalsyText = myText || &amp;#39;Hello world&amp;#39;; console.log(notFalsyText); // Hello world let preservingFalsy = myText ?? &amp;#39;Hi neighborhood&amp;#39;; console.log(preservingFalsy); // &amp;#39;&amp;#39; (as myText is neither undefined nor null) //因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的 null || undefined ?? &amp;#34;foo&amp;#34;; // 抛出 SyntaxError (null || undefined ) ?</description></item><item><title>展开语法和剩余参数</title><link>https://chenkai.life/javascript/js-spread-and-rest/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-spread-and-rest/</guid><description>展开语法 展开语法(Spread syntax),只能用于可迭代对象, 可以在函数调用/数组构造时, 将数组表达式或者 string 在语法层面展开；还可以在构造字面量对象时, 将对象表达式按 key-value 的方式展开
a = { name: &amp;#34;mdn&amp;#34; }; b = [1, 2, 3]; console.log({ ...a }); console.log([...b]); //函数参数 function sum(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); console.log(sum.apply(null, numbers)); //构造 var parts = [&amp;#34;shoulders&amp;#34;, &amp;#34;knees&amp;#34;]; var lyrics = [&amp;#34;head&amp;#34;, ...parts, &amp;#34;and&amp;#34;, &amp;#34;toes&amp;#34;]; // [&amp;#34;head&amp;#34;, &amp;#34;shoulders&amp;#34;, &amp;#34;knees&amp;#34;, &amp;#34;and&amp;#34;, &amp;#34;toes&amp;#34;] var obj1 = { foo: &amp;#34;bar&amp;#34;, x: 42 }; var obj2 = { foo: &amp;#34;baz&amp;#34;, y: 13 }; var clonedObj = { .</description></item><item><title>简单谈谈JS中的沙箱</title><link>https://chenkai.life/javascript/js-sandbox/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-sandbox/</guid><description>沙箱(sandbox)是一种安全机制， 为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供用后即回收的磁盘及内存空间。
JS 中沙箱的使用场景 前端 JS 中也会有应用到沙箱的时候，毕竟有时候你要获取到的是第三方的 JS 文件或数据？而这数据又是不一定可信的时候，创建沙箱，做好保险工作尤为重要
jsonp：解析服务器所返回的 jsonp 请求时，如果不信任 jsonp 中的数据，可以通过创建沙箱的方式来解析获取数据；（TSW 中处理 jsonp 请求时，创建沙箱来处理和解析数据）； 执行第三方 js：当你有必要执行第三方 js 的时候，而这份 js 文件又不一定可信的时候； 在线代码编辑器：相信大家都有使用过一些在线代码编辑器，而这些代码的执行，基本都会放置在沙箱中，防止对页面本身造成影响；（例如：https://codesandbox.io/s/new） vue 模板中表达式计算：vue 模板中表达式的计算被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不能够在模板表达式中试图访问用户定义的全局变量
总而言之：当你要解析或执行不可信的 JS 的时候，当你要隔离被执行代码的执行环境的时候，当你要对执行代码中可访问对象进行限制的时候，沙箱就派上用场了 JS 沙箱实现 Function Function 构造函数创建一个新的 Function 对象。直接调用此构造函数可用动态创建函数，但会遇到和 eval 类似的的安全问题和(相对较小的)性能问题。然而，与 eval 不同的是，Function 创建的函数只能在全局作用域中运行。
eval eval() 函数会将传入的字符串当做 JavaScript 代码进行执行,eval() 是一个危险的函数， 它使用与调用者相同的权限执行代码。如果你用 eval() 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。更重要的是，第三方代码可以看到某一个 eval() 被调用时的作用域，这也有可能导致一些不同方式的攻击。相似的 Function 就不容易被攻击。
vm vm 模块支持在 V8 虚拟机上下文中编译和运行代码。 vm 模块不是一种安全机制。不要使用它来运行不受信任的代码。
const { Script, createContext } = require(&amp;#34;vm&amp;#34;); /** * * @param {string} code 需要执行的代码, 执行的代码被包括在一个自执行函数中 * @param {object} context 设置执行代码的上下文对象，默认包含 resolve: 用于代码返回值, reject: 用于代码抛出异常 * @param {object} options 可选参数 * @returns 执行代码返回值 */ async function runScript(code, context = {}, options = {}) { return new Promise((resolve, reject) =&amp;gt; { const { timeout = 120 * 1000, breakOnSigint = true } = options; const script = new Script(`(async()=&amp;gt;{${code}})()`); script.</description></item></channel></rss>