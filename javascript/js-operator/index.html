<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=theme-color content="#ffffff"><meta name=color-scheme content="light dark"><meta name=description content="空值合并运算符 ??是一个逻辑操作符，当左侧的表达式结果为 null 或者 undefined 时，其返回右侧表达式的结果，否则返回左侧表达式的结果。
以前，如果想为一个变量赋默认值，通常的做法是使用逻辑或操作符|| 然而，由于 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， ''， NaN， null， undefined）都不会被返回。这导致如果你使用0，''或NaN作为有效值，就会出现不可预料的后果。空值合并操作符可以避免这种陷阱，其只在第一个操作数为null 或 undefined 时（而不是其它假值）返回第二个操作数
let myText = ''; // An empty string (which is also a falsy value) let notFalsyText = myText || 'Hello world'; console.log(notFalsyText); // Hello world let preservingFalsy = myText ?? 'Hi neighborhood'; console.log(preservingFalsy); // '' (as myText is neither undefined nor null) //因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的 null || undefined ?? &#34;foo&#34;; // 抛出 SyntaxError (null || undefined ) ?"><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="介绍几个表达式和运算符"><meta name=twitter:description content="空值合并运算符 ??是一个逻辑操作符，当左侧的表达式结果为 null 或者 undefined 时，其返回右侧表达式的结果，否则返回左侧表达式的结果。
以前，如果想为一个变量赋默认值，通常的做法是使用逻辑或操作符|| 然而，由于 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， ''， NaN， null， undefined）都不会被返回。这导致如果你使用0，''或NaN作为有效值，就会出现不可预料的后果。空值合并操作符可以避免这种陷阱，其只在第一个操作数为null 或 undefined 时（而不是其它假值）返回第二个操作数
let myText = ''; // An empty string (which is also a falsy value) let notFalsyText = myText || 'Hello world'; console.log(notFalsyText); // Hello world let preservingFalsy = myText ?? 'Hi neighborhood'; console.log(preservingFalsy); // '' (as myText is neither undefined nor null) //因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的 null || undefined ?? &#34;foo&#34;; // 抛出 SyntaxError (null || undefined ) ?"><meta property="og:title" content="介绍几个表达式和运算符"><meta property="og:description" content="空值合并运算符 ??是一个逻辑操作符，当左侧的表达式结果为 null 或者 undefined 时，其返回右侧表达式的结果，否则返回左侧表达式的结果。
以前，如果想为一个变量赋默认值，通常的做法是使用逻辑或操作符|| 然而，由于 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， ''， NaN， null， undefined）都不会被返回。这导致如果你使用0，''或NaN作为有效值，就会出现不可预料的后果。空值合并操作符可以避免这种陷阱，其只在第一个操作数为null 或 undefined 时（而不是其它假值）返回第二个操作数
let myText = ''; // An empty string (which is also a falsy value) let notFalsyText = myText || 'Hello world'; console.log(notFalsyText); // Hello world let preservingFalsy = myText ?? 'Hi neighborhood'; console.log(preservingFalsy); // '' (as myText is neither undefined nor null) //因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的 null || undefined ?? &#34;foo&#34;; // 抛出 SyntaxError (null || undefined ) ?"><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/javascript/js-operator/"><meta property="article:section" content="javascript"><meta property="article:published_time" content="2021-07-09T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-22T18:03:50+08:00"><title>介绍几个表达式和运算符 · CK's Blog</title><link rel=canonical href=https://chenkai.life/javascript/js-operator/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.56610f8c63ea4ca06cdac03f4fafe3e818c64566f988301b72895eb047082c51.css integrity="sha256-VmEPjGPqTKBs2sA/T6/j6BjGRWb5iDAbcolesEcILFE=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/favicon.ico><link rel=apple-touch-icon type=image/png sizes=256x256 href=/images/favicon-512x512.png><meta name=generator content="Hugo 0.101.0"><link rel=manifest href=/manifest.webmanifest></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><details id=table-of-contents-wapper><summary><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></summary></details><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/marks/>Marks</a></li><li class=navigation-item><a class=navigation-link href=https://github.com/ckvv/ckvv.github.io/new/main/content>Create</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=github>GitHub</button>
<button class=search-btn data-type=google>Google</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/javascript/js-operator/>介绍几个表达式和运算符</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title rel=noopener target=_blank href=https://github.com/ckvv/ckvv.github.io/edit/main/content/javascript/js-operator.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2021-07-09T00:00:00Z>2021-07-09</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/javascript/>JavaScript</a></span></div></div><h2 id=空值合并运算符>空值合并运算符
<a class=heading-link href=#%e7%a9%ba%e5%80%bc%e5%90%88%e5%b9%b6%e8%bf%90%e7%ae%97%e7%ac%a6><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>??</code>是一个逻辑操作符，当左侧的表达式结果为 null 或者 undefined 时，其返回右侧表达式的结果，否则返回左侧表达式的结果。</p><p>以前，如果想为一个变量赋默认值，通常的做法是使用逻辑或操作符<code>||</code> 然而，由于 <code>||</code> 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（<code>0</code>， <code>''</code>， <code>NaN</code>， <code>null</code>， <code>undefined</code>）都不会被返回。这导致如果你使用<code>0</code>，<code>''</code>或<code>NaN</code>作为有效值，就会出现不可预料的后果。空值合并操作符可以避免这种陷阱，其只在第一个操作数为<code>null</code> 或 <code>undefined</code> 时（而不是其它假值）返回第二个操作数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>myText</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>; <span style=color:#75715e>// An empty string (which is also a falsy value)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>notFalsyText</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>myText</span> <span style=color:#f92672>||</span> <span style=color:#e6db74>&#39;Hello world&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>notFalsyText</span>); <span style=color:#75715e>// Hello world
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>preservingFalsy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>myText</span> <span style=color:#f92672>??</span> <span style=color:#e6db74>&#39;Hi neighborhood&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>preservingFalsy</span>); <span style=color:#75715e>// &#39;&#39; (as myText is neither undefined nor null)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>undefined</span> <span style=color:#f92672>??</span> <span style=color:#e6db74>&#34;foo&#34;</span>; <span style=color:#75715e>// 抛出 SyntaxError
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>(<span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>undefined</span> ) <span style=color:#f92672>??</span> <span style=color:#e6db74>&#34;foo&#34;</span>; <span style=color:#75715e>// 返回 &#34;foo&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>customer</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Carl&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>details</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>82</span> }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>customerCity</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>customer</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>city</span> <span style=color:#f92672>??</span> <span style=color:#e6db74>&#34;暗之城&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>customerCity</span>); <span style=color:#75715e>// “暗之城”
</span></span></span></code></pre></div><h2 id=可选链式操作>可选链式操作
<a class=heading-link href=#%e5%8f%af%e9%80%89%e9%93%be%e5%bc%8f%e6%93%8d%e4%bd%9c><i class="fa fa-link" aria-hidden=true></i></a></h2><p><strong><code>?.</code></strong> 可以按照操作符之前的属性是否有效，链式读取对象的属性或者使整个对象链返回 <code>undefined</code>。<code>?.</code> 运算符的作用与 <code>.</code> 运算符类似，不同之处在于，如果对象链上的引用是 nullish(null 或 undefined)操作符会抛出一个错误，而 <code>?.</code> 操作符则会按照短路计算的方式进行处理，返回 <code>undefined</code>。可选链操作符也可用于函数调用，如果操作符前的函数不存在，也将会返回 <code>undefined</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>adventurer</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Alice&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>cat</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Dinah&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>dogName</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>adventurer</span>.<span style=color:#a6e22e>dog</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>dogName</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// expected output: undefined
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>adventurer</span>.<span style=color:#a6e22e>someNonExistentMethod</span><span style=color:#f92672>?</span>.());
</span></span><span style=display:flex><span><span style=color:#75715e>// expected output: undefined
</span></span></span></code></pre></div><h2 id=newtarget>new.target
<a class=heading-link href=#newtarget><i class="fa fa-link" aria-hidden=true></i></a></h2><p>检测函数或构造方法是否是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，<code>new.target</code>返回一个指向构造方法或函数的引用。在普通的函数调用中，<code>new.target</code> 的值是<code>undefined</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>new</span>.<span style=color:#a6e22e>target</span>) <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#34;Foo() must be called with new&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Foo instantiated with new&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Foo</span>(); <span style=color:#75715e>// throws &#34;Foo() must be called with new&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Foo</span>(); <span style=color:#75715e>// logs &#34;Foo instantiated with new&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>new</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>A</span>(); <span style=color:#75715e>// logs &#34;A&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>(); <span style=color:#75715e>// logs &#34;B&#34;
</span></span></span></code></pre></div><h2 id=逗号操作符>逗号操作符
<a class=heading-link href=#%e9%80%97%e5%8f%b7%e6%93%8d%e4%bd%9c%e7%ac%a6><i class="fa fa-link" aria-hidden=true></i></a></h2><p>对它的每个操作数求值（从左到右），并返回最后一个操作数的值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>, <span style=color:#a6e22e>x</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// expected output: 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// expected output: 3
</span></span></span></code></pre></div><h2 id=管道操作符>管道操作符
<a class=heading-link href=#%e7%ae%a1%e9%81%93%e6%93%8d%e4%bd%9c%e7%ac%a6><i class="fa fa-link" aria-hidden=true></i></a></h2><p>试验性的管道操作符 <code>|></code> （目前其标准化流程处于 stage 1 阶段）允许以一种易读的方式去对函数链式调用。本质上来说，管道操作符是单参数函数调用的语法糖，它允许你像这样执行一个调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;%21&#34;</span> <span style=color:#f92672>|&gt;</span> decodeURI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>使用传统语法写的话</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>等效的代码是这样的</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> decodeURI(<span style=color:#e6db74>&#34;%21&#34;</span>);
</span></span></code></pre></div><h1 id=装饰器>装饰器
<a class=heading-link href=#%e8%a3%85%e9%a5%b0%e5%99%a8><i class="fa fa-link" aria-hidden=true></i></a></h1><p>装饰器是对类、函数、属性之类的一种装饰，可以针对其添加一些额外的行为。通俗的理解可以认为就是在原有代码外层包装了一层处理逻辑,装饰器是一个还处于草案中的特性</p><p>TODO</p><div id=cusdis_thread data-host=https://cusdis.com data-app-id=c2b015f9-9a4b-4997-b66f-f9c6ca26ebdd data-page-id=2cba9dd91ac40e8f85526af8e2503fa0 data-page-url=https://chenkai.life/javascript/js-operator/ data-page-title=介绍几个表达式和运算符 data-iframe=/js/cusdis/iframe.umd.js data-style=/js/cusdis/style.css></div></article></section></div></main><script src=/js/coder.min.cb0c595e02234420f3ad3886bf4a9bd2874d0e1e78e090138a9ef158b35aaf17.js integrity="sha256-ywxZXgIjRCDzrTiGv0qb0odNDh544JATip7xWLNarxc="></script>
<script src=/js/custom.js></script>
<script src=/js/font.min.js></script></body><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></html>