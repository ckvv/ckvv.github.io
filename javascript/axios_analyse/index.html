<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=description content="转载自axios 核心源码解读
介绍axios    一直在使用axios库，在享受它带来的便利的同时，总感觉不读读它的源码有点对不起它，刚好网上介绍axios源码的文章较少，所以写下这篇文章，权当抛砖引玉。
axios是同构的JavaScript的异步请求库，它可以在浏览器端和NodeJS环境里使用。
VueJS的作者尤大也推荐这个工具，它除了异步请求网络资源功能，还有如下功能：
 提供代理功能 提供了拦截器（类似中间件），可以注册在请求发出去之前和收到响应之后的操作 可以获取上传进度和下载进度 提供的adapter选项可以模拟响应数据 自定义引起报错的响应码范围 提供了取消请求的功能  axios的GitHub地址。
那么，它是怎么办到的呢？    首先说说为什么它可以在浏览器端和NodeJS环境中使用    在axios中，使用适配器设计模式来屏蔽平台的差异性，让使用者可以在浏览器端和NodeJS环境中使用同一套API发起http请求。
axios的默认配置里的adapter是通过getDefaultAdapter()方法来获取的，它的逻辑如下：
function getDefaultAdapter() { var adapter; // Only Node.JS has a process variable that is of [[Class]] process  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') { // For node use HTTP adapter  adapter = require('./adapters/http'); } else if (typeof XMLHttpRequest !"><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="axios核心源码解读"><meta name=twitter:description content="转载自axios 核心源码解读
介绍axios    一直在使用axios库，在享受它带来的便利的同时，总感觉不读读它的源码有点对不起它，刚好网上介绍axios源码的文章较少，所以写下这篇文章，权当抛砖引玉。
axios是同构的JavaScript的异步请求库，它可以在浏览器端和NodeJS环境里使用。
VueJS的作者尤大也推荐这个工具，它除了异步请求网络资源功能，还有如下功能：
 提供代理功能 提供了拦截器（类似中间件），可以注册在请求发出去之前和收到响应之后的操作 可以获取上传进度和下载进度 提供的adapter选项可以模拟响应数据 自定义引起报错的响应码范围 提供了取消请求的功能  axios的GitHub地址。
那么，它是怎么办到的呢？    首先说说为什么它可以在浏览器端和NodeJS环境中使用    在axios中，使用适配器设计模式来屏蔽平台的差异性，让使用者可以在浏览器端和NodeJS环境中使用同一套API发起http请求。
axios的默认配置里的adapter是通过getDefaultAdapter()方法来获取的，它的逻辑如下：
function getDefaultAdapter() { var adapter; // Only Node.JS has a process variable that is of [[Class]] process  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') { // For node use HTTP adapter  adapter = require('./adapters/http'); } else if (typeof XMLHttpRequest !"><meta property="og:title" content="axios核心源码解读"><meta property="og:description" content="转载自axios 核心源码解读
介绍axios    一直在使用axios库，在享受它带来的便利的同时，总感觉不读读它的源码有点对不起它，刚好网上介绍axios源码的文章较少，所以写下这篇文章，权当抛砖引玉。
axios是同构的JavaScript的异步请求库，它可以在浏览器端和NodeJS环境里使用。
VueJS的作者尤大也推荐这个工具，它除了异步请求网络资源功能，还有如下功能：
 提供代理功能 提供了拦截器（类似中间件），可以注册在请求发出去之前和收到响应之后的操作 可以获取上传进度和下载进度 提供的adapter选项可以模拟响应数据 自定义引起报错的响应码范围 提供了取消请求的功能  axios的GitHub地址。
那么，它是怎么办到的呢？    首先说说为什么它可以在浏览器端和NodeJS环境中使用    在axios中，使用适配器设计模式来屏蔽平台的差异性，让使用者可以在浏览器端和NodeJS环境中使用同一套API发起http请求。
axios的默认配置里的adapter是通过getDefaultAdapter()方法来获取的，它的逻辑如下：
function getDefaultAdapter() { var adapter; // Only Node.JS has a process variable that is of [[Class]] process  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') { // For node use HTTP adapter  adapter = require('./adapters/http'); } else if (typeof XMLHttpRequest !"><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/javascript/axios_analyse/"><meta property="article:published_time" content="2021-07-09T15:37:56+08:00"><meta property="article:modified_time" content="2021-07-09T15:37:56+08:00"><title>axios核心源码解读 · CK's Blog</title><link rel=canonical href=https://chenkai.life/javascript/axios_analyse/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.ffed55576b1fe8cd1a532c3c9691900c09813ce5a8e0fbf58a6e377169305cf3.css integrity="sha256-/+1VV2sf6M0aUyw8lpGQDAmBPOWo4Pv1im43cWkwXPM=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.72.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/index.xml>RSS</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=google>Google</button>
<button class=search-btn data-type=github>GitHub</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/javascript/axios_analyse/>axios核心源码解读</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title target=_blank href=https://github.com/chenkai0520/chenkai0520.github.io/edit/main/content/javascript/axios_analyse.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2021-07-09T15:37:56+08:00>2021-07-09</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/js/>js</a></span></div></div><p>转载自<a href=https://github.com/coconilu/Blog/issues/116>axios 核心源码解读</a></p><h1 id=介绍axios>介绍axios
<a class=heading-link href=#%e4%bb%8b%e7%bb%8daxios><i class="fa fa-link" aria-hidden=true></i></a></h1><p>一直在使用axios库，在享受它带来的便利的同时，总感觉不读读它的源码有点对不起它，刚好网上介绍axios源码的文章较少，所以写下这篇文章，权当抛砖引玉。</p><p>axios是同构的JavaScript的异步请求库，它可以在浏览器端和NodeJS环境里使用。</p><p>VueJS的作者尤大也推荐这个工具，它除了异步请求网络资源功能，还有如下功能：</p><ol><li>提供代理功能</li><li>提供了拦截器（类似中间件），可以注册在请求发出去之前和收到响应之后的操作</li><li>可以获取上传进度和下载进度</li><li>提供的adapter选项可以模拟响应数据</li><li>自定义引起报错的响应码范围</li><li>提供了取消请求的功能</li></ol><p>axios的<a href=https://github.com/axios/axios>GitHub地址</a>。</p><h1 id=那么它是怎么办到的呢>那么，它是怎么办到的呢？
<a class=heading-link href=#%e9%82%a3%e4%b9%88%e5%ae%83%e6%98%af%e6%80%8e%e4%b9%88%e5%8a%9e%e5%88%b0%e7%9a%84%e5%91%a2><i class="fa fa-link" aria-hidden=true></i></a></h1><h2 id=首先说说为什么它可以在浏览器端和nodejs环境中使用>首先说说为什么它可以在浏览器端和NodeJS环境中使用
<a class=heading-link href=#%e9%a6%96%e5%85%88%e8%af%b4%e8%af%b4%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ae%83%e5%8f%af%e4%bb%a5%e5%9c%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e5%92%8cnodejs%e7%8e%af%e5%a2%83%e4%b8%ad%e4%bd%bf%e7%94%a8><i class="fa fa-link" aria-hidden=true></i></a></h2><p>在axios中，使用适配器设计模式来屏蔽平台的差异性，让使用者可以在浏览器端和NodeJS环境中使用同一套API发起http请求。</p><p>axios的默认配置里的adapter是通过<code>getDefaultAdapter()</code>方法来获取的，它的逻辑如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getDefaultAdapter</span>() {
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>adapter</span>;
  <span style=color:#75715e>// Only Node.JS has a process variable that is of [[Class]] process
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>process</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;undefined&#39;</span> <span style=color:#f92672>&amp;&amp;</span> Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>toString</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>process</span>) <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;[object process]&#39;</span>) {
    <span style=color:#75715e>// For node use HTTP adapter
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>adapter</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;./adapters/http&#39;</span>);
  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>XMLHttpRequest</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;undefined&#39;</span>) {
    <span style=color:#75715e>// For browsers use XHR adapter
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>adapter</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;./adapters/xhr&#39;</span>);
  }
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>adapter</span>;
}
</code></pre></div><p>如上面代码，通过判断运行环境的特征来选择不同的API发起http请求。</p><p>接下来分别介绍这两个文件——http和xhr。</p><h3 id=httpjs>http.js
<a class=heading-link href=#httpjs><i class="fa fa-link" aria-hidden=true></i></a></h3><p>这个文件里，引用了NodeJS的http和https库，用于发出http请求，并使用Promise接收请求结果。</p><p>代码的细节不介绍了，就讲个大概的思路，我们都知道发起http请求，最重要的是遵守http协议，书写正确的请求头，而axios就是通过传入<code>config</code>接收使用者的一些定制参数，其中包括请求头，请求参数等等，然后在内部使用(http/https).request(options, callback)发起http请求。</p><p>具体如何整合、处理传入的参数，还请下载源码看看。</p><h3 id=xhrjs>xhr.js
<a class=heading-link href=#xhrjs><i class="fa fa-link" aria-hidden=true></i></a></h3><p>类似http的逻辑，只不过是调用了WebAPI的XMLHTTPRequest接口发起http请求。</p><h2 id=拦截器的实现>拦截器的实现
<a class=heading-link href=#%e6%8b%a6%e6%88%aa%e5%99%a8%e7%9a%84%e5%ae%9e%e7%8e%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>axios提供了拦截器的功能，可以在请求发起前处理传入的config或者其它操作，也可以在接收完响应后处理response。</p><p>我们可以看看Axios的构造函数，很简单：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Axios</span>(<span style=color:#a6e22e>instanceConfig</span>) {
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>defaults</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>instanceConfig</span>;
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>interceptors</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>request</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>InterceptorManager</span>(),
    <span style=color:#a6e22e>response</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>InterceptorManager</span>()
  };
}
</code></pre></div><p>其中的InterceptorManager维护一个数组，用以收集拦截器函数，有<code>fulfilled</code>和<code>rejected</code>，分别对应Promise的onSuccess和onFail的回调，接下来看看拦截器和发起http请求是如何结合在一起的，我们看看Axios的原型上的request方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>Axios</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>request</span>(<span style=color:#a6e22e>config</span>) {
  <span style=color:#75715e>/*eslint no-param-reassign:0*/</span>
  <span style=color:#75715e>// Allow for axios(&#39;example/url&#39;[, config]) a la fetch API
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>config</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;string&#39;</span>) {
    <span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arguments</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>||</span> {};
    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arguments</span>[<span style=color:#ae81ff>0</span>];
  } <span style=color:#66d9ef>else</span> {
    <span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>config</span> <span style=color:#f92672>||</span> {};
  }

  <span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mergeConfig</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>defaults</span>, <span style=color:#a6e22e>config</span>);
  <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>method</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>method</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>method</span>.<span style=color:#a6e22e>toLowerCase</span>() <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;get&#39;</span>;

  <span style=color:#75715e>// Hook up interceptors middleware
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>chain</span> <span style=color:#f92672>=</span> [<span style=color:#a6e22e>dispatchRequest</span>, <span style=color:#66d9ef>undefined</span>];
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>promise</span> <span style=color:#f92672>=</span> Promise.<span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>config</span>);

  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>interceptors</span>.<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>forEach</span>(<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>unshiftRequestInterceptors</span>(<span style=color:#a6e22e>interceptor</span>) {
    <span style=color:#a6e22e>chain</span>.<span style=color:#a6e22e>unshift</span>(<span style=color:#a6e22e>interceptor</span>.<span style=color:#a6e22e>fulfilled</span>, <span style=color:#a6e22e>interceptor</span>.<span style=color:#a6e22e>rejected</span>);
  });

  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>interceptors</span>.<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>forEach</span>(<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>pushResponseInterceptors</span>(<span style=color:#a6e22e>interceptor</span>) {
    <span style=color:#a6e22e>chain</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>interceptor</span>.<span style=color:#a6e22e>fulfilled</span>, <span style=color:#a6e22e>interceptor</span>.<span style=color:#a6e22e>rejected</span>);
  });

  <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>chain</span>.<span style=color:#a6e22e>length</span>) {
    <span style=color:#a6e22e>promise</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>promise</span>.<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>chain</span>.<span style=color:#a6e22e>shift</span>(), <span style=color:#a6e22e>chain</span>.<span style=color:#a6e22e>shift</span>());
  }

  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promise</span>;
};
</code></pre></div><p>从上面可以看出，它们结合的方式是使用Promise把拦截器和发起http请求的操作结合起来的，<code>interceptors.request</code>会安排在发起http请求的操作前，<code>interceptors.response</code>会安排在发起http请求的操作后。</p><h2 id=上传和下载的进度>上传和下载的进度
<a class=heading-link href=#%e4%b8%8a%e4%bc%a0%e5%92%8c%e4%b8%8b%e8%bd%bd%e7%9a%84%e8%bf%9b%e5%ba%a6><i class="fa fa-link" aria-hidden=true></i></a></h2><p>axios提供了观察上传和下载进度的功能，不过仅支持在浏览器环境中，核心代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// Handle progress if needed
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>onDownloadProgress</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;function&#39;</span>) {
  <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;progress&#39;</span>, <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>onDownloadProgress</span>);
}

<span style=color:#75715e>// Not all browsers support upload events
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>onUploadProgress</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;function&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>upload</span>) {
  <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>upload</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;progress&#39;</span>, <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>onUploadProgress</span>);
}
</code></pre></div><p>从上面可以看出，下载进度回调其实就是监听XMLHTTPRequest对象的<a href=https://developer.mozilla.org/en-US/docs/Web/Events/progress>progress事件</a>，上传进度回调其实就是XMLHTTPRequest对象的upload属性的<a href=https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload>progress事件</a>。</p><h2 id=模拟响应数据>模拟响应数据
<a class=heading-link href=#%e6%a8%a1%e6%8b%9f%e5%93%8d%e5%ba%94%e6%95%b0%e6%8d%ae><i class="fa fa-link" aria-hidden=true></i></a></h2><p>官方文档里指出这个功能需要开发者返回一个Promise对象并且在Promise里返回一个有效的Response对象：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// `adapter` allows custom handling of requests which makes testing easier.
</span><span style=color:#75715e>// Return a promise and supply a valid response (see lib/adapters/README.md).
</span><span style=color:#75715e></span><span style=color:#a6e22e>adapter</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>config</span>) {
  <span style=color:#75715e>/* ... */</span>
}
</code></pre></div><p>我们可以在源码中找到这个功能的实现方式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>adapter</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>adapter</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>defaults</span>.<span style=color:#a6e22e>adapter</span>;

<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>adapter</span>(<span style=color:#a6e22e>config</span>).<span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>onAdapterResolution</span>(<span style=color:#a6e22e>response</span>) {
  <span style=color:#a6e22e>throwIfCancellationRequested</span>(<span style=color:#a6e22e>config</span>);

  <span style=color:#75715e>// Transform response data
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>transformData</span>(
    <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>data</span>,
    <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>headers</span>,
    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>transformResponse</span>
  );

  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>response</span>;
}, <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>onAdapterRejection</span>(<span style=color:#a6e22e>reason</span>) {
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>isCancel</span>(<span style=color:#a6e22e>reason</span>)) {
    <span style=color:#a6e22e>throwIfCancellationRequested</span>(<span style=color:#a6e22e>config</span>);

    <span style=color:#75715e>// Transform response data
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>reason</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>reason</span>.<span style=color:#a6e22e>response</span>) {
      <span style=color:#a6e22e>reason</span>.<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>transformData</span>(
        <span style=color:#a6e22e>reason</span>.<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>data</span>,
        <span style=color:#a6e22e>reason</span>.<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>headers</span>,
        <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>transformResponse</span>
      );
    }
  }

  <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>reason</span>);
});
</code></pre></div><p>从上面可以看出，如果我们在使用axios发出http请求时，如果传入的config对象有adapter属性，这个属性会顶替了默认的adapter（NodeJS的http.request()或XMLHTTPRequest），所以我们需要在config的adapter属性中返回一个Promise，并且这个Promise会返回一个有效的Response对象。</p><h2 id=自定义引起报错的响应码范围>自定义引起报错的响应码范围
<a class=heading-link href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%bc%95%e8%b5%b7%e6%8a%a5%e9%94%99%e7%9a%84%e5%93%8d%e5%ba%94%e7%a0%81%e8%8c%83%e5%9b%b4><i class="fa fa-link" aria-hidden=true></i></a></h2><p>axios提供了一个功能，可以自定义报错的响应码的范围，可以通过<code>config.validateStatus</code>来配置。</p><p>默认的范围是200到300之间：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>validateStatus</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>validateStatus</span>(<span style=color:#a6e22e>status</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>status</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>200</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>status</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>300</span>;
}
</code></pre></div><p>而在源码中，这个方法是通过<code>lib\core\settle.js</code>来调用的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>settle</span>(<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>, <span style=color:#a6e22e>response</span>) {
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>validateStatus</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>validateStatus</span>;
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>validateStatus</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>validateStatus</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>status</span>)) {
    <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>response</span>);
  } <span style=color:#66d9ef>else</span> {
    <span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>createError</span>(
      <span style=color:#e6db74>&#39;Request failed with status code &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>status</span>,
      <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>config</span>,
      <span style=color:#66d9ef>null</span>,
      <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>request</span>,
      <span style=color:#a6e22e>response</span>
    ));
  }
};
</code></pre></div><p>从上面可以看出，settle的入参很像Promise的resolve和reject，接下来，我们看看settle又是在哪里被调用的。</p><p>果不其然，在<code>lib\adapters\http.js</code>和<code>lib\adapters\xhr.js</code>中都看到settle的身影。</p><p>细节就不说了，我大致说一下思路，就是axios使用Promise发起http请求后，会把传入Promise对象的函数中的resolve和reject再次传递给settle中，让它来决定Promise的状态是onResolved还是onRejected。</p><h2 id=取消请求的功能>取消请求的功能
<a class=heading-link href=#%e5%8f%96%e6%b6%88%e8%af%b7%e6%b1%82%e7%9a%84%e5%8a%9f%e8%83%bd><i class="fa fa-link" aria-hidden=true></i></a></h2><p>axios官方文档指出axios提供了取消已经发出去的请求的功能。</p><blockquote><p>The axios cancel token API is based on the withdrawn <a href=https://github.com/tc39/proposal-cancelable-promises>cancelable promises proposal</a>.</p></blockquote><p>上面引用的话里指出这是一个promise的提议，不过已经被撤回了。</p><p>在这里，笔者想说的是，其实不依赖这个提议，我们也可以写一个简单取消请求的功能，只要你熟悉闭包就可以了。</p><p>思路是这样的：我们可以使用闭包的方式维护一个是否取消请求的状态，然后在处理Promise的onResolved回调的时候判断一下这个状态，如果状态是需要取消请求的话，就reject结果，大致如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>dispatchRequest</span>(<span style=color:#a6e22e>config</span>) {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>hasCancled</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
  <span style=color:#66d9ef>return</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>hasCancled</span>) {
      <span style=color:#a6e22e>reject</span>({ <span style=color:#a6e22e>hasCancled</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span> })
    } <span style=color:#66d9ef>else</span> {
      <span style=color:#75715e>/** 处理正常响应 **/</span>
    }
  })
    .<span style=color:#a6e22e>then</span>(<span style=color:#75715e>/** 其他业务操作 **/</span>)
    .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; {
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>hasCancled</span>) {
        <span style=color:#75715e>/** 处理请求被取消 */</span>
      }
    })
}
</code></pre></div><h1 id=总结>总结
<a class=heading-link href=#%e6%80%bb%e7%bb%93><i class="fa fa-link" aria-hidden=true></i></a></h1><p>最后，我们可以大致了解了axios强大的背后原因：使用适配器模式屏蔽了平台差异性，并提供统一的API，使用Promise的链式调用来保证整个请求过程的有序性和增强一些额外的功能。</p><p>axios库是一个很精美的第三库，值得我们去读读它的源码。你也会收获很多的。很感谢你能坚持看到这里。</p><div id=vcomments></div></article></section></div></main><script src=/js/coder.min.a350362441276ec5c1671926420497bb8e52b63ead1d51d3c9bc4342d0039526.js integrity="sha256-o1A2JEEnbsXBZxkmQgSXu45Stj6tHVHTybxDQtADlSY="></script><script src=/js/custom.js></script><script src=/js/font.min.js></script></body></html>