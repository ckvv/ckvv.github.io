<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=description content="转载自https://es6.ruanyifeng.com/#docs/class-extends
 简介    Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
class Point { } class ColorPoint extends Point { } 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。
class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y)  this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString()  } } 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
class Point { /* ... */ } class ColorPoint extends Point { constructor() { } } let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。"><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="js的Class的继承"><meta name=twitter:description content="转载自https://es6.ruanyifeng.com/#docs/class-extends
 简介    Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
class Point { } class ColorPoint extends Point { } 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。
class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y)  this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString()  } } 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
class Point { /* ... */ } class ColorPoint extends Point { constructor() { } } let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。"><meta property="og:title" content="js的Class的继承"><meta property="og:description" content="转载自https://es6.ruanyifeng.com/#docs/class-extends
 简介    Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
class Point { } class ColorPoint extends Point { } 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。
class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y)  this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString()  } } 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
class Point { /* ... */ } class ColorPoint extends Point { constructor() { } } let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。"><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/javascript/js_class/"><meta property="article:published_time" content="2021-07-09T15:37:56+08:00"><meta property="article:modified_time" content="2021-07-09T15:37:56+08:00"><title>js的Class的继承 · CK's Blog</title><link rel=canonical href=https://chenkai.life/javascript/js_class/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.ffed55576b1fe8cd1a532c3c9691900c09813ce5a8e0fbf58a6e377169305cf3.css integrity="sha256-/+1VV2sf6M0aUyw8lpGQDAmBPOWo4Pv1im43cWkwXPM=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.72.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/index.xml>RSS</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=google>Google</button>
<button class=search-btn data-type=github>GitHub</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/javascript/js_class/>js的Class的继承</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title target=_blank href=https://github.com/chenkai0520/chenkai0520.github.io/edit/main/content/javascript/js_class.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2021-07-09T15:37:56+08:00>2021-07-09</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/js/>js</a></span></div></div><blockquote><p>转载自<a href=https://es6.ruanyifeng.com/#docs/class-extends>https://es6.ruanyifeng.com/#docs/class-extends</a></p></blockquote><h2 id=简介>简介
<a class=heading-link href=#%e7%ae%80%e4%bb%8b><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> {
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ColorPoint</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Point</span> {
}
</code></pre></div><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ColorPoint</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Point</span> {
  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>color</span>) {
    <span style=color:#66d9ef>super</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>); <span style=color:#75715e>// 调用父类的constructor(x, y)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>color</span>;
  }

  <span style=color:#a6e22e>toString</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>color</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>toString</span>(); <span style=color:#75715e>// 调用父类的toString()
</span><span style=color:#75715e></span>  }
}
</code></pre></div><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> { <span style=color:#75715e>/* ... */</span> }

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ColorPoint</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Point</span> {
  <span style=color:#a6e22e>constructor</span>() {
  }
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>cp</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ColorPoint</span>(); <span style=color:#75715e>// ReferenceError
</span></code></pre></div><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p><p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p><p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ColorPoint</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Point</span> {
}

<span style=color:#75715e>// 等同于
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ColorPoint</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Point</span> {
  <span style=color:#a6e22e>constructor</span>(...<span style=color:#a6e22e>args</span>) {
    <span style=color:#66d9ef>super</span>(...<span style=color:#a6e22e>args</span>);
  }
}
</code></pre></div><p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> {
  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span>;
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>y</span>;
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ColorPoint</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Point</span> {
  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>color</span>) {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>color</span>; <span style=color:#75715e>// ReferenceError
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>super</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>);
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>color</span>; <span style=color:#75715e>// 正确
</span><span style=color:#75715e></span>  }
}
</code></pre></div><p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p><p>下面是生成子类实例的代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>cp</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ColorPoint</span>(<span style=color:#ae81ff>25</span>, <span style=color:#ae81ff>8</span>, <span style=color:#e6db74>&#39;green&#39;</span>);

<span style=color:#a6e22e>cp</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>ColorPoint</span> <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>cp</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>Point</span> <span style=color:#75715e>// true
</span></code></pre></div><p>上面代码中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p><p>最后，父类的静态方法，也会被子类继承。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>hello</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;hello world&#39;</span>);
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
}

<span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>hello</span>()  <span style=color:#75715e>// hello world
</span></code></pre></div><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p><h2 id=objectgetprototypeof>Object.getPrototypeOf()
<a class=heading-link href=#objectgetprototypeof><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>Object.<span style=color:#a6e22e>getPrototypeOf</span>(<span style=color:#a6e22e>ColorPoint</span>) <span style=color:#f92672>===</span> <span style=color:#a6e22e>Point</span>
<span style=color:#75715e>// true
</span></code></pre></div><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h2 id=super-关键字>super 关键字
<a class=heading-link href=#super-%e5%85%b3%e9%94%ae%e5%ad%97><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
  }
}
</code></pre></div><p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>new</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>name</span>);
  }
}
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
  }
}
<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>A</span>() <span style=color:#75715e>// A
</span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>() <span style=color:#75715e>// B
</span></code></pre></div><p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p><p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>m</span>() {
    <span style=color:#66d9ef>super</span>(); <span style=color:#75715e>// 报错
</span><span style=color:#75715e></span>  }
}
</code></pre></div><p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>p</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>p</span>()); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>  }
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>();
</code></pre></div><p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p><p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>m</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>p</span>;
  }
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>();
<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>m</span> <span style=color:#75715e>// undefined
</span></code></pre></div><p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {}
<span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>x</span>) <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>  }
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>();
</code></pre></div><p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p><p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
  }
  <span style=color:#a6e22e>print</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span>);
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
  }
  <span style=color:#a6e22e>m</span>() {
    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>print</span>();
  }
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>();
<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>m</span>() <span style=color:#75715e>// 2
</span></code></pre></div><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p><p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>x</span>); <span style=color:#75715e>// undefined
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span>); <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>  }
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>();
</code></pre></div><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>myMethod</span>(<span style=color:#a6e22e>msg</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;static&#39;</span>, <span style=color:#a6e22e>msg</span>);
  }

  <span style=color:#a6e22e>myMethod</span>(<span style=color:#a6e22e>msg</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;instance&#39;</span>, <span style=color:#a6e22e>msg</span>);
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Child</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Parent</span> {
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>myMethod</span>(<span style=color:#a6e22e>msg</span>) {
    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>myMethod</span>(<span style=color:#a6e22e>msg</span>);
  }

  <span style=color:#a6e22e>myMethod</span>(<span style=color:#a6e22e>msg</span>) {
    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>myMethod</span>(<span style=color:#a6e22e>msg</span>);
  }
}

<span style=color:#a6e22e>Child</span>.<span style=color:#a6e22e>myMethod</span>(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// static 1
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>child</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child</span>();
<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>myMethod</span>(<span style=color:#ae81ff>2</span>); <span style=color:#75715e>// instance 2
</span></code></pre></div><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
  }
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>print</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span>);
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
  }
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>m</span>() {
    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>print</span>();
  }
}

<span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
<span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>m</span>() <span style=color:#75715e>// 3
</span></code></pre></div><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>super</span>); <span style=color:#75715e>// 报错
</span><span style=color:#75715e></span>  }
}
</code></pre></div><p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>valueOf</span>() <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>B</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span>  }
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>();
</code></pre></div><p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>toString</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;MyObject: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>toString</span>();
  }
};

<span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>toString</span>(); <span style=color:#75715e>// MyObject: [object Object]
</span></code></pre></div><h2 id=类的-prototype-属性和__proto__属性>类的 prototype 属性和__proto__属性
<a class=heading-link href=#%e7%b1%bb%e7%9a%84-prototype-%e5%b1%9e%e6%80%a7%e5%92%8c__proto__%e5%b1%9e%e6%80%a7><i class="fa fa-link" aria-hidden=true></i></a></h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
}

<span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>A</span> <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#75715e>// true
</span></code></pre></div><p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
}

<span style=color:#75715e>// B 的实例继承 A 的实例
</span><span style=color:#75715e></span>Object.<span style=color:#a6e22e>setPrototypeOf</span>(<span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>prototype</span>, <span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span>);

<span style=color:#75715e>// B 继承 A 的静态属性
</span><span style=color:#75715e></span>Object.<span style=color:#a6e22e>setPrototypeOf</span>(<span style=color:#a6e22e>B</span>, <span style=color:#a6e22e>A</span>);

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>B</span>();
</code></pre></div><p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>Object.<span style=color:#a6e22e>setPrototypeOf</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>proto</span>) {
  <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>proto</span>;
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>obj</span>;
}
</code></pre></div><p>因此，就得到了上面的结果。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>Object.<span style=color:#a6e22e>setPrototypeOf</span>(<span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>prototype</span>, <span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span>);
<span style=color:#75715e>// 等同于
</span><span style=color:#75715e></span><span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span>;

Object.<span style=color:#a6e22e>setPrototypeOf</span>(<span style=color:#a6e22e>B</span>, <span style=color:#a6e22e>A</span>);
<span style=color:#75715e>// 等同于
</span><span style=color:#75715e></span><span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>A</span>;
</code></pre></div><p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span>);
<span style=color:#75715e>// 等同于
</span><span style=color:#75715e></span><span style=color:#a6e22e>B</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span>;
</code></pre></div><p><code>extends</code>关键字后面可以跟多种类型的值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>A</span> {
}
</code></pre></div><p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p><p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> <span style=color:#66d9ef>extends</span> Object {
}

<span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> Object <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> Object.<span style=color:#a6e22e>prototype</span> <span style=color:#75715e>// true
</span></code></pre></div><p>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。</p><p>第二种情况，不存在任何继承。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
}

<span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> Function.<span style=color:#a6e22e>prototype</span> <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> Object.<span style=color:#a6e22e>prototype</span> <span style=color:#75715e>// true
</span></code></pre></div><p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</p><h3 id=实例的-__proto__-属性>实例的 <strong>proto</strong> 属性
<a class=heading-link href=#%e5%ae%9e%e4%be%8b%e7%9a%84-__proto__-%e5%b1%9e%e6%80%a7><i class="fa fa-link" aria-hidden=true></i></a></h3><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>);
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ColorPoint</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;red&#39;</span>);

<span style=color:#a6e22e>p2</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>p2</span>.<span style=color:#a6e22e>__proto__</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>__proto__</span> <span style=color:#75715e>// true
</span></code></pre></div><p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p><p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>p2</span>.<span style=color:#a6e22e>__proto__</span>.<span style=color:#a6e22e>__proto__</span>.<span style=color:#a6e22e>printName</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Ha&#39;</span>);
};

<span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>printName</span>() <span style=color:#75715e>// &#34;Ha&#34;
</span></code></pre></div><p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p><h2 id=原生构造函数的继承>原生构造函数的继承
<a class=heading-link href=#%e5%8e%9f%e7%94%9f%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%9a%84%e7%bb%a7%e6%89%bf><i class="fa fa-link" aria-hidden=true></i></a></h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>MyArray</span>() {
  Array.<span style=color:#a6e22e>apply</span>(<span style=color:#66d9ef>this</span>, <span style=color:#a6e22e>arguments</span>);
}

<span style=color:#a6e22e>MyArray</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(Array.<span style=color:#a6e22e>prototype</span>, {
  <span style=color:#a6e22e>constructor</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>MyArray</span>,
    <span style=color:#a6e22e>writable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
    <span style=color:#a6e22e>configurable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
    <span style=color:#a6e22e>enumerable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>
  }
});
</code></pre></div><p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>colors</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MyArray</span>();
<span style=color:#a6e22e>colors</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;red&#34;</span>;
<span style=color:#a6e22e>colors</span>.<span style=color:#a6e22e>length</span>  <span style=color:#75715e>// 0
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>colors</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#a6e22e>colors</span>[<span style=color:#ae81ff>0</span>]  <span style=color:#75715e>// &#34;red&#34;
</span></code></pre></div><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p><p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p><p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>e</span> <span style=color:#f92672>=</span> {};

Object.<span style=color:#a6e22e>getOwnPropertyNames</span>(Error.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>e</span>))
<span style=color:#75715e>// [ &#39;stack&#39; ]
</span><span style=color:#75715e></span>
Object.<span style=color:#a6e22e>getOwnPropertyNames</span>(<span style=color:#a6e22e>e</span>)
<span style=color:#75715e>// []
</span></code></pre></div><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyArray</span> <span style=color:#66d9ef>extends</span> Array {
  <span style=color:#a6e22e>constructor</span>(...<span style=color:#a6e22e>args</span>) {
    <span style=color:#66d9ef>super</span>(...<span style=color:#a6e22e>args</span>);
  }
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MyArray</span>();
<span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>;
<span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#75715e>// undefined
</span></code></pre></div><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VersionedArray</span> <span style=color:#66d9ef>extends</span> Array {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>history</span> <span style=color:#f92672>=</span> [[]];
  }
  <span style=color:#a6e22e>commit</span>() {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>history</span>.<span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>slice</span>());
  }
  <span style=color:#a6e22e>revert</span>() {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>splice</span>(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>length</span>, ...<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>history</span>[<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>history</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
  }
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>VersionedArray</span>();

<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>push</span>(<span style=color:#ae81ff>1</span>);
<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>push</span>(<span style=color:#ae81ff>2</span>);
<span style=color:#a6e22e>x</span> <span style=color:#75715e>// [1, 2]
</span><span style=color:#75715e></span><span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>history</span> <span style=color:#75715e>// [[]]
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>commit</span>();
<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>history</span> <span style=color:#75715e>// [[], [1, 2]]
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>push</span>(<span style=color:#ae81ff>3</span>);
<span style=color:#a6e22e>x</span> <span style=color:#75715e>// [1, 2, 3]
</span><span style=color:#75715e></span><span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>history</span> <span style=color:#75715e>// [[], [1, 2]]
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>revert</span>();
<span style=color:#a6e22e>x</span> <span style=color:#75715e>// [1, 2]
</span></code></pre></div><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExtendableError</span> <span style=color:#66d9ef>extends</span> Error {
  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>message</span>) {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>message</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>message</span>;
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>stack</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>new</span> Error()).<span style=color:#a6e22e>stack</span>;
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>constructor</span>.<span style=color:#a6e22e>name</span>;
  }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyError</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ExtendableError</span> {
  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>m</span>) {
    <span style=color:#66d9ef>super</span>(<span style=color:#a6e22e>m</span>);
  }
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>myerror</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MyError</span>(<span style=color:#e6db74>&#39;ll&#39;</span>);
<span style=color:#a6e22e>myerror</span>.<span style=color:#a6e22e>message</span> <span style=color:#75715e>// &#34;ll&#34;
</span><span style=color:#75715e></span><span style=color:#a6e22e>myerror</span> <span style=color:#66d9ef>instanceof</span> Error <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>myerror</span>.<span style=color:#a6e22e>name</span> <span style=color:#75715e>// &#34;MyError&#34;
</span><span style=color:#75715e></span><span style=color:#a6e22e>myerror</span>.<span style=color:#a6e22e>stack</span>
<span style=color:#75715e>// Error
</span><span style=color:#75715e>//     at MyError.ExtendableError
</span><span style=color:#75715e>//     ...
</span></code></pre></div><p>注意，继承<code>Object</code>的子类，有一个<a href=http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object>行为差异</a>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NewObj</span> <span style=color:#66d9ef>extends</span> Object{
  <span style=color:#a6e22e>constructor</span>(){
    <span style=color:#66d9ef>super</span>(...<span style=color:#a6e22e>arguments</span>);
  }
}
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>NewObj</span>({<span style=color:#a6e22e>attr</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>});
<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>attr</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>true</span>  <span style=color:#75715e>// false
</span></code></pre></div><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p><h2 id=mixin-模式的实现>Mixin 模式的实现
<a class=heading-link href=#mixin-%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%ae%9e%e7%8e%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;a&#39;</span>
};
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;b&#39;</span>
};
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> {...<span style=color:#a6e22e>a</span>, ...<span style=color:#a6e22e>b</span>}; <span style=color:#75715e>// {a: &#39;a&#39;, b: &#39;b&#39;}
</span></code></pre></div><p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p><p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mix</span>(...<span style=color:#a6e22e>mixins</span>) {
  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Mix</span> {
    <span style=color:#a6e22e>constructor</span>() {
      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>mixin</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>mixins</span>) {
        <span style=color:#a6e22e>copyProperties</span>(<span style=color:#66d9ef>this</span>, <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>mixin</span>()); <span style=color:#75715e>// 拷贝实例属性
</span><span style=color:#75715e></span>      }
    }
  }

  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>mixin</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>mixins</span>) {
    <span style=color:#a6e22e>copyProperties</span>(<span style=color:#a6e22e>Mix</span>, <span style=color:#a6e22e>mixin</span>); <span style=color:#75715e>// 拷贝静态属性
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>copyProperties</span>(<span style=color:#a6e22e>Mix</span>.<span style=color:#a6e22e>prototype</span>, <span style=color:#a6e22e>mixin</span>.<span style=color:#a6e22e>prototype</span>); <span style=color:#75715e>// 拷贝原型属性
</span><span style=color:#75715e></span>  }

  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Mix</span>;
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>copyProperties</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>source</span>) {
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>Reflect</span>.<span style=color:#a6e22e>ownKeys</span>(<span style=color:#a6e22e>source</span>)) {
    <span style=color:#66d9ef>if</span> ( <span style=color:#a6e22e>key</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;constructor&#39;</span>
      <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;prototype&#39;</span>
      <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;name&#39;</span>
    ) {
      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>desc</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>getOwnPropertyDescriptor</span>(<span style=color:#a6e22e>source</span>, <span style=color:#a6e22e>key</span>);
      Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>desc</span>);
    }
  }
}
</code></pre></div><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DistributedEdit</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>mix</span>(<span style=color:#a6e22e>Loggable</span>, <span style=color:#a6e22e>Serializable</span>) {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><div id=vcomments></div></article></section></div></main><script src=/js/coder.min.a350362441276ec5c1671926420497bb8e52b63ead1d51d3c9bc4342d0039526.js integrity="sha256-o1A2JEEnbsXBZxkmQgSXu45Stj6tHVHTybxDQtADlSY="></script><script src=/js/custom.js></script><script src=/js/font.min.js></script></body></html>