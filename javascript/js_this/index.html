<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=description content="js中this指当前执行代码的环境对象，this不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了this的值
全局环境    浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &#34;MDN&#34;; console.log(window.b) // &#34;MDN&#34; console.log(b) // &#34;MDN&#34; node环境中this是一个空对象
console.log(this) // {} 函数（运行内）环境    在函数内部，this的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1(){ return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window  //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined
&#34;use strict&#34;; // 这里是严格模式 function f2(){ return this; } f2() === undefined; // true  window."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="js中的this"><meta name=twitter:description content="js中this指当前执行代码的环境对象，this不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了this的值
全局环境    浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &#34;MDN&#34;; console.log(window.b) // &#34;MDN&#34; console.log(b) // &#34;MDN&#34; node环境中this是一个空对象
console.log(this) // {} 函数（运行内）环境    在函数内部，this的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1(){ return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window  //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined
&#34;use strict&#34;; // 这里是严格模式 function f2(){ return this; } f2() === undefined; // true  window."><meta property="og:title" content="js中的this"><meta property="og:description" content="js中this指当前执行代码的环境对象，this不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了this的值
全局环境    浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &#34;MDN&#34;; console.log(window.b) // &#34;MDN&#34; console.log(b) // &#34;MDN&#34; node环境中this是一个空对象
console.log(this) // {} 函数（运行内）环境    在函数内部，this的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1(){ return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window  //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined
&#34;use strict&#34;; // 这里是严格模式 function f2(){ return this; } f2() === undefined; // true  window."><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/javascript/js_this/"><meta property="article:published_time" content="2021-07-09T15:37:56+08:00"><meta property="article:modified_time" content="2021-07-09T15:37:56+08:00"><title>js中的this · CK's Blog</title><link rel=canonical href=https://chenkai.life/javascript/js_this/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.ffed55576b1fe8cd1a532c3c9691900c09813ce5a8e0fbf58a6e377169305cf3.css integrity="sha256-/+1VV2sf6M0aUyw8lpGQDAmBPOWo4Pv1im43cWkwXPM=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.72.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/index.xml>RSS</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=google>Google</button>
<button class=search-btn data-type=github>GitHub</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/javascript/js_this/>js中的this</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title target=_blank href=https://github.com/chenkai0520/chenkai0520.github.io/edit/main/content/javascript/js_this.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2021-07-09T15:37:56+08:00>2021-07-09</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/js/>js</a></span></div></div><p>js中this指当前执行代码的环境对象，this不能在执行期间被赋值如<code>this = null</code>，在绝大多数情况下，函数的调用方式决定了this的值</p><h2 id=全局环境>全局环境
<a class=heading-link href=#%e5%85%a8%e5%b1%80%e7%8e%af%e5%a2%83><i class="fa fa-link" aria-hidden=true></i></a></h2><p>浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 在浏览器中, window 对象同时也是全局对象：
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span> <span style=color:#f92672>===</span> window); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>37</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(window.<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// 37
</span><span style=color:#75715e></span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;MDN&#34;</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(window.<span style=color:#a6e22e>b</span>)  <span style=color:#75715e>// &#34;MDN&#34;
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>b</span>)         <span style=color:#75715e>// &#34;MDN&#34;
</span></code></pre></div><p>node环境中this是一个空对象</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>)   <span style=color:#75715e>//  {}
</span></code></pre></div><h2 id=函数运行内环境>函数（运行内）环境
<a class=heading-link href=#%e5%87%bd%e6%95%b0%e8%bf%90%e8%a1%8c%e5%86%85%e7%8e%af%e5%a2%83><i class="fa fa-link" aria-hidden=true></i></a></h2><p>在函数内部，this的值取决于函数被调用的方式</p><p>因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f1</span>(){
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
}
<span style=color:#75715e>//在浏览器中：
</span><span style=color:#75715e></span><span style=color:#a6e22e>f1</span>() <span style=color:#f92672>===</span> window;   <span style=color:#75715e>//在浏览器中，全局对象是window
</span><span style=color:#75715e></span>
<span style=color:#75715e>//在Node中：
</span><span style=color:#75715e></span><span style=color:#a6e22e>f1</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>global</span>; 
</code></pre></div><p>严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#e6db74>&#34;use strict&#34;</span>; <span style=color:#75715e>// 这里是严格模式
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f2</span>(){
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
}

<span style=color:#a6e22e>f2</span>() <span style=color:#f92672>===</span> <span style=color:#66d9ef>undefined</span>; <span style=color:#75715e>// true
</span><span style=color:#75715e></span>
window.<span style=color:#a6e22e>f2</span>() <span style=color:#75715e>//  window
</span></code></pre></div><p>如果要想把this的值从一个环境传到另一个，就要用call或apply方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Custom&#39;</span>};

<span style=color:#75715e>// 这个属性是在global对象定义的。
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Global&#39;</span>;

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>whatsThis</span>(<span style=color:#a6e22e>arg</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span>;  <span style=color:#75715e>// this的值取决于函数的调用方式
</span><span style=color:#75715e></span>}

<span style=color:#a6e22e>whatsThis</span>();          <span style=color:#75715e>// &#39;Global&#39;
</span><span style=color:#75715e></span><span style=color:#a6e22e>whatsThis</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>obj</span>);  <span style=color:#75715e>// &#39;Custom&#39;
</span><span style=color:#75715e></span><span style=color:#a6e22e>whatsThis</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>obj</span>); <span style=color:#75715e>// &#39;Custom&#39;
</span></code></pre></div><p>当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>d</span>;
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span>};

<span style=color:#75715e>// 第一个参数是作为‘this’使用的对象
</span><span style=color:#75715e>// 后续参数作为参数传递给函数调用
</span><span style=color:#75715e></span><span style=color:#a6e22e>add</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>o</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>); <span style=color:#75715e>// 1 + 3 + 5 + 7 = 16
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 第一个参数也是作为‘this’使用的对象
</span><span style=color:#75715e>// 第二个参数是一个数组，数组里的元素用作函数调用中的参数
</span><span style=color:#75715e></span><span style=color:#a6e22e>add</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>o</span>, [<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>]); <span style=color:#75715e>// 1 + 3 + 10 + 20 = 34
</span></code></pre></div><p>使用 call 和 apply 函数的时候要注意，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。因此，如果传递的值是一个原始值比如 7 或 &lsquo;foo&rsquo;，那么就会使用相关构造函数将它转换为对象，所以原始值 7 会被转换为对象，像 new Number(7) 这样，而字符串 &lsquo;foo&rsquo; 转化成 new String(&lsquo;foo&rsquo;) 这样，例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bar</span>() {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>);
}
<span style=color:#75715e>//原始值 7 被隐式转换为对象
</span><span style=color:#75715e></span><span style=color:#a6e22e>bar</span>.<span style=color:#a6e22e>call</span>(<span style=color:#ae81ff>7</span>); <span style=color:#75715e>// Number {7}
</span></code></pre></div><p>ECMAScript 5 引入了 Function.prototype.bind。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span>;
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>bind</span>({
    <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;azerty&#34;</span>
});
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>g</span>()); <span style=color:#75715e>// azerty
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>bind</span>({
    <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;yoo&#39;</span>
}); <span style=color:#75715e>// bind只生效一次！
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>h</span>()); <span style=color:#75715e>// azerty
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>37</span>,
    <span style=color:#a6e22e>f</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>f</span>,
    <span style=color:#a6e22e>g</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>g</span>,
    <span style=color:#a6e22e>h</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>h</span>
};
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>(), <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>g</span>(), <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>h</span>()); <span style=color:#75715e>// 37, azerty, azerty
</span></code></pre></div><h2 id=箭头函数>箭头函数
<a class=heading-link href=#%e7%ae%ad%e5%a4%b4%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>在箭头函数中，this与封闭词法环境的this保持一致。在全局代码中，它将被设置为全局对象,无论如何，foo 的 this 被设置为他被创建时的环境</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>globalObject</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> (() =&gt; <span style=color:#66d9ef>this</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>globalObject</span>); <span style=color:#75715e>// true
</span></code></pre></div><p>如果将this传递给call、bind、或者apply，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为null。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>foo</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>foo</span>};
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>foo</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>globalObject</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 尝试使用call来设定this
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>obj</span>) <span style=color:#f92672>===</span> <span style=color:#a6e22e>globalObject</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 尝试使用bind来设定this
</span><span style=color:#75715e></span><span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#a6e22e>obj</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>globalObject</span>); <span style=color:#75715e>// true
</span></code></pre></div><p>箭头函数的this被设置为封闭的词法环境,一个赋值给了 obj.bar的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 A 调用时，函数B的this被永久设置为obj.bar（函数A）的this。当返回的函数（函数B）被调用时，它this始终是最初设置的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 创建一个含有bar方法的obj对象，
</span><span style=color:#75715e>// bar返回一个函数，
</span><span style=color:#75715e>// 这个函数返回this，
</span><span style=color:#75715e>// 这个返回的函数是以箭头函数创建的，
</span><span style=color:#75715e>// 所以它的this被永久绑定到了它外层函数的this。
</span><span style=color:#75715e>// bar的值可以在调用中设置，这反过来又设置了返回函数的值。
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>bar</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> (() =&gt; <span style=color:#66d9ef>this</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>;
  }
};

<span style=color:#75715e>// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。
</span><span style=color:#75715e>// 将返回的函数的引用赋值给fn。
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>bar</span>();

<span style=color:#75715e>// 直接调用fn而不设置this，
</span><span style=color:#75715e>// 通常(即不使用箭头函数的情况)默认为全局对象
</span><span style=color:#75715e>// 若在严格模式则为undefined
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>fn</span>() <span style=color:#f92672>===</span> <span style=color:#a6e22e>obj</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 但是注意，如果你只是引用obj的方法，
</span><span style=color:#75715e>// 而没有调用它
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fn2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>bar</span>;
<span style=color:#75715e>// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>fn2</span>()() <span style=color:#f92672>==</span> window); <span style=color:#75715e>// true
</span></code></pre></div><h2 id=作为对象的方法>作为对象的方法
<a class=heading-link href=#%e4%bd%9c%e4%b8%ba%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h2><p>当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象;
当 o.f()被调用时，函数内的this将绑定到o对象</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>prop</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>37</span>,
  <span style=color:#a6e22e>f</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>prop</span>;
  }
};

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>()); <span style=color:#75715e>// logs 37
</span><span style=color:#75715e></span>


window.<span style=color:#a6e22e>prop</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>
<span style=color:#a6e22e>a</span>()  <span style=color:#75715e>//3
</span></code></pre></div><p><strong>注意</strong>
这样的行为，根本不受函数定义方式或位置的影响。在前面的例子中，我们在定义对象o的同时，将函数内联定义为成员 f 。但是，我们也可以先定义函数，然后再将其附属到o.f。这样做会导致相同的行为：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>prop</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>37</span>};

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>independent</span>() {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>prop</span>;
}

<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>independent</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>()); <span style=color:#75715e>// logs 37
</span></code></pre></div><p><strong>这表明函数是从o的f成员调用的才是重点</strong></p><p>this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法g当作对象o.b的函数调用。在这次执行期间，函数中的this将指向o.b。事实证明，这与他是对象 o 的成员没有多大关系，最靠近的引用才是最重要的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>g</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>independent</span>, <span style=color:#a6e22e>prop</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>42</span>};
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>g</span>()); <span style=color:#75715e>// 42
</span></code></pre></div><h2 id=原型链中的-this>原型链中的 this
<a class=heading-link href=#%e5%8e%9f%e5%9e%8b%e9%93%be%e4%b8%ad%e7%9a%84-this><i class="fa fa-link" aria-hidden=true></i></a></h2><p>如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>f</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() { 
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span>; 
  }
};
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>o</span>);
<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>f</span>()); <span style=color:#75715e>// 5
</span></code></pre></div><p>在这个例子中，对象p没有属于它自己的f属性，它的f属性继承自它的原型。虽然在对 f 的查找过程中，最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向p。也就是说，因为f是作为p的方法调用的，所以它的this指向了p。这是 JavaScript 的原型继承中的一个有趣的特性。</p><h2 id=getter-与-setter-中的-this>getter 与 setter 中的 this
<a class=heading-link href=#getter-%e4%b8%8e-setter-%e4%b8%ad%e7%9a%84-this><i class="fa fa-link" aria-hidden=true></i></a></h2><p>再次，相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>sum</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>c</span>;
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>,
    <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>,
    <span style=color:#a6e22e>c</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span>,
    <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>average</span>() {
        <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>c</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>;
    }
};

Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>o</span>, <span style=color:#e6db74>&#39;sum&#39;</span>, {
    <span style=color:#a6e22e>get</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>sum</span>,
    <span style=color:#a6e22e>enumerable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
    <span style=color:#a6e22e>configurable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>
});

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>average</span>, <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>sum</span>); <span style=color:#75715e>// logs 2, 6
</span></code></pre></div><h2 id=作为构造函数>作为构造函数
<a class=heading-link href=#%e4%bd%9c%e4%b8%ba%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。虽然构造器返回的默认值是this所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回this对象）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>/*
</span><span style=color:#75715e> * 构造函数这样工作:
</span><span style=color:#75715e> *
</span><span style=color:#75715e> * function MyConstructor(){
</span><span style=color:#75715e> *   // 函数实体写在这里
</span><span style=color:#75715e> *   // 根据需要在this上创建属性，然后赋值给它们，比如：
</span><span style=color:#75715e> *   this.fum = &#34;nom&#34;;
</span><span style=color:#75715e> *   // 等等...
</span><span style=color:#75715e> *
</span><span style=color:#75715e> *   // 如果函数具有返回对象的return语句，
</span><span style=color:#75715e> *   // 则该对象将是 new 表达式的结果。 
</span><span style=color:#75715e> *   // 否则，表达式的结果是当前绑定到 this 的对象。
</span><span style=color:#75715e> *   //（即通常看到的常见情况）。
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>C</span>(){
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>37</span>;
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>C</span>();
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// logs 37
</span><span style=color:#75715e></span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>C2</span>(){
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>37</span>;
  <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>a</span><span style=color:#f92672>:</span><span style=color:#ae81ff>38</span>};
}

<span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>C2</span>();
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// logs 38
</span></code></pre></div><h2 id=作为一个dom事件处理函数>作为一个DOM事件处理函数
<a class=heading-link href=#%e4%bd%9c%e4%b8%ba%e4%b8%80%e4%b8%aadom%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>当函数被用作事件处理函数时，它的this指向触发事件的元素（一些浏览器在使用非addEventListener的函数动态添加监听函数时不遵守这个约定)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 被调用时，将关联的元素变成蓝色
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bluify</span>(<span style=color:#a6e22e>e</span>){
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>currentTarget</span>); <span style=color:#75715e>// 总是 true
</span><span style=color:#75715e></span>
  <span style=color:#75715e>// 当 currentTarget 和 target 是同一个对象时为 true
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>target</span>);        
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>style</span>.<span style=color:#a6e22e>backgroundColor</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;#A5D9F3&#39;</span>;
}

<span style=color:#75715e>// 获取文档中的所有元素的列表
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>elements</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementsByTagName</span>(<span style=color:#e6db74>&#39;*&#39;</span>);

<span style=color:#75715e>// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> ; <span style=color:#a6e22e>i</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>elements</span>.<span style=color:#a6e22e>length</span> ; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>){
  <span style=color:#a6e22e>elements</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#a6e22e>bluify</span>, <span style=color:#66d9ef>false</span>);
}
</code></pre></div><h2 id=作为一个内联事件处理函数>作为一个内联事件处理函数
<a class=heading-link href=#%e4%bd%9c%e4%b8%ba%e4%b8%80%e4%b8%aa%e5%86%85%e8%81%94%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h2><p>当代码被内联on-event 处理函数调用时，它的this指向监听器所在的DOM元素</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onclick</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;alert(this.tagName.toLowerCase());&#34;</span>&gt;
  Show this
&lt;/<span style=color:#f92672>button</span>&gt;
</code></pre></div><p>注意只有外层代码中的this是这样设置的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onclick</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;alert((function(){return this})());&#34;</span>&gt;
  Show inner this
&lt;/<span style=color:#f92672>button</span>&gt;
</code></pre></div><p>在这种情况下，没有设置内部函数的this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置this时指向的默认对象）</p><div id=vcomments></div></article></section></div></main><script src=/js/coder.min.a350362441276ec5c1671926420497bb8e52b63ead1d51d3c9bc4342d0039526.js integrity="sha256-o1A2JEEnbsXBZxkmQgSXu45Stj6tHVHTybxDQtADlSY="></script><script src=/js/custom.js></script><script src=/js/font.min.js></script></body></html>