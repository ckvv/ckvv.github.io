<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vues on CK's Blog</title><link>https://chenkai.life/vue/</link><description>Recent content in Vues on CK's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 16 Jul 2024 11:38:29 +0800</lastBuildDate><atom:link href="https://chenkai.life/vue/index.xml" rel="self" type="application/rss+xml"/><item><title>Vue动态组件缓存</title><link>https://chenkai.life/vue/vue%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98/</guid><description> 使用KeepAlive缓存组件实例 我们可以通过&amp;lt;KeepAlive&amp;gt;实现多个组件间动态切换时缓存被移除的组件实例。 https://play.vuejs.org
&amp;lt;!-- 非活跃的组件将会被缓存！ --&amp;gt; &amp;lt;KeepAlive&amp;gt; &amp;lt;component :is=&amp;#34;activeComponent&amp;#34; /&amp;gt; &amp;lt;/KeepAlive&amp;gt; 单一组件多实例缓存 但是这种实现无法针对同一组件生效，例如针对动态路由，由于渲染的组件实际未发生变更缓存的实例将是同一个
&amp;lt;router-view v-slot=&amp;#34;{ Component }&amp;#34;&amp;gt; &amp;lt;keep-alive&amp;gt; &amp;lt;component :is=&amp;#34;Component&amp;#34;/&amp;gt; &amp;lt;/keep-alive&amp;gt; &amp;lt;/router-view&amp;gt; const User = { template: &amp;#39;&amp;lt;div&amp;gt;User&amp;lt;/div&amp;gt;&amp;#39;, } // 这些都会传递给 `createRouter` const routes = [ // 动态字段以冒号开始 { path: &amp;#39;/users/:id&amp;#39;, component: User }, ] 访问/users/1, /users/2时缓存的实例将是同一个
针对上面的问题有以下解决办法
设置component的key keep-alive内部把组件对象的key或者或者组件对象当作key缓存https://github.com/vuejs/core/blob/a95e612b252ae59eaf56e0b8ddba66948d4ac20e/packages/runtime-core/src/components/KeepAlive.ts#L291-L292
&amp;lt;router-view v-slot=&amp;#34;{ Component, route }&amp;#34;&amp;gt; &amp;lt;keep-alive&amp;gt; &amp;lt;component :is=&amp;#34;Component&amp;#34; :key=&amp;#34;route.path&amp;#34;/&amp;gt; &amp;lt;/keep-alive&amp;gt; &amp;lt;/router-view&amp;gt;</description></item><item><title>Vue全局组件类型提示</title><link>https://chenkai.life/vue/vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA/</link><pubDate>Thu, 16 Mar 2023 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA/</guid><description>一旦我们全局注册了组件，我们就可以在任何地方使用这个组件, 这有一个弊端，如果我们使用了TypeScript的话就丢失了全局组件的类型提示。 对于这个问题，Vue 3 有一个 PRhttps://github.com/vuejs/core/pull/3399 扩展了全局组件的接口。Volar 已经支持这种用法， 我们可以通过在根目录添加components.d.ts文件的方式来添加全对局组件的TypeScript的支持。
/* eslint-disable */ /* prettier-ignore */ // @ts-nocheck // Generated by unplugin-vue-components // Read more: https://github.com/vuejs/core/pull/3399 import &amp;#39;@vue/runtime-core&amp;#39; export {} declare module &amp;#39;@vue/runtime-core&amp;#39; { export interface GlobalComponents { ElButton: typeof import(&amp;#39;element-plus/es&amp;#39;)[&amp;#39;ElButton&amp;#39;] ElLink: typeof import(&amp;#39;element-plus/es&amp;#39;)[&amp;#39;ElLink&amp;#39;] } } 对于这个文件我们可以使用unplugin-vue-components插件来自动生成。
使用pnpm命令创建的vite项目无法在vscode中获得组件类型提示 解决办法参考https://github.com/antfu/unplugin-vue-components/issues/406
添加.npmrc文件并添加以下内容
public-hoist-pattern[]=@vue/runtime-core 或者
node-linker=hoisted 这两种方法原理都是一样的，即将@vue/runtime-core提到最上层。</description></item><item><title>Vue 3 UI 组件库评测</title><link>https://chenkai.life/vue/ui_framework/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/ui_framework/</guid><description> Vue 3 UI TS/JS SFC/JSX Options/Composition Desktop/Mobile/MP Style 特点 缺点 推荐 Element Plus TS SFC Composition Desktop scss setup 🌟🌟🌟🌟🌟 Ant Design Vue TS JSX Composition Desktop less React 🌟🌟🌟🌟🌟 TDesign TS JSX Composition Desktop/Mobile/MP less React/腾讯 🌟🌟🌟🌟🌟 Arco Design Vue TS SFC Composition Desktop less React/字节 🌟🌟🌟🌟🌟 Naive UI TS JSX Composition Desktop css in js 图森 🌟🌟🌟🌟🌟 NutUI TS SFC Composition Mobile scss React/京东 🌟🌟🌟🌟🌟 Vant TS JSX Composition Mobile less 有赞 🌟🌟🌟🌟🌟 Vuetify TS JSX Composition Desktop sass 🌟🌟🌟🌟🌟 Vuestic UI TS SFC Composition Desktop scss 🌟🌟🌟🌟🌟 BalmUI JS SFC Composition Desktop scss Material 不流行/缺乏维护 🌟🌟🌟🌟 Vue Material JS SFC Options Desktop scss Material 🌟🌟🌟🌟 Quimax TS SFC Composition Desktop scss 拟物风格 不流行 🌟🌟🌟🌟 Quasar JS JSX Composition Desktop sass Material 🌟🌟🌟🌟 Agnostic UI TS SFC Composition Desktop css module React/setup 不流行/缺乏维护 🌟🌟🌟🌟 mand-mobile-nest TS JSX Composition Mobile stylus 滴滴 不流行/缺乏维护 🌟🌟🌟🌟 Codex TS JSX Composition Desktop less 维基 不流行 🌟🌟🌟🌟 iDux TS JSX Composition Desktop less 不流行 🌟🌟🌟🌟 Oruga TS SFC Options Desktop scss 🌟🌟🌟🌟 Vexip UI TS JSX Composition Desktop scss 缺乏维护 🌟🌟🌟🌟 Unge UI TS JSX Composition Desktop stylus 不流行 🌟🌟🌟🌟 Core UI TS JSX Composition Desktop scss React 缺乏维护 🌟🌟🌟🌟 MDBootstrap JS SFC Composition Desktop scss React/Material 不流行/缺乏维护 🌟🌟🌟 Prime Vue TS SFC Options Desktop css React 🌟🌟🌟 Buefy JS SFC Options Desktop scss 🌟🌟🌟 Cube UI JS SFC Options Mobile stylus 滴滴 缺乏维护 🌟🌟 Bootstrap Vue JS JSX Options Desktop scss 缺乏维护 🌟🌟 HeyUI JS SFC Options Desktop less 缺乏维护 🌟🌟 Mijin JS SFC Options Desktop Tailwind CSS 不流行/缺乏维护 🌟🌟 View Design JS SFC Options Desktop less 缺乏维护 🌟🌟 vue-material-adapter JS SFC Options Desktop scss Material 缺乏维护 🌟🌟 Wave UI JS SFC Options Desktop scss Material 缺乏维护 🌟🌟</description></item><item><title>关于Vue组件二次封装的技巧总结</title><link>https://chenkai.life/vue/guanyu-vue-zujian-fengzhuang/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/guanyu-vue-zujian-fengzhuang/</guid><description>在开发Vue项目我们一般使用第三方UI组件库进行开发，如element-plus, @arco-design/web-Vue, naive-ui等, 但是这些组件提供的接口并不一定满足我们的需求，这时我们可以通过对组件库组件的二次封装，来满足我们特殊的需求。 对于封装组件有一个大原则就是我们应该尽量保持原有组件的接口，除了我们需要封装的功能外，我们不应该改变原有组件的接口，即保持原有组件提供的接口如props,events,slots等不变。 为了实现这一原则我们就需要将新组件的接口与旧组件的接口一一对应, 当然我们可以通过在新组件中一一声明对应的接口来实现（或者只实现我们目前需要用到的接口）但这种办法虽然简单但看起来却极其很繁琐, 有没有一种方法可以实现props,events,slots的自动透传呢？
透传 Attribute 我们可以使用一个没有参数的 v-bind来实现props,events的透传， 它会将一个对象的所有属性都作为 attribute 应用到目标元素或组件上, 这在官方文档中有着详细介绍。
&amp;lt;BaseButton v-bind=&amp;#34;$attrs&amp;#34;/&amp;gt; 其中$attrs包含组件可以透传属性的对象, 透传属性包括props,events, class,style,id等。(不包含接收组件显式声明的 props、emits以及slots )
如下,是一个封装el-input的默认可清空的的组件，由于我们已经在defineProps声明过clearable, 所以此时我们需要显性传递clearable属性
&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;my-input&amp;#34;&amp;gt; {{ label }} &amp;lt;el-input v-bind=&amp;#34;$attrs&amp;#34; :clearable=&amp;#34;clearable&amp;#34;&amp;gt;&amp;lt;/el-input&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script setup&amp;gt; defineProps({ label: String, clearable: { type: Boolean, default: true, }, }); &amp;lt;/script&amp;gt; 如果我们不希望透传某些属性比如class, 我们可以通过useAttrs来实现
&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;my-input&amp;#34;&amp;gt; {{ label }} &amp;lt;el-input v-bind=&amp;#34;filteredAttrs&amp;#34; :clearable=&amp;#34;clearable&amp;#34;&amp;gt;&amp;lt;/el-input&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script setup&amp;gt; import { computed, useAttrs } from &amp;#39;Vue&amp;#39;; defineProps({ label: String, clearable: { type: Boolean, default: true, }, }); const attrs = useAttrs(); const filteredAttrs = computed(() =&amp;gt; { return { .</description></item><item><title>vue nextTick的原理</title><link>https://chenkai.life/vue/vue-nex-tick/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue-nex-tick/</guid><description>nextTick是 vue 的一个全局 API， 作用是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
const callbacks = []; let pending = false; function flushCallbacks() { pending = false; const copies = callbacks.slice(0); callbacks.length = 0; for (let i = 0; i &amp;lt; copies.length; i++) { copies[i](); } } // Here we have async deferring wrappers using microtasks. // In 2.</description></item><item><title>Vue样式dev和build下不一致</title><link>https://chenkai.life/vue/vue-page-style-dev-build-different/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue-page-style-dev-build-different/</guid><description>一次更新镜像后发现 vue 项目页面混乱，在开发模式模式下，写的样式有效，打包后无效
一、多个相同样式文件同时存在项目中 现象：修改组件时，在项目中复制了一个组件重命名后进行修改，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：在本地试图修改总是不见效果，在控制台查看样式仍是之前的样式，把其中一处样式在所有相关组件中修改，打包上传后样式生效，这说明是旧的样式在打包时覆盖了新的样式。将旧组件删除后解决上述问题。 原因猜测：因为相同组件包含不同样式时，无法判断哪份样式时在后面渲染，如果旧样式刚好打包后在后面渲染，则会覆盖掉新写的样式。在本地执行时，因为样式没有打包，访问页面时渲染的都是组件自身样式，所以不会出现上述问题。
二、全局(main.js)引用样式 现象：在全局引入了 Element UI 样式，在 header 组件中修改部分样式，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：因为在项目中段发现该问题，以为是后续的样式造成的影响(虽然我也认为可能性极小)，删除新写的组件，没有效果。运行一段时间之前的代码，项目正常运行，这迫使我回想中间这段时间对项目做了什么？除了新写了一些组件，还将一些配置信息从 index.js 中转移到了 main.js 中，测试发现果然是这里出现了问题。配置中同时出现了 Element UI 样式文件引用，还有 router 的引用，将 yang 样式引用放在 router 引用后解决问题。 原因猜测：不正常的样式显示的还是组件原始的样式，由此猜测 router 加载时会加载组件样式，将样式文件在 router 后引用会将 router 加载时渲染的样式覆盖掉，所以建议将 router 的引用放在最后面。在每个组件的样式中记得添加 ‘scoped’.
import &amp;#34;element-ui/lib/theme-chalk/index.css&amp;#34;; //element样式文件 import App from &amp;#34;./App&amp;#34;; 如果相反，那么 element-ui 的样式会覆盖自定义的样式，所以会出现你修改的样式不生效问题！！</description></item><item><title>Vue组件的自动按需引入</title><link>https://chenkai.life/vue/vue-component-registration/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue-component-registration/</guid><description>在Vue中我们可以通过全局组件、局部注册的方式来使用组件
全局注册 通过app.component来创建全局组件
import { createApp } from &amp;#39;vue&amp;#39; import HelloWorld from &amp;#39;./components/HelloWorld&amp;#39; const app = createApp({}) // 全局注册一个名为hello-wolrd的组件 app.component(&amp;#39;hello-wolrd&amp;#39;, HelloWorld); 一旦我们全局注册了组件，我们就可以在任何地方使用这个组件：&amp;lt;hello-wolrd/&amp;gt;
值得注意的是全局注册会使Vue失去TypeScript的支持, Vue 3 有一个 PR 扩展了全局组件的接口。目前，Volar 已经支持这种用法，我们可以通过在根目录添加components.d.ts文件的方式来添加全对局组件的TypeScript的支持
declare module &amp;#39;vue&amp;#39; { export interface GlobalComponents { HelloWorld: typeof import(&amp;#39;./src/components/HelloWorld.vue&amp;#39;)[&amp;#39;default&amp;#39;] } } 局部注册 我们可以直接从文件中引入vue组件使用，
在单文件组件中（SFC）
&amp;lt;template&amp;gt; &amp;lt;HelloWorld msg=&amp;#34;Welcome to Your Vue.js App&amp;#34;/&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import HelloWorld from &amp;#39;./components/HelloWorld.vue&amp;#39; export default { name: &amp;#39;App&amp;#39;, components: { HelloWorld } } &amp;lt;/script&amp;gt; 在JSX中</description></item></channel></rss>