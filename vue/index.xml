<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vues on CK's Blog</title><link>https://chenkai.life/vue/</link><description>Recent content in Vues on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 06 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://chenkai.life/vue/index.xml" rel="self" type="application/rss+xml"/><item><title>关于Vue组件二次封装的技巧总结</title><link>https://chenkai.life/vue/guanyu-vue-zujian-fengzhuang/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/guanyu-vue-zujian-fengzhuang/</guid><description>在开发Vue项目我们一般使用第三方UI组件库进行开发，如element-plus, @arco-design/web-Vue, naive-ui等, 但是这些组件提供的接口并不一定满足我们的需求，这时我们可以通过对组件库组件的二次封装，来满足我们特殊的需求。 对于封装组件有一个大原则就是我们应该尽量保持原有组件的接口，除了我们需要封装的功能外，我们不应该改变原有组件的接口，即保持原有组件提供的接口如props,events,slots等不变。 为了实现这一原则我们就需要将新组件的接口与旧组件的接口一一对应, 当然我们可以通过在新组件中一一声明对应的接口来实现（或者只实现我们目前需要用到的接口）但这种办法虽然简单但看起来却极其很繁琐, 有没有一种方法可以实现props,events,slots的自动透传呢？
透传 Attribute 我们可以使用一个没有参数的 v-bind来实现props,events的透传， 它会将一个对象的所有属性都作为 attribute 应用到目标元素或组件上, 这在官方文档中有着详细介绍。
&amp;lt;BaseButton v-bind=&amp;#34;$attrs&amp;#34;/&amp;gt; 其中$attrs包含组件可以透传属性的对象, 透传属性包括props,events, class,style,id等。(不包含接收组件显式声明的 props、emits以及slots )
如下,是一个封装el-input的默认可清空的的组件，由于我们已经在defineProps声明过clearable, 所以此时我们需要显性传递clearable属性
&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;my-input&amp;#34;&amp;gt; {{ label }} &amp;lt;el-input v-bind=&amp;#34;$attrs&amp;#34; :clearable=&amp;#34;clearable&amp;#34;&amp;gt;&amp;lt;/el-input&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script setup&amp;gt; defineProps({ label: String, clearable: { type: Boolean, default: true, }, }); &amp;lt;/script&amp;gt; 如果我们不希望透传某些属性比如class, 我们可以通过useAttrs来实现
&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;my-input&amp;#34;&amp;gt; {{ label }} &amp;lt;el-input v-bind=&amp;#34;filteredAttrs&amp;#34; :clearable=&amp;#34;clearable&amp;#34;&amp;gt;&amp;lt;/el-input&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script setup&amp;gt; import { computed, useAttrs } from &amp;#39;Vue&amp;#39;; defineProps({ label: String, clearable: { type: Boolean, default: true, }, }); const attrs = useAttrs(); const filteredAttrs = computed(() =&amp;gt; { return { .</description></item><item><title>Vue组件的自动按需引入</title><link>https://chenkai.life/vue/vue-component-registration/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue-component-registration/</guid><description>在Vue中我们可以通过全局组件、局部注册的方式来使用组件
全局注册 通过app.component来创建全局组件
import { createApp } from &amp;#39;vue&amp;#39; import HelloWorld from &amp;#39;./components/HelloWorld&amp;#39; const app = createApp({}) // 全局注册一个名为hello-wolrd的组件 app.component(&amp;#39;hello-wolrd&amp;#39;, HelloWorld); 一旦我们全局注册了组件，我们就可以在任何地方使用这个组件：&amp;lt;hello-wolrd/&amp;gt;
值得注意的是全局注册会使Vue失去TypeScript的支持, Vue 3 有一个 PR 扩展了全局组件的接口。目前，Volar 已经支持这种用法，我们可以通过在根目录添加components.d.ts文件的方式来添加全对局组件的TypeScript的支持
declare module &amp;#39;vue&amp;#39; { export interface GlobalComponents { HelloWorld: typeof import(&amp;#39;./src/components/HelloWorld.vue&amp;#39;)[&amp;#39;default&amp;#39;] } } 局部注册 我们可以直接从文件中引入vue组件使用，
在单文件组件中（SFC）
&amp;lt;template&amp;gt; &amp;lt;HelloWorld msg=&amp;#34;Welcome to Your Vue.js App&amp;#34;/&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import HelloWorld from &amp;#39;./components/HelloWorld.vue&amp;#39; export default { name: &amp;#39;App&amp;#39;, components: { HelloWorld } } &amp;lt;/script&amp;gt; 在JSX中</description></item></channel></rss>