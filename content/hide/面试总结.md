---
title: "面试总结"
draft: true
date: '2025-04-20'
---

+ https://vue3js.cn/interview/
+ https://juejin.cn/post/7208005892313579576
+ https://juejin.cn/post/7343484473184698405
+ https://juejin.cn/post/7330065707358208010
+ https://www.nowcoder.com/exam/interview/81754024/test?paperId=50270010&jobs=%5B11201%5D&order=0
+ https://www.nowcoder.com/exam/interview/81754153/test?paperId=50270066&jobs=%5B11201%5D&order=0
+ https://www.xiangshu233.cn/%E5%89%8D%E7%AB%AF%203-5%20%E5%B9%B4%E7%BB%8F%E9%AA%8C%E9%9D%A2%E8%AF%95%E9%A2%98/#css-%E4%B8%AD%E7%9A%84-BFC-%E6%98%AF%E4%BB%80%E4%B9%88
+ https://fecommunity.github.io/front-end-interview/%E9%9D%A2%E7%BB%8F%E7%B3%BB%E5%88%97/3.%E7%99%BE%E5%BA%A6%E9%9D%A2%E7%BB%8F.html
+ https://jecyu.github.io/Web-Performance-Optimization/tool-monitor/chromeDev.html#%E5%88%86%E6%9E%90%E9%9D%A2%E6%9D%BF%E4%BB%8B%E7%BB%8D

# Vue 
+ 响应式原理：track（依赖项跟踪）、trigger更新触发 <https://vuejs.org/guide/extras/reactivity-in-depth.html>
  - 劫持属性的读写, Vue 2 使用 `Object.defineProperty`  Vue 3 中则使用了 `Proxy` 来创建响应式对象，仅将 getter / setter 用于 ref(检测普通变量的访问或修改是行不通的),
  - 在访问时跟踪依赖(get:track)、在变更时触发副作用(set:trigger)
+ 内置组件: Transition TransitionGroup KeepAlive Teleport Suspense
+ 内置指令: v-text v-html v-show v-if v-else v-else-if v-for v-on v-bind v-model v-slot v-pre v-once v-memo v-cloak
+ 自定义指令:
  - (el, binding) => {}, 在 `mounted` 和 `updated` 时都调用
  - el(指令绑定到的元素。这可以用于直接操作 DOM), binding(value,oldValue,arg,modifiers,instance,dir), vnode(绑定元素的底层 VNode)
  - created 在绑定元素的 attribute 前 或事件监听器应用前调用
  - beforeMount 在元素被插入到 DOM 前调用
  - mounted 在绑定元素的父组件 及他自己的所有子节点都挂载完成后调用
  - beforeUpdate 绑定元素的父组件更新前调用
  - updated 在绑定元素的父组件及他自己的所有子节点都更新后调用
  - beforeUnmount 绑定元素的父组件卸载前调用
  - unmounted 绑定元素的父组件卸载后调用
+ 插件: 拥有 install() 方法的对象，也可以直接是一个安装函数本身, `全局组件或自定义指令` `provide` `全局实例属性或方法`
+ 组合式 API: `响应式 API` `生命周期钩子` `依赖注入`
+ 组件封装经验
+ 路由
+ 插槽: 默认插槽、具名插槽（name）、条件插槽、动态插槽名、作用域插槽
+ 状态管理（vuex, pina）: state、getters、actions ｜ function
+ Vue 2、Vue 3: TS代码、代码拆分、组合 API、响应式、生命周期、API 增加、减少、编译优化、
+ nextTick: nextTick通过将回调函数添加到异步任务队列中，下次 DOM 更新循环结束之后执行延迟回调
+ 核心: ref、computed、reactive、readonly、watchEffect、watchPostEffect、watchSyncEffect、watch
+ 工具函数: isRef、unref、toRef、toValue、toRefs、isProxy、isReactive、isReadonly
+ 高级: shallowRef、triggerRef、customRef、shallowReactive、shallowReadonly、toRaw、markRaw、effectScope、getCurrentScope、onScopeDispose
+ 生命周期: 每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。 beforeCreate, created, onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount、onUnmounted、onActivated、onDeactivated、onErrorCaptured、onRenderTracked、onRenderTriggered、onServerPrefetch
+ provide、inject、hasInjectionContext: 将父组件的 provides 对象设置到当前组件实例的 provides 属性的原型对象
+ mixin、extends
+ 双向数据绑定原理
  - 在访问时跟踪依赖、在变更时触发副作用的
  - 当Vue实例化时，会遍历data对象中的每个属性，使用`Object.defineProperty`为每个属性设置getter和setter。
  - 在模板中，如果使用了数据绑定（例如{{ message }}），Vue会生成一个Watcher对象，将其与对应的DOM元素关联起来。
  - 当数据发生变化时，setter被调用，通知Watcher对象更新视图。
  - 当用户与视图交互，如输入表单元素时，Vue会监听DOM事件，然后通过setter更新数据，从而实现数据模型到视图的同步更新。
  - 当一个对象被包装为响应式对象时，Vue会使用Proxy来代理这个对象，拦截对该对象的读取（get）和修改（set）操作
+ 虚拟 DOM: 高效\灵活：
  - DOM 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步
  - 运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为挂载 (mount)
  - 如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，应用到真实的 DOM 上。这个过程被称为更新 (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)
+ diff函数
  - 复杂度O(n)，因为它会将组件结构打平，而不是基于树的结构进行遍历（得益于编译阶段的模板分析）
  - 对于稳定的结构（不含v-if，v-for），vue会调用patchBlockChildren函数，逐个对新旧VNode进行对比
  - 结构不是稳定的组件：比较key、patchFlag（标记了组件有哪些动态属性）
  - 第⼀个是相同的前置与后置元素的预处理，从头部、尾部开始调用path算法，对于相同类型的新旧阶段逐个patch，直到不匹配
  - 生成最长递增子序列（让需要移动的元素最少）
  - 父节点先触发更新-->然后子节点触发更新-->子节点完成更新-->父节点完成更新
+ Vue 组件挂载
  - 编译：Vue 模板被编译为渲染函数：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。
  - 挂载：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。
  - 更新：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。
+ vue 编译优化: `静态提升` `更新类型标记` `树结构打平`
+ 如何实现组件之间的通信: props、事件、ref实例、$parent、$children、Provide 与 Inject、EventBus、Vuex|pina
+ Vue 3 中的动画是如何实现的？
  - Vue 提供了 <Transition> 和 <TransitionGroup> 组件来处理元素进入、离开和列表顺序变化的过渡效果
  - 动态添加 CSS class 来触发动画
  - 动态地给元素绑定样式
  - 基于侦听器的动画
+ Transition 触发条件
  - 由 v-if 所触发的切换
  - 由 v-show 所触发的切换
  - 由特殊元素 <component> 切换的动态组件
  - 改变特殊的 key 属性
+ Transition 实现原理
  - Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 CSS 过渡 class 会在适当的时机被添加和移除。
  - 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。
  - 如果没有探测到 CSS 过渡或动画、也没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧后执行。
  - `v-enter-fro`m`：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。
  - `v-enter-active`：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。
  - `v-enter-to`：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 v-enter-from 被移除的同时)，在过渡或动画完成之后移除。
  - `v-leave-from`：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。
  - `v-leave-active`：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。
  - `v-leave-to`：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 v-leave-from 被移除的同时)，在过渡或动画完成之后移除。
+ ref vs reactive: `有限的值类型` `不能替换整个对象` `对解构操作不友好`
+ vue vs react
  - Hooks 有严格的调用顺序，并不可以写在条件分支中
  - setup代码仅调用一次,组合式 API 也并不限制调用顺序
  - Vue 的响应性系统运行时会自动收集计算属性和侦听器的依赖，因此无需手动声明依赖。
  - 无需手动缓存回调函数来避免不必要的组件更新
+ 当遇到错误时，如何有效地排查和解决 Vue3 中的问题: `控制台` `Vue开发者工具` `调试工具` 生命周期函数、`猜测 验证 猜测 逼近`
+ 虚拟滚动：仅仅渲染用户当前可见区域内的数据，而不是一次性渲染整个数据集，监听用户滚动事件，根据滚动位置动态地计算出哪些数据应该处于视窗内
+ vue 性能优化
  - 网络: gzip 、缓存
  - 体积优化: ES 模块格式的依赖, 按需引入、 代码分割，懒加载路由、现代的打包工具
  - 缓存: keep-alive、key、v-memo、v-once、props 尽量保持稳定、
  — 虚拟列表、减少大型不可变数据的响应性开销， 通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应、避免不必要的组件抽象
  - 体验: css 动画、css 替代 JS
+ v-if和v-for的优先级是什么
  - v-for 优先 v-if 导致每次都会进行一次if判断
  - 在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环
  - 通过计算属性computed提前过滤掉那些不需要显示的项
+ Vue 中是怎么监测数组的变化
  - vue 2: 通过 Array 原型上的方法改变数组内容的时候是无发触发 getter/setter 的，通过对数组原型的方法进行重写
  - vue 3: 'push', 'pop', 'shift', 'unshift', 'splice', 会读取 length 属性，也会设置 length 属性，导致 track & trigger 一起触发, 需要特殊处理
+ SSR
  - 服务器渲染的标记不需要等到所有 JavaScript 都下载并执行完后才显示，因此您的用户将更快地看到完全渲染的页面
  - 更好的 SEO （meta 指定搜索关键词）
  - 服务器端负载，流量大，需要更多的用到缓存，作用域隔离(pina)
  - https://nuxt.com/ https://nextjs.org/docs
+ 编写 SSR 友好型代码
  -  SSR 期间不会调用 onMounted 或 onUpdated 等生命周期钩子，并且只会在客户端上执行(避免根范围内清理的副作用， 由于在 SSR 期间永远不会调用卸载钩子，因此计时器将永远存在。为避免这种情况，请将您的副作用代码改为 onMounted 中)
  - 仅限浏览器的 API，常见的方法是在仅限客户端的生命周期钩子（如 onMounted）中延迟访问它们
  - 交叉请求状态污染，JavaScript 模块的根范围内声明的响应式变量是共享状态。这使它们成为单例，应用程序模块通常只在服务器上初始化一次，在每个请求上创建整个应用程序（包括路由器和全局存储）的新实例（pina）
  - ClientOnly(nuxt)
+ useTemplateRef()
  - 通过 Object.defineProperty 监听 ref[key] 的 get setter 行为，为组件的 refs 赋值
  - 通过 shallowRef 生成 ref 实例，并作为 useTemplateRef 的返回值
+ pina 原理用法
```js
// Option Store
export const useCounterStore = defineStore('counter', {
  state: () => ({ count: 0, name: 'Eduardo' }),
  getters: {
    doubleCount: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})

// Setup Store
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const doubleCount = computed(() => count.value * 2)
  function increment() {
    count.value++
  }

  return { count, doubleCount, increment }
})
```
## 组件执行顺序
### 加载渲染过程
父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created 
子beforeMount -> 子mounted -> 父mounted
### 父组件引起的子组件更新过程
父beforeUpdate -> 子beforeUpdate -> 子updaed -> 父updated
### 父组件跟新过程
父beforeUpdate -> 父updated
### 子组件跟新过程
子beforeUpdate -> 子updated
### 销毁过程
父beforeDestroy -> 子beforeDestroy -> 子destroyed ->父destroyed

# CSS
+ @media、@layer、@scope、@keyframes、@import、@supports
+ 盒子模型：每个HTML元素看作是一个矩形的盒子，这个盒子由四个部分组成：内容区域（content）、内边距（padding）、边框（border）和外边距（margin）
  - content-box： `box-sizing: content-box` 元素的宽度和高度仅包括内容区域的尺寸，不包括内边距、边框和外边距
  - border-box： `box-sizing: border-box` 元素的宽度和高度包括内容区域、内边距和边框，但不包括外边距。
+ 行内元素
  - 默认情况下，行内元素不会开始新的一行，而是在一行中水平排列
  - 它们只占据它们实际的宽度，不会强制换行
  - 行内元素的宽度、高度、内边距和外边距（上下）都不可设置，只能通过CSS设置水平方向的间距（如左右内边距、外边距）。
+ 块元素
  - 块级元素会始终在新行上开始，并且会占据其父元素（容器）的整个宽度（除非设置了宽度属性）。
  - 可以设置宽度、高度、内边距和外边距等样式。
  - 块级元素可以包含行内元素和其他块级元素
+ display: block、inline、inline-block、flex、grid 和 none
+ position: 指定元素的定位方式
  - static:默认值，元素按照正常的文档流进行布局。top、right、bottom 和 left 属性不起作用
  - relative: 相对定位，元素相对于其正常位置进行偏移，但仍然占据原来的空间。偏移量由 top、right、bottom 和 left 属性指定。
  - absolute: 绝对定位，元素相对于最近的已定位（非static）祖先元素进行偏移，如果没有已定位的祖先元素，则相对于root进行定位。`脱离了文档流，不占据空间`
  - fixed: 固定定位，元素相对于视口（viewport）进行定位，即不论页面滚动与否，元素始终停留在相同位置。`脱离了文档流，不占据空间`
  - sticky: 粘性定位，根据用户的滚动位置在不同的位置切换定位类型（相对定位和固定定位的结合）。当元素在容器中可见时，表现为相对定位；当元素超出容器时，表现为固定定位。`脱离了文档流，不占据空间`
+ 弹性盒子: 一维布局模型，用于在物品之间分配空间，并包括许多对齐功能
  - `flex\flex-flow` `flex-direction` `flex-wrap` `justify-content` `align-items` `align-content`
  - `align-self` `flex-basis` `flex-grow` `flex-shrink` `order`
+ 网格:grid
  - grid-template-columns grid-template-rows  grid-template-areas justify-items align-items
  - grid-area grid-column-start grid-column-end grid-row-start grid-row-end
+ 浮动
  - 额外的清除元素 `"clear: both`
  - 伪元素 `::after { content: ""; display: block; clear: both;}`
  - 设置父容器的 overflow 属性为 auto 或 hidden 也可以清除浮动
  - display: Flex Grid flow-root table inline-flex inline-grid
+ BFC（Block Formatting Context）即块级格式化上下文： 一块独立的渲染区域，内部的元素布局不会影响到外部元素，外部元素的布局也不会影响到内部元素
  - 清除浮动：可以包裹浮动元素，防止父元素高度塌陷、排除外部浮动
  - 防止 margin 重叠：在普通文档流中，上下相邻的两个块级元素的垂直外边距可能会发生重叠，而处于 BFC 中的元素不会与外部元素发生 margin 重叠。
+ 如何触发 BFC
  - ]
  - 绝对定位元素（元素的 position 为 absolute 或 fixed）
  - 行内块元素（元素的 display 为 inline-block）
  - overflow 计算值(Computed)不为 visible 的块元素
  - display 值为 flow-root 的元素
  - contain 值为 layout、content 或 paint 的元素
  - 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）
  - 网格元素（display 为 grid 或 inline-grid 元素的直接子元素）
+ CSS 优先级：浏览器通过优先级来判断哪些属性值与一个元素最为相关，从而在该元素上应用这些属性值
  - 优先级相等：最后的那个声明将会被应用
  - 内联 style > 外部样式表 > link
  - 选择器类型：id > class > 元素, 选择器变得更加具体 优先级越大，` div span > span  `
  - !important, 冲突的的按照 important 优先级
  - 伪类 :where() 总是会将其优先级替换为零
  - 添加样式 > 继承样式
  - @layer
+ @layer声明了一个 级联层，同一层内的规则将级联在一起，这给予了开发者对层叠机制的更多控制
  - 如果同一声明在多个级联层中被指定，最后一层中的将优先于其他层
  - 不属于任何一级联层的样式将被集中到同一匿名层，并置于所有层的后部，这意味着任何在层外声明的样式都会覆盖在层内声明的样式
  - 没有指定顺序的话，声明的后面的合并覆盖前面的，指定顺序后如`@layer base, special;`，同名合并覆盖
+ 浏览器渲染过程 <https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work>
  - 下载完 CSS 并生成 CSS 对象模型（CSSOM）后，浏览器才会绘制页面（如果先让用户看到一个没有样式的页面，等 CSS 样式解析完后再重绘（repaint），这样的体验会很差）
  - 生成渲染树（render tree），而渲染树的生成则需要 DOM 和 CSSOM 树的配合
  - 布局（layout）完成后才能绘制（paint）页面
+ css 性能
  - 删除不必要的样式
  - 将 CSS 拆分为独立模块, 仅加载初始页面所需内容， `<link rel="stylesheet" href="mobile.css" media="screen and (max-width: 480px)" />`(会下载样式表，但不会阻塞渲染)
  - 压缩 CSS
  - 避免使用不必要且复杂的 CSS 选择器，简化选择器(层级、 范围)
  - 增加必要动画（看起来更流畅）
  - 减少不必要动画，特别是对性能影响比较大的，某些属性在进行动画处理时会触发重排
    - 修改元素的尺寸，例如 width、height、border 和 padding。
    - 重新定位元素，例如 margin、top、bottom、left 和 right。
    - 更改元素的布局，例如 align-content、align-items 和 flex。
    - 添加改变元素几何形状的视觉效果，例如 box-shadow。
  - 不会引起重排/重绘的动画：transforms、opacity、filter
  - 在 GPU 上进行动画处理: 选择特定类型的动画来实现，浏览器会自动将这些动画发送到 GPU 来处理,`transform`,  `will-change`, 特定的在其自己层中渲染的元素，包括 `<video>`、`<canvas>` 和 `<iframe>`
  - will-change 属性向浏览器提示元素预期的变化方式, `.element { will-change: opacity, transform; }`
  - CSS 局限: 通过允许浏览器从页面的其余部分中隔离出页面子树而改善性能(contain, content-visibility)
  - contain: 
+  contain: contain属性用于控制元素的布局和绘制范围，以提高页面的渲染性能
  - node: 元素照常渲染
  - content: 将除 size 外的所有局限规则应用于元素。此值等价于 `contain: layout paint style`
  - strict：将所有局限规则应用于元素。此值等价于 `contain: size layout paint style`
  - layout：从页面的其余部分中隔离出元素的内部布局。此值意味着元素外的任意内容和元素内部布局互不影响
  - style: 对于可在元素及其后代外产生影响的属性，其影响将不会逃离包含元素
  - paint：元素后代不在元素边界外显示。若包含盒在屏外，则浏览器无需绘制其被局限的元素——这些元素因为完全局限于此盒故必定也在屏外。若后代元素溢出包含元素的边界，则此后代元素将被裁剪至包含元素的边框盒
  - size: 在行向和块向上将尺寸局限应用于元素
+ 层叠上下文：HTML 元素基于其元素属性按照优先级顺序占据虚构的 z 轴排开<https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context>
  - position 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素；
  - position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素
  - flex (flex) 容器的子元素，且 z-index 值不为 auto；
  - grid (grid) 容器的子元素，且 z-index 值不为 auto；
  - opacity 属性值小于 1 的元素（参见 the specification for opacity）
  - isolation：决定了元素是否必须创建一个新的层叠上下文
  - 层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。
  - 每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。
  - 每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠（可以想象成版本号 1.9 < 3.1 ）
+ 伪类：用于选择那些无法用常规选择器选择的元素状态，比如元素的特定状态或元素在文档树中的特定位置。`:hover` `:focus` `:nth-child(n)` `:first-child` `:last-child` `:not(selector)` `:where(div, button)` `:is(div, button)` `h1:has(+ p)`
+ 伪元素: 伪元素用于选择和样式化元素的一部分或插入新的元素。这些通常是通过双冒号 :: 来表示 `::before` `::after` `::first-letter` `::first-line` `::selection`
+ 元素选择器
+ 响应式布局
  - `<meta name="viewport" content="width=device-width, initial-scale=1.0">`
  - media query、
  - 弹性布局：flexbox
  - 栅格系统：grid
  - 调整大小: rem 适配, vw wh
  - 重新定位，重新排列，显示 / 隐藏
  - 针对不同尺寸的屏幕采用不同形态的组件
+ div 居中
  - 使用 line-height 居中单行文本
  - 使用 text-align 居中内联或内联块元素
  - 使用 margin: auto 居中块级元素
  - flex: justify-content \ align-items
  - grid: place-items
+ css兼容: `@supports, flex 替换 grid`
+ 什么是BEM（Block Element Modifier）命名规范
```html
<!-- 通过将类名分成块（Block）(定义一个独立的实体或组件，表示功能和内容的最外层容器)、元素（Element）(表示块的组成部分，描述块内部的某个部分。)和修饰符（Modifier）(描述块或元素的外观、状态或行为的变化。)三部分，来构建组件的样式。旨在提高代码的可读性和可维护性 -->
<nav class="menu">
    <h1 class="menu__title">Site Navigation</h1>
    <ul class="menu__list">
        <li class="menu__item menu__item--active">Home</li>
        <li class="menu__item">About</li>
        <li class="menu__item">Services</li>
        <li class="menu__item">Contact</li>
    </ul>
</nav>
```
+ 动画
  - 触发方式：动画可以自动播放，不需要用户交互，也可以通过添加或移除类来触发。
  - 复杂性：适用于更复杂的动画效果，可以定义多个关键帧。
  - 定义方式：使用 @keyframes 规则定义关键帧序列。
  - 动画属性：animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction, animation-fill-mode, + animation-play-state
```css
@keyframes fadeinout {
  0%, 100% { opacity: 0; }
  50% { opacity: 1; }
}

div {
  animation: fadeinout 3s infinite;
}
```
+ CSS 过渡（Transitions）
  - 触发方式：过渡是由某个事件触发的，如鼠标悬停、聚焦、点击等。
  - 简单性：适合用于简单的状态变化，如颜色、位置、透明度等。
  - 定义方式：只需定义开始状态和结束状态，浏览器会自动计算中间帧。
  - 过渡属性：transition-property, transition-duration, transition-timing-function, transition-delay
```css
.element {
  width: 100px;
  height: 100px;
  background-color: blue;
  transition: width 2s, height 2s, background-color 2s;
}

.element:hover {
  width: 200px;
  height: 200px;
  background-color: red;
}
```

# JS
+ this: 指一段代码运行的上下文
  - JavaScript 中的值 this 取决于函数的调用方式（运行时绑定），当常规函数作为对象 （ obj.method() ） 的方法被调用时， this 指向该对象
  - 独立函数（未附加到对象： func() ） this 调用时，通常引用全局对象（在非严格模式下）或 undefined （在严格模式下）。
  - bind可以创建其 this 绑定不更改的函数
  - apply、call可以设置特定调用的 this 值
  - 箭头函数没有自己的 this，它会捕获其所在上下文（父作用域继承）的 this 值。此行为使箭头函数对于回调和保留上下文特别有用, 全局代码中，this 总是 globalThis 与严格程度无关
  - 构造函数: this 都会绑定到正在构造的新对象
+ 箭头函数与普通函数有什么区别
  - 语法简洁性
  - 箭头函数没有自己的 this，它会捕获其所在上下文（父作用域继承）的 this 值。此行为使箭头函数对于回调和保留上下文特别有用
  - 箭头函数没有自己的 arguments 对象
  - 箭头函数不能用作构造函数，不能通过 new 关键字调用。
+ Array: 
  - 数组的方法: push、pop、shift、unshift、splice、slice、concat、join、map、filter、reduce、every、some、find、findIndex、indexOf、lastIndexOf、includes、sort、reverse、forEach、entries、keys、values、flat、flatMap、toSpliced、toReversed、with、at
  - 数组的静态方法: Array.from、Array.of、Array.isArray、Array.prototype.findIndex
+ Object
 -  对象的方法: Object.keys、Object.values、Object.entries、Object.getOwnPropertyNames、Object.getOwnPropertySymbols、Object.create、Object.assign、Object.freeze、Object.seal、Object.isFrozen、Object.isSealed、Object
+ String
  - 字符串的方法: charAt、charCodeAt、concat、indexOf、lastIndexOf、slice、substring、substr、split、trim、toUpperCase、toLowerCase、match、replace、search、repeat
## ES6 Module和CommonJS模块区别
CommonJS 模块是为 Node.js 打包 JavaScript 代码的原始方式
+ 模块在首次加载后进行缓存。这意味着（除其他外）如果解析为相同的文件，则每次调用 require（'foo'） 都将返回完全相同的对象。
ECMAScript 模块是打包 JavaScript 代码以供重用的官方标准格式。模块使用各种 import 和 export 语句
+ 没有 require、exports 或 module.exports
+ 无__filename或__dirname

<!-- TODO -->
+ Reflect&Proxy
+ Objek.defineProperty
+ class 类
+ 原型链
+ 闭包
+ Promise
+ Generator
+ 迭代、异步迭代
+ 正则
+ WebWorker
+ new 一个对象 发生了什么
  - 创建一个新对象
  - 将新对象的原型指向构造函数的原型，新对象的内部`[[Prototype]]`（在现代浏览器中可以通过Object.getPrototypeOf()访问）, 被设置为构造函数的原型对象。这使得新对象可以访问构造函数原型上的属性和方法 `Object.getPrototypeOf(person) === Person.prototype`
  - 执行构造函数: 构造函数被执行，并且将新创建的对象作为this的值传入构造函数。在构造函数内部，可以使用this来添加属性和方法到新创建的对象上
  - 返回新对象: 构造函数显式地返回的对象或者新创建的对象。
+ 宏任务：定时器、浏览器事件、网络请求完成后的回调函数、MessageChannel
+ 微任务：Promise.resolve().then(), queueMicrotask、MutationObserver
+ 闭包：当一个内部函数被定义在外部函数中，并在外部函数之外被调用时，就创建了一个闭包。这个内部函数可以访问外部函数的变量和参数，即使外部函数已经执行完毕
  - 数据隐藏和封装：可以利用闭包来创建私有变量，实现数据的封装。在函数外部无法直接访问这些私有变量，只能通过暴露的公共方法来操作它们, 立即执行函数,（IIFE）
  - 函数工厂：根据不同的参数生成具有特定行为的函数（node 中间件、Vite 插件）
  - 缓存和记忆化：闭包可以用于实现缓存功能，避免重复计算。对于一些开销较大的计算，可以将结果缓存起来，下次调用时如果参数相同直接返回缓存的结果
  - 函数柯里化：可以固定部分参数，创建一个新的函数，这个新函数只需要接收剩余的参数(参数复用, 延迟计算, 函数组合)
  - 闭包会保留对外部函数变量的引用，这可能导致内存泄漏问题，闭包引用的变量不再需要，应该及时清理

# TypeScript

+ 泛型：它允许我们在定义函数、类或接口时使用类型参数，这些类型参数可以在使用时被具体的类型替代
+ 内置类型函数: Awaited、Partial、Record、Pick、Parameters、ConstructorParameters、ReturnType、InstanceType
+ interface、type 区别: 都可以用来表示接口，即定义对象或者函数
  - 都可以实现继承: interface 可以 extends type可以通过交叉类型（&）
  - type 可以声明基本类别名，即可以为原始类型重命名，而 interface 不可以。例如：`type A = number`
  - type 可以定义元组类型，而 interface 不可以。例如：`type A = [number, string]`
  - type 可以使用交叉类型和联合类型，而 interface 不可以。例如：`type A = A1 | A2 / type B = B1 & B2`
  - type 可以通过 typeof 获取实例的类型进行赋值定义，而 interface 不可以。例如：`type A = typeof obj / type A = keyof obj`
  - interface 可以重复定义会进行声明合并，而 type 不可以。例如：`interface A { name: string }  interface A { get: string }`
+ any，never，void和unknown的区别
  - any: TypeScript将会跳过对这个变量的类型检查, 允许赋值为任意类型, 访问任意属性和方法(无法确定变量的类型 ,或者无需确认类型时)
  - unknown: 需要描述我们不确定的变量类型， 希望有意接受 API 中的所有值, 使用时可以通过执行 typeof 检查、比较检查或更高级的类型守卫来将其缩小到更具体的内容否则会类型报错
  - void: 通常将此视为不返回值的函数的返回类型，只能分配 undefined 或 null（strictNullChecks为 true）, never, any
  - never: 表示不存在的值, 是所有其他类型的子类型。这意味着可以将 Never类型的值赋值给任何其他类型的变量，但不能将其他类型的值赋值给 Never类型的变量（一个函数如果永远不会正常返回（比如函数中抛出了一个永远不会被捕获的异常，或者进入了一个无限循环），那么这个函数的返回值类型可以被推断为 Never）
+ strictNullChecks
  - false: 会忽略 null 和 undefined。这可能会导致运行时出现意外错误
  - true: null 和 undefined 有自己的不同类型，如果尝试在需要具体值的地方使用它们，则会收到类型错误

+ 解释 TypeScript 中的接口（interface）是什么，以及它的用途。
+ 说说 TypeScript 中的泛型（generics）有哪些应用场景。
+ 什么是 TypeScript 中的类型别名（type alias）？与接口有何区别？
+ 如何在 TypeScript 中实现函数重载？
+ 描述 TypeScript 中的枚举（enum）类型及其特点。
+ 解释 TypeScript 中的装饰器（decorator）是什么以及如何使用。
+ TypeScript 中的联合类型（union type）和交叉类型（intersection type）有什么不同？
  - 联合类型表示一个值可以是多种类型中的一种。它使用竖线（|）来连接不同的类型
  - 交叉类型表示一个值同时具有多种类型的特征。它使用与号（&）来连接不同的类型, `type CombinedType = TypeA & TypeB`表示 CombinedType 同时具有 TypeA 和 TypeB 的所有属性和方法
+ 如何在 TypeScript 中处理可选参数和默认参数？
+ 谈谈你对 TypeScript 中类型推断的理解。
+ 什么是 TypeScript 的类型守卫？举例说明。
+ 如何在 TypeScript 中实现继承？
+ 解释 TypeScript 中的模块（module）系统。
+ TypeScript 中的索引签名（index signature）是用来做什么的？: 约束动态对象属性的类型 `interface People { [key: string]: string | number | boolean; }`
+ 说说 TypeScript 中的 never 类型代表什么。


# 前端
+ 网络性能优化: 文件最小化（文件压缩、按需加载、路由懒加载、模块化代码）、CDN、缓存
+ 代码性能优化: 缓存(keep-live、key、shallowref、算法缓存)、虚拟列表、动画效果、代码切片、
+ cookies，sessionStorage 和 localStorage 的区别
+ link和@import有什么区别: `<link>: 引入外部资源，如样式表、字体文件  不会阻塞页面渲染  兼容性良好` `@import: 在 CSS 文件中引入其他样式表  CSS 文件解析时才会加载资源，会阻塞页面的渲染  兼容性较差`
+ HTTP缓存
  - Last-Modified 和 If-Modified-Since：主要依赖于文件的最后修改时间，适合静态文件或者没有实体标签（如哈希值）的资源。
  - ETag 和 If-None-Match：通过唯一的实体标签（ETag），可以更精确地判断资源的变化，适合于动态生成的内容或者需要精确验证的场景。
  - Cache-Control : `Cache-Control: max-age=3600`
  - 资源未更新: HTTP/1.1 304 Not Modified
# 强缓存和协商缓存
## 强缓存
强缓存指的是在浏览器请求资源时，直接从浏览器缓存中获取数据，不需要与服务器进行任何交互，避免了重复的网络请求，从而提高页面加载速度, 通过HTTP头部的Cache-Control和Expires来设置资源在浏览器缓存中的过期时间，避免重复请求资源。适用于不频繁变化的资源。
## 协商缓存
通过Last-Modified/ETag与If-Modified-Since/If-None-Match来和服务器协商是否需要重新下载资源，适用于可能会更新的资源。

+ websocket：单个 TCP 连接上进行全双工通信的协议
+ 跨域: 同源策略是浏览器的安全机制，它限制了来自不同源的脚本如何与页面进行交互，以防止潜在的安全风险。
  - 协议号-域名-端口 都相同的地址，浏览器才认为是同源， 这意味着，如果一个网页包含的脚本试图跨域请求其他源的资源，浏览器会阻止这个请求。
  - 设置响应头、后端代理、jsonp
- 服务器通过设置 HTTP 头来明确允许哪些域访问资源`Access-Control-Allow-Origin` `Access-Control-Allow-Methods` 
+ DOM 操作
+ 那些操作会造成内存泄漏: 忘记释放动态分配的内存、循环引用、未正确关闭资源（事件监听器）、全局变量的滥用、缓存使用不当、
+ 如何解决内存泄漏:
  - 未使用var、let或const声明变量，使变量被意外地声明为全局变量，从而无法被垃圾回收机制回收
  - 闭包中的变量引用外部作用域中的变量，导致外部变量无法被回收。
  - 在JavaScript中持有对DOM元素的引用，导致这些元素无法被垃圾回收。
  - 使用clearInterval或clearTimeout清除定时器，并确保回调函数中未持有对不必要的外部变量的引用
  - 内存中的对象积累，特别是在没有适当的清理机制时。
  - 事件监听器未能正确移除，导致其引用的对象无法被回收
+ 事件循环
+ 前端安全相关
  - XSS（跨站脚本攻击）：攻击者将恶意脚本代码注入到正常的网页中。从而获取用户的敏感信息、篡改网页内容、进行恶意操作等， `输入验证与过滤` `输出转义` `Cookie 设置为 HttpOnly，防止通过 JavaScript 访问和修改` `配置 CSP 规则`
  - CSRF（跨站请求伪造）: B 页面中包含了对A (已登录)请求。浏览器会自动带上这些凭证执行转账请求 `验证请求来源` `双重认证(二次密码)` `请求唯一token` `SameSite Cookie `
  - SQL 注入: 输入验证
  - HTTPS: 保障前端数据在传输过程中的安全性
+ meta: 可以包含哪些信息，可用于提供 名称 - 值 对形式的文档元数据
  - charset（字符编码）
  - name：author、description、keywords、referrer（控制由当前文档发出的请求的 HTTP Referer 请求头）、theme-color、viewport（为视口的初始大小）、creator、robots（爬虫规则）
  - http-equiv （指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击）
  - content 包含 http-equiv 或 name 属性的值

```html
<meta charset="UTF-8">
<meta name="description" content="这是一个示例网站，提供丰富的学习资源。">
<meta name="keywords" content="示例网站,学习资源,在线课程">
<!-- 页面重定向 -->
<meta http-equiv="refresh" content="5;url=https://www.example.com"> 
<meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate">
<meta name="author" content="张三">
<!-- width=device-width：将网页的宽度设置为设备的屏幕宽度。
initial-scale=1.0：页面首次加载时的缩放比例为 1:1。
minimum-scale=1.0：用户能进行的最小缩放比例为 1:1。
maximum-scale=1.0：用户能进行的最大缩放比例为 1:1。
user-scalable=no：禁止用户对页面进行缩放操作。 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
```
+ Content Security Policy（内容安全策略）: 防止跨站脚本（XSS）和数据注入等。通过发送一个 CSP 头部，告诉浏览器哪些资源是被授权执行的，哪些是需要被禁止的，实质是一种白名单制度。
  - 设置 HTTP 响应头： Content-Security-Policy: policy
  - HTML 标签`<meta>`: `<meta http-equiv="content-security-policy" content="default-src 'elf'; img-src *; child-src 'none';"/>`
+ 列举一些常见的前端加密算法及其应用场景
  - 对称加密：加密和解密使用相同的密钥
  - 非对称加密：加密和解密使用不同的密钥，其中公钥可以公开，私钥需要保密，任何人都可以使用加密密钥(公钥)来加密消息。但是，解密密钥(私钥)是秘密的。这样，只有预期的接收者才能解密该消息。最常见的非对称加密算法是RSA
  - 哈希算法：将任意长度的输入转换为固定长度的输出，
+ 重排（回流）和重绘
+ 重排（回流）（当浏览器计算元素的几何属性（如宽度、高度、位置等）发生改变时，需要重新计算布局），重排是一个比较耗时的操作，会导致浏览器重新计算页面的布局，影响页面的性能。
  - 添加、删除或修改可见的 DOM 元素。
  - 改变元素的尺寸、位置、内容等属性。
  - 改变窗口大小。
  - 改变字体大小
+ 重绘： 当元素的外观属性（如颜色、背景、边框等）发生改变，但不影响布局时，浏览器会重新绘制该元素
  - 改变元素的背景颜色。
  - 改变元素的边框颜色或样式。
  - 改变元素的 visibility 属性
+ 减少重排和重绘的方法
  - 避免频繁操作 DOM
  - 避免频繁读取和修改样式
  - 避免频繁调整窗口大小
  - 使用 CSS3 动画和过渡， 浏览器会对动画和过渡进行优化，使用 GPU 来加速渲染
  - 不要逐个更改单个样式， 通过更改类名，批量更新数据然后渲染 dom
  - 使用 documentFragment 保存临时批量更改：像标准的 document 一样，最大的区别是它不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染
+ 不同标签页通信方式
  - localStorage、IndexDB(同源)
  - BroadcastChannel(同源)
  - 使用postMessage结合window.open或window.opener
  - 后端 API
+ 标记清除算法（Mark and Sweep）：
  - 标记阶段：从根对象（如全局对象、正在执行的函数的局部变量等）开始，遍历所有可达的对象，并为它们打上标记。
  - 清除阶段：遍历整个内存空间，检查每个对象是否被标记。未被标记的对象被认为是不可达的，其占用的内存将被释放。
  - 优点是可以处理循环引用的情况，即两个或多个对象相互引用但没有被其他地方引用时，也能正确回收内存。
+ 引用计数算法（Reference Counting）：
  - 每个对象都有一个引用计数器，当一个对象被引用时，其引用计数器加一；当引用被删除时，引用计数器减一。
  - 当一个对象的引用计数器为零时，该对象所占用的内存可以被回收。
  - 缺点是无法处理循环引用的问题，而且每次引用的变化都需要更新计数器，会带来一定的性能开销。
+ 内存使用注意事项
  - 及时释放不再使用的对象的引用，特别是在事件处理程序、定时器等场景中，防止出现循环引用。
  - 对于不再需要的 DOM 元素，要确保从文档中移除并释放其相关的事件监听器等资源。
  - 避免创建不必要的大型对象或数组，尽量按需分配内存。
  - 当处理大量数据时，可以考虑使用数据结构的优化策略，如使用对象池来重复利用对象，减少内存分配和垃圾回收的次数
+ 跨域解决方案
JSONP: script标签的src属性不受同源策略的限制，并且资源加载完成后会被当作js脚本立即执行
CORS: Access-Control-Allow-Origin, withCredentials
反向代理: nginx
# http
+ HTTP/0.9:
  - 最初版本，只支持GET方法，没有Header等结构。
  - 仅支持HTML文档。
+ HTTP/1.0:
  - 支持多种HTTP方法，如GET、POST、HEAD。
  - 引入了Header字段，允许传递元数据。
  - 每次请求/响应需要建立新的TCP连接，没有持久连接。
  - 不支持请求管道（pipelining）和部分内容传输（range request）。
+ HTTP/1.1:
  - 引入了持久连接（Keep-Alive），允许多个请求/响应在同一个连接上处理，减少了连接建立的开销。
  - 支持请求管道（pipelining），可以同时发送多个请求，提升了性能。
  - 引入了Host头部字段，支持虚拟主机的多个网站共享同一个IP地址。
  - 引入了缓存控制（Cache-Control）等新的头部字段，支持更细粒度的缓存策略。
+ HTTP/2:
  - 引入了二进制协议，数据以二进制格式传输，替代了HTTP/1.x的文本格式，减少了传输的头部数据大小。
  - 多路复用（Multiplexing），允许在同一个连接上并行发送多个请求和响应，解决了队头阻塞问题，提升了性能。
  - 头部压缩（Header Compression），进一步减少了传输的头部数据大小，降低了网络流量。
  - 服务器推送（Server Push），服务器可以在客户端请求之前主动推送资源，加速页面加载。
  - 支持优先级（Priority）和流控制（Flow Control），更精确地管理数据流，提升了传输效率和质量。
+ HTTP/3:
  - 使用QUIC作为传输层协议，基于UDP，集成了TCP和TLS的功能，减少了连接建立和断开的成本，提高了网络传输的效率。
  - 改善了传输性能，降低了延迟，特别适合高延迟和带宽变化的网络环境。
  - 通过快速握手和快速重传等机制增强了安全性和可靠性。
  - 支持多路复用和流量控制，提高了并发传输能力和网络利用率。
+ TCP:（HTTP、HTTPS、FTP、SSH、SMTP） TCP是一种面向连接的协议，提供可靠的数据传输。它通过三次握手建立连接，确保数据的顺序和完整性，并在传输过程中进行错误检测和重传。
  - 适合于对数据可靠性要求较高、对数据顺序要求较高的应用，如文件传输、网络通信等。
+ UDP:（DNS、TFTP） UDP是一种无连接的协议，数据传输不保证可靠性，不进行连接的建立和维护。它仅提供数据的最小封装和转发，不保证数据的到达顺序或完整性。
  - 适合于实时性要求高、对数据完整性要求较低的应用，如音频/视频流传输、在线游戏、实时通信等。
+ TCP vs UDP 比较
  - 可靠性：TCP提供可靠的数据传输，确保数据到达且无差错；UDP则不保证数据的可靠性。
  - 连接性：TCP是面向连接的，通信前需要建立连接；UDP是无连接的，通信时不需要先建立连接。
  - 效率：UDP比TCP更高效，因为它不需要建立连接和维护状态，适合实时数据传输。
  - 应用场景：根据应用需求选择TCP或UDP，如需可靠传输和顺序性选择TCP，如需实时性和效率选择UDP
  - 流量控制和拥塞控制： TCP：具有流量控制和拥塞控制机制，可以根据网络条件调整数据传输速率，避免网络拥堵。UDP：不提供流量控制和拥塞控制机制，发送方的发送速率不会根据网络条件进行调整。
+ Server send events
事件流是一个简单的文本数据流，必须使用 UTF-8 进行编码。事件流中的消息由一对换行符分隔。冒号作为一行的第一个字符本质上是一个注释，会被忽略。
每条消息都包含一行或多行文本，其中列出了该消息的字段(event,data,id,retry)。每个字段都由字段名称表示，后跟冒号，后跟该字段值的文本数据。
```md
<!-- 注释行可用于防止连接超时;服务器可以定期发送 Comment 以保持连接处于活动状态。 -->
: this is a test stream
<!-- event 用于标识所描述的事件的类型。如果指定了此选项，则会在浏览器上将事件调度到指定事件名称的侦听器;网站源代码应使用 addEventListener（） 来侦听命名事件。如果没有为消息指定事件名称，则调用 onmessage 处理程序。 -->
event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

<!-- data 消息的数据字段。当 EventSource 收到多行以 data： 开头的连续行时，它会将它们连接起来，并在每行之间插入换行符。尾随换行符将被删除。 -->
data: Here's a system message of some kind that will get used
data: to accomplish some task.

event: usermessage
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}
```
客户端通过 JavaScript 创建一个EventSource对象，并指定要连接的服务器端 URL。浏览器会与服务器建立一个持久的 HTTP 连接
服务器可以在任何时候通过这个连接向客户端发送数据。数据以文本格式发送，通常采用text/event-stream的 MIME 类型。服务器发送的数据由一系列的消息组成，每个消息由换行符分隔，以data:开头，后面跟着实际的数据内容。

+ WebSocket
+ WebRTC
+ HTTP VS HTTPS
+ 三次握手（建立链接）和四次挥手（断开链接）:（TCP协议保证可靠传输的重要机制，确保了双方都能安全、有序地建立、关闭连接，并释放资源）
+ http 状态码
  - 1xx（信息性状态码）: 100 请求已接受，客户端应继续发送请求的其余部分。 101 服务器已理解请求的方法，即将切换到新的协议
  - 2xx（成功状态码): 200 OK 请求成功, 204 No Content：请求成功，但没有返回任何内容
  - 3xx（重定向状态码）: 301 请求的资源已被永久移动到新位置。 302 请求的资源现在临时从不同的URI响应请求。 304 资源未被修改，可以使用缓存的版本。
  - 4xx（客户端错误状态码）: 400 服务器无法理解请求的语法 401 请求要求用户的身份认证。 403 服务器拒绝请求。 404 请求的资源不存在 405 Method Not Allowed：请求方法不被允许 408 Request Timeout：请求超时
  - 5xx（服务器错误状态码）: 500 : 服务器遇到错误   502  服务器作为网关或代理，从上游服务器收到无效响应  503 服务器目前无法处理请求（过载或维护）。

```shell
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
```

+ 五层网络模型
  - 物理层：定义了物理介质上的数据传输方式，如电缆、光纤等
  - 数据链路层：负责在直接连接的两个设备之间传输数据帧，处理物理层的传输错误。
  - 网络层：处理数据包在网络中的路由和转发，负责确定数据包的最佳路径到达目的地。主要协议包括 IP（Internet Protocol），用于标识网络中的每个设备及其位置。
  - 传输层：提供端到端的数据传输服务，包括数据的分段、流量控制和错误恢复。主要协议有 TCP 和 UDP。
  - 应用层：定义了不同应用程序之间的通信规则和数据交换方式 HTTP HTTPS DNS SSH

+ 浏览器请求全流程
DNS 解析: URL 的域名, 解析成对应的 IP 地址, 检查缓存, DNS 服务器查询
建立 TCP 连接: 通过三次握手完成
HTTPS 加密握手:
  客户端 Hello：浏览器发送支持的加密算法和 TLS 版本。
  服务器 Hello：服务器选择加密算法，并返回自己的数字证书。
  证书验证：客户端验证服务器证书的合法性（由受信任的 CA 签发）。
  生成对称密钥：双方协商生成共享的对称密钥。
  安全通信开始：后续数据使用对称密钥加密传输。
浏览器构造 HTTP 请求，并通过 TCP 连接发送给服务器。请求内容包括：
请求行：
  请求方法：GET、POST、PUT 等。
  请求路径：如 /index.html。
  协议版本：HTTP/1.1 或 HTTP/2。
请求头：
  包含额外的信息，例如：
  Host：目标服务器地址（域名）。
  User-Agent：客户端标识（浏览器信息）。
  Accept：客户端希望接收的数据类型（如 HTML、JSON）。
  Cookie：携带之前存储的用户会话数据。
请求体（仅 POST/PUT 等方法使用）：
  例如，表单数据或 JSON 数据。
服务器接收并处理请求
  权限验证：检查请求是否包含有效的认证信息（如 Token、Session）
  路由处理: 静态资源：直接查找文件系统, 调用服务器程序，生成响应内容
  生成 HTTP 响应：返回状态码、响应头和响应体
浏览器接收并解析响应: HTML(解析 HTML 字符串为 DOM 树), 下载 CSS 文件后，解析为 CSSOM 树, 将 CSSOM 与 DOM 树合并，生成渲染树, 下载并解析 <script> 标签中的 JS 代码。
如果 JS 会修改 DOM 或 CSSOM，重新计算渲染树。
子资源加载: 图片、字体
关闭连接: 浏览器与服务器完成通信后，关闭 TCP 连接（如果未使用 Keep-Alive）。
如果资源设置了缓存策略，浏览器会将资源存储到本地，以便下次加载更快

# jQuery 简化复杂的DOM操作和跨浏览器兼容性问题
+ 选择器引擎
+ DOM操作封装
+ 事件处理
+ 动画效果
+ Ajax请求
+ 动画效果
+ 工具函数
+ 链式调用

# React

## hooks
+ useState: 向组件添加一个 状态变量
+ useEffect
+ useReducer
+ useRef: 改变 ref 不会触发重新渲染
+ useImperativeHandle: 自定义由 ref 暴露出来的句柄
+ useContext: 组件树深层传递数据
+ useMemo: 
+ useCallback
+ useInsertionEffect
+ useLayoutEffect: 在浏览器重新绘制屏幕之前触发
+ useTransition
+ useSyncExternalStore
+ useId
+ useDebugValue
+ useDeferredValue

## 组件
+ Suspense
+ StrictMode
+ Profiler
+ Fragment

## API
+ memo
+ lazy
+ forwardRef: 允许组件使用 ref 将 DOM 节点暴露给父组件
+ createContext: 创建组件能够提供与读取的 上下文

# 设计模式: 计模式是对软件设计中普遍存在的各种问题所提出的解决方案
+ 常用的: `单例模式` `适配器模式` `装饰器模式` `外观模式` `享元模式` `组合模式` `策略模式` `迭代器模式`
+ 创建型模式：用于解决与对象创建情况相关的常见问题
  - 单例模式 (Singleton Pattern)：确保一个类只有一个实例，并提供一个全局访问点。
  - 工厂方法模式 (Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定实例化哪一个类。（如果你只需要创建一类产品的不同变体）
  - 抽象工厂模式 (Abstract Factory Pattern)：提供一个创建一系列相关或依赖对象的接口，而无需指定它们具体的类。（创建多个相关产品的组合（如产品家族））
  - 建造者模式 (Builder Pattern)：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
  - 原型模式 (Prototype Pattern)：通过复制现有实例来创建新的对象，而不是直接实例化类。
+ 结构型模式：何将类和对象组合在一起形成更大的结构，以便获得更大的灵活性和效率
  - 适配器模式 (Adapter Pattern)：将一个类的接口转换成客户期望的另一个接口，使得原本因接口不兼容而不能一起工作的类可以一起工作。
  - 装饰器模式 (Decorator Pattern)：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活。
  - 代理模式 (Proxy Pattern)：为其他对象提供一种代理以控制对这个对象的访问。
  - 外观模式 (Facade Pattern)：为子系统中的一组接口提供一个一致的接口，使得子系统更容易使用。
  - 桥接模式 (Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
  - 组合模式 (Composite Pattern)：将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户对单个对象和组合对象的使用具有一致性。
  - 享元模式 (Flyweight Pattern)：运用共享技术有效地支持大量细粒度的对象。
+ 行为型模式：关注对象之间的相互作用和职责分配。这些模式通过定义类或对象之间的通信方式，帮助程序员构建更清晰和高效的系统。行为型模式通常涉及算法的封装、责任链的建立、对象的协作等。
  - 策略模式 (Strategy Pattern)：定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。
  - 观察者模式 (Observer Pattern)：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。
  - 命令模式 (Command Pattern)：将一个请求封装成一个对象，从而使你可以用不同的请求对客户进行参数化。
  - 状态模式 (State Pattern)：允许对象在内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
  - 责任链模式 (Chain of Responsibility Pattern)：避免请求发送者与多个请求处理者之间的耦合，使多个处理者都有机会处理请求。这些处理者被连接成一条链，并沿着这条链传递请求，直到有一个处理者处理它为止。
  - 解释器模式 (Interpreter Pattern)：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
  - 中介者模式 (Mediator Pattern)：用一个中介对象来封装一系列对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散。
  - 迭代器模式 (Iterator Pattern)：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
  - 模板方法模式 (Template Method Pattern)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
  - 访问者模式 (Visitor Pattern)：表示一个作用于某对象结构中的各元素的操作，使得可以在不改变各元素类的前提下定义作用于这些元素的新操作。

# 设计模式是为了解决什么问题
+ 代码复用: 
  - 经常需要重复实现类似的功能或逻辑，这会导致代码重复，增加维护成本
  - 单例模式: 确保类只有一个实例，并提供全局访问点，避免了重复创建对象的需求
+ 灵活性和扩展性
  - 需求变更时，如果软件设计不够灵活，往往需要修改现有代码，这会增加风险并降低系统的稳定性。
  - 策略模式: 允许在运行时动态选择和切换算法或策略，满足不同需求的变化
+ 复杂性管理
  - 随着系统功能的增加，代码的复杂性也会增加，导致难以理解、维护和扩展。通过将系统划分为多个小的、具有明确职责的组件来管理复杂性。
  - 组合模式: 允许将对象组合成树形结构以表示部分-整体层次结构，简化了复杂结构的处理。
+ 模块解耦
  - 模块之间的强耦合使得系统难以修改和扩展，因为对一个模块的更改可能会影响其他模块。设计模式通过定义清晰的接口和协议来解耦模块之间的依赖。
  - 观察者模式: 允许对象之间以一种松散耦合的方式进行通信和通知，当一个对象的状态改变时，它会通知所有依赖于它的对象。
+ 对象创建
  - 对象的创建过程可能会很复杂，特别是当需要配置对象的多个属性或依赖时, 设计模式提供了灵活的对象创建机制来简化对象的创建过程。
  - 工厂模式: 将对象的创建过程封装在工厂类中，使得客户端代码不需要直接创建对象，从而简化了对象的创建和管理。
+ 封装变化
  - 系统中经常会发生变化，这些变化可能会影响到系统的各个部分，导致系统的不稳定。设计模式通过封装变化来减少影响。
  - 模板方法模式: 定义了算法的骨架，将算法的一些步骤延迟到子类中实现，从而使得算法的变化不会影响到算法的整体结构。
+ 代码一致性和标准化
  - 团队中不同的开发人员可能会用不同的方式解决相同的问题，导致代码风格和结构的不一致。
  - 设计模式提供了标准化的解决方案，使得团队成员能够按照统一的设计原则来实现功能，提高了代码的一致性和可维护性

# 其他
+ Vue Vapor: 不依赖于虚拟 DOM，而是更多地利用 Vue 的内置响应性系统
+ 最新的装饰器语法 
<!-- TODO -->
+ node 原生测试
+ react
+ vite 插件
+ rspack、Vite6(Rolldown)
+ tailwindcss 4.0

# 项目经验
+ SSP(供应方平台)
+ 绩效营销SaaS平台
+ 极海云平台
+ 评估系统（观影、游戏任务、问卷系统）
## 角色权限
+ 角色: 业务经理、UI、Affiliate（联盟成员）、广告主、运营
+ 前端：路由（meta、）、组件
+ 后端：中间件获取角色类型、装饰器注入允许的权限到路由中
## API 设计
+ 授权机制: cookie、jwt、token
+ 命名规范和响应格式、错误码、编写文档
+ 监控 API 的性能、使用情况和错误，以便及时发现和解决问题。
+ 调用频率、IP白名单
## 日志管理
+ 错误拦截器、中间件访问日志
+ 日志收集、分析、存储、展示
## 业务预警
+ 按照小时、天等设置点击量、收入、转化率等设置预警值
+ 定时任务，系统自动发送钉钉、url、短信通知等
## 实时数据分析
+ Kafka、redis、WebSocket 事件
+ 按天、小时计算入库
+ 查询缓存
+ echart（折线图、饼图）、表格(条件、维度、指标)
## 文件上传: 异步调度器、分块上传、断点续传、并行上传、文件 HASH、文件预览(按需加载)
```js
class Scheduler {
    constructor() {
        this.awaitArr = [];
        this.count = 0;
    }
    async add(promiseCreator) {
        if (this.count >= 2) {
            await new Promise(resolve => {
                this.awaitArr.push(resolve);
            });
        }
        this.count++;
        const res = await promiseCreator();
        this.count--;

        if (this.awaitArr.length) {
            this.awaitArr.shift()();
        }
        return res;
    }
}
```
## 数据隔离与安全
+ 单一数据库，共享架构
  - 表中添加一个租户ID（Tenant ID），并在查询时进行过滤，来实现数据隔离。
  - 创建一个中间件来处理每个请求的租户ID。这通常通过请求头中的信息来识别租户。
  - Sequelize 的 scopes 可以用于在模型中预定义查询条件。
+ 其他方案
  - 每个租户使用一个单独的数据库实例。这种方法需要动态创建和管理 Sequelize 实例。
  - 为每个租户创建一个独立的架构（Schema）。每个租户的数据保存在其专属的架构中。

# nginx
+ 如何优化 Nginx 以处理更多的并发请求
  - 增加 worker_processes 和 worker_connections。
  - 使用 keepalive_timeout 减少 TCP 连接开销。
  - 使用 gzip 压缩响应内容。
  - 日志级别优化 延迟、buffer
  - nginx 缓存
  - 负载均衡
  - 合理配置缓冲区大小
  - 简化处理路径，减少资源竞争的可能性
  - Nginx 支持多种事件模型，主要有 epoll、kqueue、eventport 和 select 等，每种模型在不同的操作系统上有不同的支持和表现。
+ 反向代理
+ 正向代理
+ 缓存
+ 负载均衡：轮询、最少链接、IP Hash、权重
+ root 和 alias 区别
  - root：用于设置相对路径，结合 location 的 URI 使用
  - alias：直接使用指定的路径，不结合 location 的 URI。
```shell
upstream backend {
    ip_hash;
    server backend1.example.com;
    server backend2.example.com;
}
```

# node

## 全局变量
+ global
+ __dirname __filename
+ process: 获取环境变量、处理命令行参数、监听进程事件
+ Buffer: 处理二进制数据
+ 一些浏览器全局变量: Fetch、crypto, structuredClone,  setTimeout()、setInterval()、setImmediate()、queueMicrotask

## 
+ stream
+ pipe
+ Node.js 中创建子进程
+ 进程间通信（IPC）在 Node.js 中的实现方式: `child_process: fork、exec、spawn` `worker_threads: parentPort.postMessage、worker.on('message', (msg) => msg)` `文件和数据库`
+ buffer

## 事件循环机制
- 事件循环允许Node.js执行非阻塞 I/O 操作（尽管默认情况下使用单个 JavaScript 线程），方法是尽可能将操作卸载到系统内核。
- 由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会通知Node.js，以便将适当的回调添加到轮询队列中，以便最终执行
+ Node.js 的非阻塞 I/O 模型
  - 当Node.js执行 I/O 操作时，例如从网络读取、访问数据库或文件系统，而不是阻塞线程并浪费 CPU 周期等待，Node.js将在响应返回时恢复操作。
+ nextTick: 事件循环继续进行之前运行其回调
+ setImmediate: 事件循环的下一次迭代或“滴答”时触发

# 查找文件规则

# nestjs 中的依赖注入
https://juejin.cn/post/7049504750257045540
https://www.midwayjs.org/docs/container
# redis
+ 数据结构、用途
  - String（字符串）: 缓存简单的键值对数据，例如：用户会话信息、页面内容缓存
  - Hash（哈希）键值对: 存储对象的属性和字段，例如：用户信息（id, name, email）。
  - List（列表）:使用 LPUSH 和 RPOP 实现简单的队列。
  - Set（集合）: 去重、存储不重复的元素集合，例如：标签、用户角色。
  - Sorted Set（有序集合）: 实现排行榜功能，例如：按得分排序的游戏排行榜。
  - HyperLogLog
  - Bitmaps
  - Geospatial index（地理空间索引）: 存储地理位置数据，进行地理位置范围查询。
+ 消息队列
+ 持久化

# Kafka
<!-- TODO -->
# 敏捷开发

+ 需求规划
+ 迭代计划
+ 测试计划
+ 缺陷跟踪
+ 任务看板
+ 甘特图
+ 工时管理
+ 流程自动化
+ 故事墙
+ 代码集成
+ 统计分析

# 持续集成和持续部署（CI/CD

+ GitHub Actions

```yml
name: Update AWS Node Service with Tests
on:
  push:
    branches:
      - main
jobs:
  test-and-update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test

      - name: Install AWS CLI
        run: sudo apt-get update && sudo apt-get install -y awscli

      - name: Configure AWS credentials
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID && aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY

      - name: SSH into AWS server and update Node service
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          ssh -i $SSH_PRIVATE_KEY $SSH_USERNAME@$SERVER_IP "
            # 这里编写在服务器上更新 Node 服务的具体命令
          "
```
+ GitHub Actions &  AWS CodeBuild 
  - 在 AWS 中设置 CodeBuild 项目： 创建一个 CodeBuild 项目，并配置构建环境、源代码位置（例如来自 GitHub 仓库）、构建命令等
  - 在 GitHub 中创建 Actions 工作流：在您的 GitHub 仓库的 .github/workflows 目录下创建一个 YAML 文件，例如 codebuild.yml 
  - 在 GitHub Actions 工作流中触发 AWS CodeBuild：您可以使用 AWS 的 API 或者 AWS 提供的工具来从 GitHub Actions 中触发 CodeBuild 项目的构建。

```yml
name: Trigger AWS CodeBuild
on:
  push:
    branches:
      - main
jobs:
  trigger-codebuild:
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    steps:
      - name: Trigger AWS CodeBuild
        uses: aws-actions/aws-codebuild-start-build@v1
        with:
          project-name: 'YourCodeBuildProjectName'
          environment-variables-override: |
            {
              "ENV_VAR1": "value1",
              "ENV_VAR2": "value2"
            }
```

+ Jenkins
  - 配置源代码管理，如 Git 仓库的 URL 和认证信息。
  - 设置构建触发器，例如定时构建、代码提交触发等。
  - 定义构建步骤，例如执行 Shell 脚本、调用 Maven 构建、运行测试等。
  - 配置构建后的操作，如发送邮件通知、部署到服务器等

# eslint

+ flat config <https://eslint.org/docs/latest/extend/plugin-migration-flat-config>
- 平面配置默认值
- 配置文件

# vite ｜ rollup 插件

+ https://www.rollupjs.com/plugin-development/#plugins-overview

+ https://vite.dev/guide/api-plugin.html#plugin-api
<!-- TODO -->
# DevOPS

+ Project
+ GitHub Actions 使自动化软件交付过程变得容易。开发人员可以创建工作流来自动构建、测试和部署他们的软件

# 原子化 CSS
它将 CSS 样式拆分成最小的、独立的原子类，每个类只负责一个特定的样式属性
+ 优点
  - 避免样式冲突（可维护性）：原子化 CSS 的类更容易维护和修改，因为它们都是独立的，不会影响其他类的样式
  - 方便修改：如果需要修改某个样式属性，只需要在一个地方进行修改即可
  - 快速开发（减少代码重复）：由于原子类已经预先定义好了各种样式属性，开发人员可以直接使用这些类来快速构建页面
  - 减少 CSS 文件大小：原子化 CSS 只包含最小的样式属性，所以生成的 CSS 文件通常比传统的 CSS 文件更小
  - 提高浏览器渲染性能
+ 缺点
  - 类名冗长
  - 缺乏可读性（对于不熟悉的人）

# Vite vite.config.js

- 自动导入文件
- 选项：基础（）、开发服务器选项（端口、proxy、）
- 插件

# webpack

# git
配置 Git
```shell
git config --global user.name "Your Name"
git config --global user.email "your_email@example.com"

#查看当前配置
git config --list
```
创建/克隆仓库
```shell
git init
git clone <repository_url>
```
查看状态/记录
```shell
# 查看当前工作区状态
git status

# 查看提交历史
git log
```
分支操作
```shell
# 查看所有分支
git branch -a

# 创建新分支
git branch <branch_name>

# 切换分支
git checkout <branch_name>
git switch <branch_name>

# 创建并切换到新分支
git checkout -b <branch_name>
git switch -c <branch_name>

# 删除本地分支
git branch -d <branch_name>

# 合并分支
git merge <branch_name>
```
提交修改
```shell
# 添加文件到暂存区
git add <file_name>       # 添加单个文件
git add .                 # 添加所有文件
git commit -m "描述信息"   #提交修改
git commit -a -m "描述信息" #跳过暂存区直接提交
```
远程操作
```shell
git remote -v #查看远程仓库
git remote add origin <repository_url> #添加远程仓库
git push origin <branch_name> #推送本地分支到远程
git pull origin <branch_name> #拉取远程分支
git clone --recursive <repository_url> #克隆远程仓库
```

撤销修改
```shell
git checkout -- <file_name> #撤销未暂存的修改
git reset HEAD <file_name> #撤销暂存区的修改
git reset --hard HEAD #重置到上一次提交
```
标签操作
```shell
git tag <tag_name> 创建标签
```
排查问题
```shell
git diff #查看改动差异
git show <commit_hash> #查看某次提交的具体改动
git log -p <file_name> #查看文件的历史修改记录
```

其他常用命令
```shell
git stash #暂存当前工作状态
git stash apply #恢复暂存的工作状态
```

## 常用命令

### 多人协同开发

# 装饰器
主要用于在不修改原有代码的情况下为对象添加额外的行为和功能，
+ `代码复用`: 可以将一些通用的功能封装在装饰器中，然后应用到多个不同的类、方法或属性上。比如日志记录、性能监测、权限控制等功能可以通过装饰器轻松地添加到多个地方，避免重复编写相同的代码。
+ `分离关注点`: 把与业务逻辑无关的横切关注点（如日志、安全检查等）从业务代码中分离出来，让业务代码更加专注于实现核心业务逻辑。
+ `增强对象功能`: 可以在不改变原有对象结构的情况下，为对象添加新的方法或属性，或者修改现有方法的行为。

```ts
function logMethod(target, key, descriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function (...args) {
    console.log(`Calling method ${key} with arguments ${JSON.stringify(args)}`);
    const result = originalMethod.apply(this, args);
    console.log(`Method ${key} returned ${result}`);
    return result;
  };
  return descriptor;
}

class MyClass {
  @logMethod
  myMethod(arg1, arg2) {
    return arg1 + arg2;
  }
}

const instance = new MyClass();
instance.myMethod(2, 3);
```

# App 混合开发

## WebView 
App将定义好的原生接口注入到 WebView 中，使得 WebView 中的 JavaScript 可以访问这些接口

# 数据结构
## 线性结构
+ 数组
  - 存储在连续的内存空间中，可以通过索引快速访问元素，
  - 适合存储一组具有相同类型的数据，例如存储一组整数或字符串。可用于实现简单的排序算法，如冒泡排序、插入排序等，在这些算法中，数组可以方便地进行元素的比较和交换
+ 链表
  - 由一系列节点组成，每个节点包含数据和指向下一个节点的指针。
  - 适合频繁进行插入和删除操作的场景。例如，在实现栈和队列时，可以使用链表来存储元素，使得入栈和出栈、入队和出队操作更加高效。在一些动态内存分配的场景中，链表也很有用，比如操作系统中的内存管理可能会使用链表来跟踪空闲内存块
+ 栈
  - 后进先出, 只能在栈顶进行插入和删除操作。可以用数组或链表实, 常用于函数调用、表达式求值、浏览器历史记录等
+ 队列
  - 先进先出, 只能在队尾插入元素，在队头删除元素。可以用数组或链表实现, 常用于任务调度、消息队列、广度优先搜索算法等，如操作系统中的进程调度、网络通信中的数据包处理
## 树结构
+ 二叉树
  - 每个节点最多有两个子节点，分为左子节点和右子节点
  - 广泛应用于搜索和排序算法中。例如，二叉搜索树可以快速地进行插入、删除和查找操作，时间复杂度为 O (log n)
+ 堆
## 图结构
+ 邻接矩阵
  - 对于一个有 n 个顶点的图，可以用一个 n×n 的矩阵来表示。如果顶点 i 和顶点 j 之间有边相连，那么矩阵中第 i 行第 j 列的元素为 1（或边的权重），否则为 0
  - 优点是可以快速判断两个顶点之间是否有边相连，时间复杂度为 O (1)。缺点是对于稀疏图（边的数量相对较少的图），会浪费大量的存储空间
+ 邻接表
  - 对于每个顶点，用一个链表或数组来存储与其相邻的顶点。
  - 优点是对于稀疏图可以节省存储空间。缺点是判断两个顶点之间是否有边相连的时间复杂度相对较高，可能需要遍历链表或数组。
## 集合与映射结构
+ 哈希表
  - 通过哈希函数将键映射到内存中的某个位置，从而快速地进行插入、删除和查找操作
  - 在需要快速查找和存储键值对的场景中非常有用。例如，在统计单词出现次数的问题中，可以使用哈希表来存储单词和其出现的次数，快速地进行统计和查询
+ 集合
  - 存储一组不重复的元素
  - 用于去除重复元素、判断元素是否存在等场景

# 算法
+ 排序: 冒泡、快排、归并
  - 冒泡: 相邻元素比较，交换位置
  - 快排: 选择一个基准元素，将数组分为两部分，一部分小于基准，一部分大于基准，递归处理
  - 归并: 分治思想，将数组分为两部分，分别排序，然后合并
+ 二叉树: 广度、深度
  - 广度: 队列
  - 深度: 递归、栈
+ 链表: 反转、合并
+ 动态规划(如计算斐波那契): 将问题分解为子问题，存储子问题的结果，避免重复计算
+ 递归: 函数的定义中使用函数自身的方法, 将一个大问题逐步分解为规模更小的相同问题，直到达到基础情况，然后从最底层开始逐步返回结果，最终解决整个大问题
 - 通过函数调用栈来实现。每次调用函数时，系统会将当前函数的上下文（包括局部变量、参数等）压入栈中，当函数返回时再从栈中弹出。如果递归层次过深，可能会导致栈溢出错误
 - 代码通常更简洁、清晰，更符合某些问题的自然逻辑，尤其是在处理树形结构、分治问题等方面
 - 由于存在大量的函数调用和栈操作，在一些情况下可能会导致性能开销较大，执行效率相对较低
+ 迭代: 使用循环结构（如 for 循环、while 循环）来重复执行一段代码，通过不断更新变量的值，在每次循环中逐步逼近问题的解，直到满足特定的结束条件为止
  - 使用循环结构来实现，在循环体内通过更新变量的值来控制循环的执行次数和过程，不会产生额外的函数调用栈开销，相对来说更节省内存空间
  - 代码相对来说可能会更复杂一些，需要手动管理循环变量和循环条件，但它的执行过程更直观，更容易理解和调试
  - 通常执行效率较高，因为它避免了函数调用的开销，直接在循环中进行计算和操作

# Webpack

## 开发框架(React、Taro、React Native、Flutter、Electron、Uniapp、Tauri)
