<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=theme-color content="#ffffff"><meta name=color-scheme content="light dark"><meta name=description content="前后端通过HTTP请求穿参的几种方式：
URL传参(params) 我们可以通过?开头并用&符号分隔的键 - 值对，同时以 &lsquo;=&rsquo; 分隔键和值的URL, 如http://127.0.0.1:3000?key1=value1&key2=value2来提供额外参数。为了构造查询字符串，我们可以使用URLSearchParams
// Pass in a searc new URLSearchParams(`key1=value1&key2=value2`); // Pass in a sequence new URLSearchParams([[&#34;key1&#34;, &#34;value1&#34;],[&#34;key2&#34;, &#34;value2&#34;]]); // Pass in a record new URLSearchParams({&#34;key1&#34; : &#34;value1&#34;, &#34;key2&#34; : &#34;value2&#34;}); // 通过URL传入的参数都会被隐式地转译为`字符串`, 如果保护有特殊字符将被转译,非字母或数字的字符会被 percent-encoding<https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding>, 相当于调用encodeURIComponent<https://www.rfc-editor.org/rfc/rfc3986#section-1.2.1>, 对于转译后的字符串我们可以用decodeURIComponent解码 new URLSearchParams({&#34;key1&#34; : [1,2,3]}) // key1=1%2C2%2C3 即 key1=1,2,3 new URLSearchParams({&#34;key1&#34; : { age: 18 }}) // key1=%5Bobject+Object%5D 即 key1=[object+Object] 如果我们希望传递嵌套的对象可以通过前后端约定一种序列化参数的编码解码方案，如qs
// 在前端对参数编码 Qs.stringify({{&#34;key1&#34; : { age: 18 }}}) // key1%5Bage%5D=18 即 key1[age]=18 // 在后端调用对应的解码函数 Qs."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="HTTP请求传参的几种方式"><meta name=twitter:description content="前后端通过HTTP请求穿参的几种方式：
URL传参(params) 我们可以通过?开头并用&符号分隔的键 - 值对，同时以 &lsquo;=&rsquo; 分隔键和值的URL, 如http://127.0.0.1:3000?key1=value1&key2=value2来提供额外参数。为了构造查询字符串，我们可以使用URLSearchParams
// Pass in a searc new URLSearchParams(`key1=value1&key2=value2`); // Pass in a sequence new URLSearchParams([[&#34;key1&#34;, &#34;value1&#34;],[&#34;key2&#34;, &#34;value2&#34;]]); // Pass in a record new URLSearchParams({&#34;key1&#34; : &#34;value1&#34;, &#34;key2&#34; : &#34;value2&#34;}); // 通过URL传入的参数都会被隐式地转译为`字符串`, 如果保护有特殊字符将被转译,非字母或数字的字符会被 percent-encoding<https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding>, 相当于调用encodeURIComponent<https://www.rfc-editor.org/rfc/rfc3986#section-1.2.1>, 对于转译后的字符串我们可以用decodeURIComponent解码 new URLSearchParams({&#34;key1&#34; : [1,2,3]}) // key1=1%2C2%2C3 即 key1=1,2,3 new URLSearchParams({&#34;key1&#34; : { age: 18 }}) // key1=%5Bobject+Object%5D 即 key1=[object+Object] 如果我们希望传递嵌套的对象可以通过前后端约定一种序列化参数的编码解码方案，如qs
// 在前端对参数编码 Qs.stringify({{&#34;key1&#34; : { age: 18 }}}) // key1%5Bage%5D=18 即 key1[age]=18 // 在后端调用对应的解码函数 Qs."><meta property="og:title" content="HTTP请求传参的几种方式"><meta property="og:description" content="前后端通过HTTP请求穿参的几种方式：
URL传参(params) 我们可以通过?开头并用&符号分隔的键 - 值对，同时以 &lsquo;=&rsquo; 分隔键和值的URL, 如http://127.0.0.1:3000?key1=value1&key2=value2来提供额外参数。为了构造查询字符串，我们可以使用URLSearchParams
// Pass in a searc new URLSearchParams(`key1=value1&key2=value2`); // Pass in a sequence new URLSearchParams([[&#34;key1&#34;, &#34;value1&#34;],[&#34;key2&#34;, &#34;value2&#34;]]); // Pass in a record new URLSearchParams({&#34;key1&#34; : &#34;value1&#34;, &#34;key2&#34; : &#34;value2&#34;}); // 通过URL传入的参数都会被隐式地转译为`字符串`, 如果保护有特殊字符将被转译,非字母或数字的字符会被 percent-encoding<https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding>, 相当于调用encodeURIComponent<https://www.rfc-editor.org/rfc/rfc3986#section-1.2.1>, 对于转译后的字符串我们可以用decodeURIComponent解码 new URLSearchParams({&#34;key1&#34; : [1,2,3]}) // key1=1%2C2%2C3 即 key1=1,2,3 new URLSearchParams({&#34;key1&#34; : { age: 18 }}) // key1=%5Bobject+Object%5D 即 key1=[object+Object] 如果我们希望传递嵌套的对象可以通过前后端约定一种序列化参数的编码解码方案，如qs
// 在前端对参数编码 Qs.stringify({{&#34;key1&#34; : { age: 18 }}}) // key1%5Bage%5D=18 即 key1[age]=18 // 在后端调用对应的解码函数 Qs."><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/web/http%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"><meta property="article:section" content="web"><meta property="article:published_time" content="2022-08-15T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-15T00:00:00+00:00"><title>HTTP请求传参的几种方式 · CK's Blog</title><link rel=canonical href=https://chenkai.life/web/http%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.56610f8c63ea4ca06cdac03f4fafe3e818c64566f988301b72895eb047082c51.css integrity="sha256-VmEPjGPqTKBs2sA/T6/j6BjGRWb5iDAbcolesEcILFE=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/favicon.ico><link rel=apple-touch-icon type=image/png sizes=256x256 href=/images/favicon-512x512.png><meta name=generator content="Hugo 0.101.0"><link rel=manifest href=/manifest.webmanifest></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><details id=table-of-contents-wapper><summary><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></summary></details><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/marks/>Marks</a></li><li class=navigation-item><a class=navigation-link href=https://github.com/ckvv/ckvv.github.io/new/main/content>Create</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=github>GitHub</button>
<button class=search-btn data-type=google>Google</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/web/http%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/>HTTP请求传参的几种方式</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title rel=noopener target=_blank href=https://github.com/ckvv/ckvv.github.io/edit/main/content/web/HTTP%e8%af%b7%e6%b1%82%e4%bc%a0%e5%8f%82%e7%9a%84%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2022-08-15T00:00:00Z>2022-08-15</time></span></div></div><p>前后端通过<a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP>HTTP</a>请求穿参的几种方式：</p><h2 id=url传参params>URL传参(params)
<a class=heading-link href=#url%e4%bc%a0%e5%8f%82params><i class="fa fa-link" aria-hidden=true></i></a></h2><p>我们可以通过<code>?</code>开头并用<code>&</code>符号分隔的键 - 值对，同时以 &lsquo;=&rsquo; 分隔键和值的URL, 如<code>http://127.0.0.1:3000?key1=value1&key2=value2</code>来提供额外参数。为了构造查询字符串，我们可以使用<a href=https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams>URLSearchParams</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// Pass in a searc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>URLSearchParams</span>(<span style=color:#e6db74>`key1=value1&amp;key2=value2`</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Pass in a sequence
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>URLSearchParams</span>([[<span style=color:#e6db74>&#34;key1&#34;</span>, <span style=color:#e6db74>&#34;value1&#34;</span>],[<span style=color:#e6db74>&#34;key2&#34;</span>, <span style=color:#e6db74>&#34;value2&#34;</span>]]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Pass in a record
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>URLSearchParams</span>({<span style=color:#e6db74>&#34;key1&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;value1&#34;</span>, <span style=color:#e6db74>&#34;key2&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;value2&#34;</span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 通过URL传入的参数都会被隐式地转译为`字符串`, 如果保护有特殊字符将被转译,非字母或数字的字符会被 percent-encoding&lt;https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding&gt;, 相当于调用encodeURIComponent&lt;https://www.rfc-editor.org/rfc/rfc3986#section-1.2.1&gt;, 对于转译后的字符串我们可以用decodeURIComponent解码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>URLSearchParams</span>({<span style=color:#e6db74>&#34;key1&#34;</span> <span style=color:#f92672>:</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]}) <span style=color:#75715e>// key1=1%2C2%2C3 即 key1=1,2,3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>URLSearchParams</span>({<span style=color:#e6db74>&#34;key1&#34;</span> <span style=color:#f92672>:</span> { <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>18</span> }}) <span style=color:#75715e>// key1=%5Bobject+Object%5D 即 key1=[object+Object]
</span></span></span></code></pre></div><p>如果我们希望传递嵌套的对象可以通过前后端约定一种序列化参数的编码解码方案，如<a href=https://www.npmjs.com/package/qs>qs</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// 在前端对参数编码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Qs</span>.<span style=color:#a6e22e>stringify</span>({{<span style=color:#e6db74>&#34;key1&#34;</span> <span style=color:#f92672>:</span> { <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>18</span> }}}) <span style=color:#75715e>// key1%5Bage%5D=18 即 key1[age]=18
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 在后端调用对应的解码函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Qs</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#e6db74>`key1%5Bage%5D=18`</span>) <span style=color:#75715e>// {&#34;key1&#34;:{&#34;age&#34;:&#34;18&#34;}}
</span></span></span></code></pre></div><h3 id=设置url参数的例子>设置URL参数的例子
<a class=heading-link href=#%e8%ae%be%e7%bd%aeurl%e5%8f%82%e6%95%b0%e7%9a%84%e4%be%8b%e5%ad%90><i class="fa fa-link" aria-hidden=true></i></a></h3><p>通过<code>axios</code>设置URL参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>instance</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>axios</span>.<span style=color:#a6e22e>create</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>paramsSerializer</span>(<span style=color:#a6e22e>params</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Qs</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>params</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 或者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>axios</span>(<span style=color:#e6db74>`http://127.0.0.1:3000?</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>Qs</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>params</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
</span></span></code></pre></div><p>通过<code>fetch</code>设置URL参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>`http://127.0.0.1:3000?</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>Qs</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>params</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
</span></span></code></pre></div><h2 id=header传参>header传参
<a class=heading-link href=#header%e4%bc%a0%e5%8f%82><i class="fa fa-link" aria-hidden=true></i></a></h2><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers>Headers</a>允许客户端和服务器通过<code>request</code>和<code>response</code>传递附加信息，主要用来描述资源或服务器或客户端的行为.</p><p>我们可以通过以下方式构造<code>Headers</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>headers</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Headers</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>headers</span>.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#39;Content-Type&#39;</span>, <span style=color:#e6db74>&#39;application/json&#39;</span>);
</span></span></code></pre></div><h3 id=例子>例子
<a class=heading-link href=#%e4%be%8b%e5%ad%90><i class="fa fa-link" aria-hidden=true></i></a></h3><p>通过<code>axios</code>设置<code>Headers</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>instance</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>axios</span>.<span style=color:#a6e22e>create</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;X-Requested-With&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;XMLHttpRequest&#39;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>paramsSerializer</span>(<span style=color:#a6e22e>params</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Qs</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>params</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 或者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>axios</span>.<span style=color:#a6e22e>defaults</span>.<span style=color:#a6e22e>headers</span>.<span style=color:#a6e22e>common</span>[<span style=color:#e6db74>&#39;Authorization&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>AUTH_TOKEN</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>axios</span>.<span style=color:#a6e22e>defaults</span>.<span style=color:#a6e22e>headers</span>.<span style=color:#a6e22e>post</span>[<span style=color:#e6db74>&#39;Content-Type&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;application/x-www-form-urlencoded&#39;</span>;
</span></span></code></pre></div><p>通过<code>fetch</code>设置<code>Headers</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;input&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;X-Requested-With&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;XMLHttpRequest&#39;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=body传参>Body传参
<a class=heading-link href=#body%e4%bc%a0%e5%8f%82><i class="fa fa-link" aria-hidden=true></i></a></h2><p><a href=https://greenbytes.de/tech/webdav/draft-ietf-httpbis-p1-messaging-26.html#rfc.section.3.3>Body</a>用于携带该请求或响应的有效负载正文。可以传递任何参数</p><h3 id=form-data>form-data
<a class=heading-link href=#form-data><i class="fa fa-link" aria-hidden=true></i></a></h3><h3 id=applicationx-www-form-urlencoded>application/x-www-form-urlencoded
<a class=heading-link href=#applicationx-www-form-urlencoded><i class="fa fa-link" aria-hidden=true></i></a></h3><h3 id=raw>raw
<a class=heading-link href=#raw><i class="fa fa-link" aria-hidden=true></i></a></h3><p>text/plain
application/json
text/html
application/xml
application/javascript</p><h3 id=binary>binary
<a class=heading-link href=#binary><i class="fa fa-link" aria-hidden=true></i></a></h3><div id=cusdis_thread data-host=https://cusdis.com data-app-id=c2b015f9-9a4b-4997-b66f-f9c6ca26ebdd data-page-id=c77b7411eb674a19e4d5638bf9c519c5 data-page-url=https://chenkai.life/web/http%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/ data-page-title=HTTP请求传参的几种方式 data-iframe=/js/cusdis/iframe.umd.js data-style=/js/cusdis/style.css></div></article></section></div></main><script src=/js/coder.min.cb0c595e02234420f3ad3886bf4a9bd2874d0e1e78e090138a9ef158b35aaf17.js integrity="sha256-ywxZXgIjRCDzrTiGv0qb0odNDh544JATip7xWLNarxc="></script>
<script src=/js/custom.js></script>
<script src=/js/font.min.js></script></body><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></html>