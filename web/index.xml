<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Webs on CK's Blog</title><link>https://chenkai.life/web/</link><description>Recent content in Webs on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 01 Sep 2021 17:13:52 +0800</lastBuildDate><atom:link href="https://chenkai.life/web/index.xml" rel="self" type="application/rss+xml"/><item><title>浏览器中获取宽、高相关的属性</title><link>https://chenkai.life/web/get-width-and-height-attributes-in-the-browser/</link><pubDate>Wed, 01 Sep 2021 17:13:52 +0800</pubDate><guid>https://chenkai.life/web/get-width-and-height-attributes-in-the-browser/</guid><description>我们可能需要针对宽屏和高屏编写不同代码，下面我总结一下从浏览器中获取宽、高相关的属性
css 如果宽高屏不设计具体逻辑代码，我们可以采用css的@media媒体查询的方式判断;
orientation 宽度和高度相等时会被判断为纵向
/* viewport 处于纵向，即高度大于等于宽度 */ @media (orientation: portrait) { } /* viewport 处于横向，即宽度大于高度。 */ @media (orientation: landscape) { } aspect-ratio 利用宽高比我们也可以判断宽高屏，当如果同时满足后面的样式会覆盖前面，所以下面当宽高相等时生效的是@media (aspect-ratio: 1/1) {}
/* 最大宽高比 */ @media (max-aspect-ratio: 1/1){ } /* 最小宽高比 */ @media (min-aspect-ratio: 1/1) { } /* 指定宽高比 */ @media (aspect-ratio: 1/1) { } js window innerHeight innerWidth outerHeight outerWidth 获取浏览器窗口的视口（viewport）高度、宽度（以像素为单位）</description></item><item><title>浅谈css动画</title><link>https://chenkai.life/web/css-animation/</link><pubDate>Wed, 18 Aug 2021 11:31:16 +0800</pubDate><guid>https://chenkai.life/web/css-animation/</guid><description>本文简单介绍如何定义css动画
transition transitions 可以决定哪些属性发生动画效果transition-property (明确地列出这些属性,如果省略则包含所有属性)，何时开始 transition-delay (设置 delay），持续多久transition-duration (设置 duration) 以及如何动画transition-timing-function (定义timing function，比如匀速地或先快后慢)
如下面指定字体大小颜色和字体发生动画效果
.transition-box{ font-size: 1rem; color: red; transition: color 2s, font-size 2s; } transition的发生需要属性被修改时才会触发，比如hover时我们修改字体大小和颜色，如果没有定义transition这些属性会立即修改，
.transition-box:hover { font-size: 2rem; color: green; } .transition-box{ font-size: 1rem; color: red; transition: color 2s, font-size 2s; } .transition-box:hover { font-size: 3rem; color: green; } 把鼠标放上查看效果 CSS 过渡 由简写属性transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间。
也可以用下面子属性来控制过渡的各部分
transition-property: color, font-size; transition-duration: 4s; transition-timing-function: ease; transition-delay: 0s; transition的特点 只能在css属性变化时被动触发</description></item><item><title>谈谈Web项目中图标的方式</title><link>https://chenkai.life/web/use_icon_in_web/</link><pubDate>Sat, 14 Aug 2021 10:25:11 +0800</pubDate><guid>https://chenkai.life/web/use_icon_in_web/</guid><description>谈谈Web项目中图标的方式
单个图标 我们可以选择单独引用图标文件如png、svg等等，这种方式缺点显而易见，图标多了之后不方便维护
字体文件 通过font-face,我们可以指定一个用于显示文本的自定义字体，字体文件内部类似一个svg我们可以在字体文件里面随便定义这些字符的形状，
通过对应字体文件的字体编码我们就可以使用这些图标了,如下面是一个close图标
&amp;lt;i class=&amp;#34;iconfont&amp;#34;&amp;gt;&amp;amp;#xe64f;&amp;lt;/i&amp;gt; 这样有个明显的缺点就是图标不直观，我们很难根据&amp;amp;#x33;知道它是什么图标，我们可以通过提前定义好对应图标css的::before的content，将其改造成自定义class引用的方式
.icon-close:before{ content: &amp;#34;\e64f&amp;#34; } 然后我们在页面中可以这样使用
&amp;lt;span class=&amp;#34;iconfont icon-close&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 因为是字体格式所以这种方式使用图标有以下特点
兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 不支持多色。 symbol 引用 symbol 元素用来定义一个图形模板对象，它可以用一个use元素实例化。一个symbol元素本身是不呈现的。只有symbol元素的实例（亦即，一个引用了symbol的 use元素）才能呈现，如
&amp;lt;svg&amp;gt; &amp;lt;!-- symbol definition NEVER draw --&amp;gt; &amp;lt;symbol id=&amp;#34;sym01&amp;#34; viewBox=&amp;#34;0 0 150 110&amp;#34;&amp;gt; &amp;lt;circle cx=&amp;#34;50&amp;#34; cy=&amp;#34;50&amp;#34; r=&amp;#34;40&amp;#34; stroke-width=&amp;#34;8&amp;#34; stroke=&amp;#34;red&amp;#34; fill=&amp;#34;red&amp;#34; /&amp;gt; &amp;lt;circle cx=&amp;#34;90&amp;#34; cy=&amp;#34;60&amp;#34; r=&amp;#34;40&amp;#34; stroke-width=&amp;#34;8&amp;#34; stroke=&amp;#34;green&amp;#34; fill=&amp;#34;white&amp;#34; /&amp;gt; &amp;lt;/symbol&amp;gt; &amp;lt;!-- actual drawing by &amp;#34;use&amp;#34; element --&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;0&amp;#34; width=&amp;#34;100&amp;#34; height=&amp;#34;50&amp;#34; /&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;50&amp;#34; width=&amp;#34;75&amp;#34; height=&amp;#34;38&amp;#34; /&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;100&amp;#34; width=&amp;#34;50&amp;#34; height=&amp;#34;25&amp;#34; /&amp;gt; &amp;lt;/svg&amp;gt; symbol的作用域是全局的我们也可以在svg中单独使用如</description></item><item><title>常用的一些css样式</title><link>https://chenkai.life/web/css_useful_style/</link><pubDate>Fri, 06 Aug 2021 15:06:32 +0800</pubDate><guid>https://chenkai.life/web/css_useful_style/</guid><description>字体 文字超出后省略
white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 中文简&amp;gt;繁转换
font-variant-east-asian: traditional;</description></item><item><title>css元素选择器</title><link>https://chenkai.life/web/css_select/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/css_select/</guid><description>CSS 选择器规定了 CSS 规则会应用到哪些元素上。
基本选择器 节点选择 CSS 类型选择器按节点名称匹配元素。换句话说，它选择文档中给定类型的所有元素。
/* All &amp;lt;a&amp;gt; elements. */ a { color: red; } 类选择 该CSS 类选择匹配根据他们的内容元素class属性。
/* All elements with class=&amp;#34;spacious&amp;#34; */ .spacious { margin: 2em; } /* All &amp;lt;li&amp;gt; elements with class=&amp;#34;spacious&amp;#34; */ li.spacious { margin: 2em; } /* All &amp;lt;li&amp;gt; elements with a class list that includes both &amp;#34;spacious&amp;#34; and &amp;#34;elegant&amp;#34; */ /* For example, class=&amp;#34;elegant retro spacious&amp;#34; */ li.</description></item><item><title>css关于浮动的知识</title><link>https://chenkai.life/web/css_float/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/css_float/</guid><description>float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。 当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。
float原始用法 float本意是为了允许文本和内联元素环它如（文字环绕图片）,就像下面一样
.float { float: left; width: 200px; height: 200px; background-color: red; } &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;float&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; float本意是为了允许文本和内联元素环它; float本意是为了允许文本和内联元素环它; float本意是为了允许文本和内联元素环它; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 滥用float 带来的问题 我们使用float浮动做了很多其本职工作以外的事情，使用float进行分栏布局、列表排列，但是如果一个元素里只有浮动元素，那它的高度会是0。如果你想要它自适应即包含所有浮动元素，那你需要清除它的子元素。
清除浮动的几种办法 ::after伪元素 这种方式不会影响任何其他样式，通用性强，覆盖面广，推荐使用
#container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } 类似的可以在元素后面加一个&amp;lt;div style=&amp;quot;clear:both;&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;空元素
其他清除浮动方法 IE下清除浮动准则很简单，使元素haslayout就可以了。如宽度值，高度值，绝对定位，zoom，浮动本身都可以让元素haslayout。显然，首选zoom:1;不会干扰任何样式。非IE浏览器常用的是overflow属性
container也浮动,这种方式治标不治本总不能一直浮动到root
#container{ float:left; } 使用position: absolute</description></item><item><title>DOM中的event</title><link>https://chenkai.life/web/dom_event/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/dom_event/</guid><description>event Event 接口表示在 DOM 中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由 API 生成（例如指示动画已经完成运行的事件，视频已被暂停等等。事件通常由外部源触发，同样也会以编程方式触发，例如执行一个 element 的一个 HTMLElement.click( ) 方法，或通过定义事件，然后使用 EventTarget.dispatchEvent() 将其派发到一个指定的目标。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。 事件处理函数可以附加在各种对象上，包括 DOM元素,window,document对象. 等
有三种方式可以为DOM元素注册事件处理函数
EventTarget.addEventListener // Assuming myButton is a button element myButton.addEventListener(&amp;#39;click&amp;#39;, function(){alert(&amp;#39;Hello world&amp;#39;);}, false); HTML 属性 &amp;lt;button onclick=&amp;#34;alert(&amp;#39;Hello world!&amp;#39;)&amp;#34;&amp;gt; DOM 元素属性 该函数在定义时，可以传入一个 event 形式的参数。 在HTML 规范中，其返回值会以一种特殊的方式被处理。
// Assuming myButton is a button element myButton.onclick = function(event){alert('Hello world');}; 创建自定义事件 可以使用事件构造函数创建事件
var event = new Event(&amp;#39;build&amp;#39;); let eventEle = document.</description></item><item><title>Flex弹性布局</title><link>https://chenkai.life/web/css_flex/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/css_flex/</guid><description>&lt;h2 id="弹性布局">
弹性布局
&lt;a class="heading-link" href="#%e5%bc%b9%e6%80%a7%e5%b8%83%e5%b1%80">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="一弹性布局是什么">
一.弹性布局是什么？
&lt;a class="heading-link" href="#%e4%b8%80%e5%bc%b9%e6%80%a7%e5%b8%83%e5%b1%80%e6%98%af%e4%bb%80%e4%b9%88">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>任何一个容器都可以指定为 Flex 布局&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-css" data-lang="css">.&lt;span style="color:#a6e22e">box&lt;/span>{
&lt;span style="color:#66d9ef">display&lt;/span>: &lt;span style="color:#66d9ef">flex&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>行内元素也可以使用 Flex 布局。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-css" data-lang="css">.&lt;span style="color:#a6e22e">box&lt;/span>{
&lt;span style="color:#66d9ef">display&lt;/span>: &lt;span style="color:#66d9ef">inline&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#66d9ef">flex&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>vue_nextTick的原理</title><link>https://chenkai.life/web/vue_nexttick/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/vue_nexttick/</guid><description>nextTick是vue的一个全局API， 作用是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
const callbacks = [] let pending = false function flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &amp;lt; copies.length; i++) { copies[i]() } } // Here we have async deferring wrappers using microtasks. // In 2.</description></item><item><title>vue实践</title><link>https://chenkai.life/web/vue_guide/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/vue_guide/</guid><description>参考vue风格指南 参考vue编程指南
Vue Router 路由懒加载 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载
规范 vue文件内css样式尽量使用局部样式。全局样式可以统一放入静态库由app.vue文件导入
注意事项 vue data中的对象状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新
最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, 'newProp', 123), 或者 以新对象替换老对象。例如，利用对象展开运算符我们可以这样写： state.obj = { ...state.obj, newProp: 123 }</description></item><item><title>vue样式dev和build下不一致</title><link>https://chenkai.life/web/vue_page_style_dev_build_different/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/vue_page_style_dev_build_different/</guid><description>一次更新镜像后发现vue项目页面混乱，在开发模式模式下，写的样式有效，打包后无效
一、多个相同样式文件同时存在项目中 现象：修改组件时，在项目中复制了一个组件重命名后进行修改，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：在本地试图修改总是不见效果，在控制台查看样式仍是之前的样式，把其中一处样式在所有相关组件中修改，打包上传后样式生效，这说明是旧的样式在打包时覆盖了新的样式。将旧组件删除后解决上述问题。 原因猜测：因为相同组件包含不同样式时，无法判断哪份样式时在后面渲染，如果旧样式刚好打包后在后面渲染，则会覆盖掉新写的样式。在本地执行时，因为样式没有打包，访问页面时渲染的都是组件自身样式，所以不会出现上述问题。
二、全局(main.js)引用样式 现象：在全局引入了Element UI 样式，在header组件中修改部分样式，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：因为在项目中段发现该问题，以为是后续的样式造成的影响(虽然我也认为可能性极小)，删除新写的组件，没有效果。运行一段时间之前的代码，项目正常运行，这迫使我回想中间这段时间对项目做了什么？除了新写了一些组件，还将一些配置信息从index.js中转移到了main.js中，测试发现果然是这里出现了问题。配置中同时出现了Element UI 样式文件引用，还有router的引用，将yang样式引用放在router引用后解决问题。 原因猜测：不正常的样式显示的还是组件原始的样式，由此猜测router加载时会加载组件样式，将样式文件在router后引用会将router加载时渲染的样式覆盖掉，所以建议将router的引用放在最后面。在每个组件的样式中记得添加 ‘scoped’.
import &amp;#39;element-ui/lib/theme-chalk/index.css&amp;#39; //element样式文件 import App from &amp;#39;./App&amp;#39; 如果相反，那么element-ui的样式会覆盖自定义的样式，所以会出现你修改的样式不生效问题！！</description></item><item><title>vue项目添加单元测试</title><link>https://chenkai.life/web/vue_test/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/vue_test/</guid><description>创建vue的单元测试项目
vue-cli 创建项目 vue create vue-test Vue CLI 3可以向项目组中直接添加unit-jest vue add @vue/unit-jest 可以发现项目中多了很多文件，并且已经创建了一个测试文件demo，
进行测试 vue在添加单元测试框架时会在package.jsonscripts添加一个test:unit，我们可以允许此命令打开测试
在vue版本过低的项目中添加单元测试 我们可以选择以下两种方式
升级vue版本及其依赖 vue版本如果太旧的不支持此种方式直接添加单元测试,可以选择更新vue版本2.5以上，并更新其依赖库。 此种方法可能会出现浏览器报exportes错误，把.babelrc文件transform-runtime删除即可。
采用旧版本方式 Note: This example is outdated. It&amp;rsquo;s now recommended to scaffold your project with Vue CLI 3 which provides out-of-the-box configurations for unit testing.
vue-test-utils-jest-example Example project using Jest + vue-test-utils together</description></item><item><title>WebWorker</title><link>https://chenkai.life/web/web-worker/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/web-worker/</guid><description>一、概述 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。
Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。
Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。
Web Worker 有以下几个使用注意点。
（1）同源限制
分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。
（2）DOM 限制
Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。
（3）通信联系
Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
（4）脚本限制
Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。
（5）文件限制
Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。
二、基本用法 2.1 主线程 主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。
var worker = new Worker(&amp;#39;work.js&amp;#39;); Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</description></item><item><title>手机web端调试</title><link>https://chenkai.life/web/web_phone_debug_/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/web_phone_debug_/</guid><description>最近使用vue开发的一个应用，在部分手机页面中会出现时而正常时而异常的问题，由手机中调试不如桌面那么方便，想着在网上找找有没有现成的解决方案，大体分三种,下面大概介绍下
捕获错误日志将日志发送到服务器查看 前端应用通过window.onerror事件捕获错误或者重写console方法，将日志通过请求发送到后端应用
捕获错误日志把日志在前端应用查看 如腾讯的vConsole，该插件会在页面右下角插入一个按钮，点击可以打开一个类似调试页面的窗口。
主要包括以下功能:
查看 console 日志 查看网络请求 查看页面 element 结构 查看 Cookies、localStorage 和 SessionStorage 手动执行 JS 命令行 自定义插件 使用方法如下：
import VConsole from &amp;#34;vconsole&amp;#34;; new VConsole(); 通过某些特殊应用调试 如使用谷歌浏览器的开发者工具远程调试Android和iOS页面，手机和电脑使用usb连接，手机要开启usb调试模式，在电脑端浏览器输入chrome://inspect会打开设备监视页面，这里可以监视到iOS和Android设备</description></item><item><title>拷贝数据到剪贴板</title><link>https://chenkai.life/web/brower_copy_to_clipboard/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/brower_copy_to_clipboard/</guid><description>介绍几种在浏览器中拷贝数据到剪贴板的方法
document.execCommand(&amp;ldquo;copy&amp;rdquo;); 拷贝当前选中内容到剪贴板, 该api已经废弃不推荐使用，
function fallbackCopyTextToClipboard(text) { const textArea = document.createElement(&amp;#34;textarea&amp;#34;); textArea.value = text; textArea.style.top = &amp;#34;0&amp;#34;; textArea.style.left = &amp;#34;0&amp;#34;; textArea.style.position = &amp;#34;fixed&amp;#34;; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { let msg = document.execCommand(&amp;#34;copy&amp;#34;); if (!msg) { throw new Error(&amp;#34;Copy filed&amp;#34;); } } finally { document.body.removeChild(textArea); } } navigator.clipboard 剪贴板 Clipboard API 提供了响应剪贴板命令（剪切、复制和粘贴）与异步读写系统剪贴板的能力。从权限 Permissions API 获取权限之后，才能访问剪贴板内容；如果用户没有授予权限，则不允许读取或更改剪贴板内容。该 API 被设计用来取代使用 document.execCommand() 的剪贴板访问方式。(基于 HTTP 的网站中包含的脚本则不能获得剪贴板对象)
await navigator.clipboard.writeText(data); npm package clipboard, 内部使用的 document.</description></item><item><title>浏览器处理cookie</title><link>https://chenkai.life/web/cookie/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/cookie/</guid><description>设置cookie function setCookie(options) { const { name, data } = options; const age = options.age || 24 * 3600000; const domain = options.domain || window.location.hostname; document.cookie = `${name}=${data}; path=/; max-age=${age}; domain=${domain}`; } 获取cookie function getCookie(cookie_name) { let value = null; let allcookies = document.cookie; let cookie_pos = allcookies.indexOf(cookie_name); if (cookie_pos != -1) { cookie_pos = cookie_pos + cookie_name.length + 1; let cookie_end = allcookies.indexOf(&amp;#34;;&amp;#34;, cookie_pos); if (cookie_end == -1) { cookie_end = allcookies.</description></item><item><title>浏览器如何渲染页面</title><link>https://chenkai.life/web/how_brower_render_page/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/how_brower_render_page/</guid><description>参考https://coolshell.cn/articles/9666.html
文章是为了说明浏览器如何将HTML，CSS和JavaScript转换为网站。
首先 浏览器是一个可以从远程服务器或者本地磁盘将文件加载、显示、交互的软件。
浏览器有两个重要部分：
渲染引擎（Rendering Engine）：一般习惯称为“浏览器内核”，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同如Gecko（火狐）、Blink（Chrome）、Webkit（Safari）、Trident（IE）等，因此同一网页在不同的内核的浏览器里的渲染效果也可能不同。
JavaScript引擎：JavaScript由ECMAScript，DOM和BOM三者组成，不同浏览器针对JavaScript语法和语义标准有多种实现如：
Chrome使用V8引擎， Safari使用JavaScriptCore， Firefox使用SpiderMonkey 浏览器接收数据 数据是通过Internet以数据包（Packet）为单位按字节形式发送到浏览器。浏览器将从硬盘（或网络）中读取HTML的原始数据字节转换为字符。
从原始字节到DOM 当浏览器接受到扩展名为.html时，会将该文件解释为html对其进行解析，文件中的每个开始和结束html标签会转换为节点如
&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; 创建这些节点后，然后将这些节点链接到称为DOM的树数据结构中。DOM建立父子关系，相邻的兄弟关系等。每个节点之间的关系都在此DOM对象中建立。浏览器必须先将html数据的原始字节转换为DOM，然后才能进行任何操作。
当浏览器接收数据的原始字节并启动DOM构造过程时，它还将发出请求以获取链接的样式表。 一旦浏览器开始解析html，一旦找到文件的link标签，浏览器css就会同时发出获取请求的请求。
从原始字节到CSSOM 当浏览器收到CSS的原始字节时，也会启动HTML原始字节的类似过程。将数据的原始字节转换为字符，然后标记化节点，最后还形成CSS树结构，称为CSS对象模型，简称CSSOM。 CSS有一个叫做Cascade的东西。级联是浏览器如何确定将哪些样式应用于元素的方式。
由于影响元素的样式可能来自父元素（即通过继承），或者已设置在元素本身上，因此CSSOM树结构变得很重要。浏览器必须递归地遍历CSS树结构并确定影响特定元素的样式。
渲染树 DOM和CSSOM树结构是两个独立的结构。DOM包含有关页面HTML元素的关系的所有信息，而CSSOM包含有关元素样式的信息。浏览器现在将DOM和CSSOM树合并为一个称为渲染树(render tree)的东西。渲染树包含有关页面上所有可见DOM内容的信息，以及不同节点所需的所有CSSOM信息。
如果一个元素被CSS隐藏，display; none例如使用，则该节点将不会在渲染树中表示。隐藏的元素将出现在DOM中，但不会出现在渲染树中。原因是渲染树结合了来自DOM和CSSOM的信息，因此它知道在树中不包括隐藏元素。
构建了渲染树后，浏览器将继续进行下一步，即 布局！
现在，我们在屏幕上拥有所有可见内容的内容和样式信息，但实际上并没有在屏幕上呈现任何内容,浏览器必须计算页面上每个对象的确切大小和位置。此布局步骤对从DOM和CSSOM接收到的内容和样式，进行了必要的布局计算，并绘制到屏幕上。DOM和CSSOM必须在成功绘制之前构建，所以优化网站的第一条规则是尽快将最重要的HTML和CSS交付给客户端。
JavaScript JavaScript可以更改DOM和CSSOM。
###Javascript执行前将停止整个DOM构造过程
由于浏览器不确定此特定Javascript会做什么，因此通过停止整个DOM结构来采取预防措施。每当浏览器遇到script标签时，在脚本完成执行之前，将停止整个DOM构造过程。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Medium Article Demo&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;style.</description></item></channel></rss>