<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Csses on CK's Blog</title><link>https://chenkai.life/css/</link><description>Recent content in Csses on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 22 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://chenkai.life/css/index.xml" rel="self" type="application/rss+xml"/><item><title>CSS颜色</title><link>https://chenkai.life/css/css-color/</link><pubDate>Wed, 22 Mar 2023 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-color/</guid><description>记录一下CSS颜色的相关概念
alpha alpha 表示可以在某种程度上看到背景的颜色，不透明度可以被认为是一种后处理操作。从概念上讲，在元素（包括其后代）渲染成 RGBA 离屏图像后，不透明度设置指定如何将离屏渲染混合到当前合成渲染中。
颜色格式 CSS 提供了几种直接指定sRGB颜色的方法
color keyword CSS 定义了一大组命名颜色，以便可以更轻松地编写和阅读常用颜色。
red, blue, green 等等
LinkText, transparent(透明的黑色), currentColor（代表同一元素上的颜色）
rgb（red blue green） 通过调节红、绿、蓝三原色的亮度和色彩来表示颜色。在RGB模型中，每种颜色的取值范围为0-255。
RGB十六进制表示 将通道作为十六进制数字来指定 sRGB 颜色，其值由 3、4、6 或 8 个十六进制数字组
六位#00ff00，每两位代表一个通道，其中00表示最小值，ff（十进制为 255）表示最大值。即rgb(0 255 0) 八位#00ff00cc，最后一对数字表示alpha 即rgb(0 0 100% / 80%) 三位#Of0 等于 #00ff00 四位#0f0c等于 #00ff00cc 优点
兼容性好 缺点
人类难以直观地判断颜色。例如，很难说出如何改变 RGB 颜色以产生相同色调的较亮变体 hsl (Hue Saturation Lightness) 模型是一种圆锥模型，通过色调、饱和度和亮度三个参数来描述颜色。在HSL模型中，色相的取值范围为0-360度，饱和度和亮度的取值范围为0-100%。 如: hsl(50 80% 40%) hsl(50 80% 40% / 25%)
优点
直观，人们可以猜测他们想要的颜色，然后进行调整。 缺点</description></item><item><title>与滚动条相关的属性</title><link>https://chenkai.life/css/scrollbars/</link><pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/scrollbars/</guid><description>滚动条设置（overflow） 设置当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。 可选值: visible, hidden, scroll, auto, overlay
特别的: overlay: 行为与auto相同，但滚动条绘制在内容之上而不是占用空间。仅在基于 WebKit（例如，Safari）和基于 Blink 的（例如，Chrome 或 Opera）浏览器中受支持。
滚动行为（scroll-behavior） 为一个滚动框指定滚动行为
auto: 立即滚动 smoot: 平滑滚动 滚动条样式（伪类选择器） 通过下面几个伪类选择器可以设置滚动条样式
::-webkit-scrollbar——整个滚动条。 ::-webkit-scrollbar-thumb——滚动条上的滚动滑块。 ::-webkit-scrollbar-track——滚动条轨道。 ::-webkit-scrollbar-track-piece——滚动条没有滑块的轨道部分。 ::-webkit-scrollbar-corner——当同时有垂直滚动条和水平滚动条时交汇的部分。通常是浏览器窗口的右下角。 ::-webkit-scrollbar-button——滚动条上两端的按钮（上下箭头）。 ::-webkit-resizer——出现在某些元素底角的可拖动调整大小的滑块。 可用的属性
width: 滚动条宽度 height: 滚动条高度 background-color: 滚动条背景色 border: 滚动条边框 border-radius: 滚动条圆角 例子 &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; div::-webkit-scrollbar { width: 17px; height: 17px; } div::-webkit-scrollbar-button { display: block; width: 17px; height: 17px; } div::-webkit-scrollbar-button:decrement:start { background-color: lightblue; border: 2px solid black; } div::-webkit-scrollbar-button:increment:start { background-color: lightgreen; border: 2px solid black; } div::-webkit-scrollbar-button:decrement:end { background-color: orange; border: 2px solid black; } div::-webkit-scrollbar-button:increment:end { background-color: brown; border: 2px solid black; } div::-webkit-scrollbar-thumb { max-width: 10px; max-height: 10px; background-color: red; border: 2px solid #cccccc; } div::-webkit-scrollbar-track-piece:decrement { background-color: olive; } div::-webkit-scrollbar-track-piece:increment { background-color: pink; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;width:200px; height:200px; overflow-y:scroll; overflow-x:hidden&amp;#34;&amp;gt; Hello&amp;lt;br&amp;gt; Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt; Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt; Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt; &amp;lt;span style=&amp;#34;white-space:nowrap&amp;#34;&amp;gt;Hello world this is a long string and will not wrap.</description></item><item><title>CSS实现字体阴影效果</title><link>https://chenkai.life/css/font-shadow/</link><pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/font-shadow/</guid><description>shadow 对于阴影我们一般可以设置以下几种效果
水平偏移：正值向右偏移阴影，而负值向左偏移。 垂直偏移：正值向上偏移阴影，而负值向下偏移。 模糊半径：阴影的长度。长度越长，阴影就越大越轻。没有负值。 传播半径：这是另一个长度值，较大的值会导致更大、更长的阴影。 颜色：这定义了阴影的颜色，就像我们为 CSS 颜色属性所做的那样。 inset：默认值（初始）会产生阴影。使用 inset 值移动元素框架内的阴影，从而产生内部阴影（只有box-shadow支持） box-shadow 一般来说，提到实现阴影效果，我们首先想到的是box-shadow，但是这个属性只能用在盒模型上，为了显示立体感如弹框、按钮等。
&amp;lt;p style=&amp;#34;box-shadow: 0 0 10px red;&amp;#34;&amp;gt;HelloWorld&amp;lt;/p&amp;gt; HelloWorld
text-shadow 与box-shadow不同的是，text-shadow只能用在文本上
&amp;lt;p style=&amp;#34;font-size: 2em;text-shadow: 0 0 0.4em red;&amp;#34;&amp;gt;HelloWorld&amp;lt;/p&amp;gt; HelloWorld
阴影越大越淡，我们可以通过叠加多个shadow加深阴影颜色
&amp;lt;p style=&amp;#34;font-size: 2em;text-shadow: 0 0 0.4em red, 0 0 0.4em red, 0 0 0.4em red&amp;#34;&amp;gt;HelloWorld&amp;lt;/p&amp;gt; HelloWorld
drop-shadow 与box-shadow类似
&amp;lt;p style=&amp;#34;font-size: 2em;filter:drop-shadow(0 0 0.4em red);&amp;#34;&amp;gt;HelloWorld&amp;lt;/p&amp;gt; HelloWorld
阴影越大越淡，与box-shadow不同的是,随着叠加drop-shadow它的范围会逐渐变大
&amp;lt;p style=&amp;#34;font-size: 2em;filter:drop-shadow(0 0 0.4em red) drop-shadow(0 0 0.4em red) drop-shadow(0 0 0.</description></item><item><title>css元素选择器</title><link>https://chenkai.life/css/css-select/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-select/</guid><description>CSS 选择器规定了 CSS 规则会应用到哪些元素上。
基本选择器 节点选择 CSS 类型选择器按节点名称匹配元素。换句话说，它选择文档中给定类型的所有元素。
/* All &amp;lt;a&amp;gt; elements. */ a { color: red; } 类选择 该 CSS 类选择匹配根据他们的内容元素 class 属性。
/* All elements with class=&amp;#34;spacious&amp;#34; */ .spacious { margin: 2em; } /* All &amp;lt;li&amp;gt; elements with class=&amp;#34;spacious&amp;#34; */ li.spacious { margin: 2em; } /* All &amp;lt;li&amp;gt; elements with a class list that includes both &amp;#34;spacious&amp;#34; and &amp;#34;elegant&amp;#34; */ /* For example, class=&amp;#34;elegant retro spacious&amp;#34; */ li.spacious.elegant { margin: 2em; } ID 选择 CSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素</description></item><item><title>css关于浮动的知识</title><link>https://chenkai.life/css/css-float/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-float/</guid><description>float CSS 属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。 当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。
float 原始用法 float 本意是为了允许文本和内联元素环它如（文字环绕图片）,就像下面一样
.float { float: left; width: 200px; height: 200px; background-color: red; } &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;float&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; float本意是为了允许文本和内联元素环它; float本意是为了允许文本和内联元素环它; float本意是为了允许文本和内联元素环它; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 滥用 float 带来的问题 我们使用 float 浮动做了很多其本职工作以外的事情，使用 float 进行分栏布局、列表排列，但是如果一个元素里只有浮动元素，那它的高度会是 0。如果你想要它自适应即包含所有浮动元素，那你需要清除它的子元素。
清除浮动的几种办法 ::after 伪元素 这种方式不会影响任何其他样式，通用性强，覆盖面广，推荐使用
#container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } 类似的可以在元素后面加一个&amp;lt;div style=&amp;quot;clear:both;&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;空元素
其他清除浮动方法 IE 下清除浮动准则很简单，使元素 haslayout 就可以了。如宽度值，高度值，绝对定位，zoom，浮动本身都可以让元素 haslayout。显然，首选 zoom:1;不会干扰任何样式。非 IE 浏览器常用的是 overflow 属性
container 也浮动,这种方式治标不治本总不能一直浮动到 root
#container { float: left; } 使用 position: absolute</description></item><item><title>常用的一些css样式</title><link>https://chenkai.life/css/css-useful-style/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-useful-style/</guid><description> 字体 文字超出后省略
white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 中文简&amp;gt;繁转换
font-variant-east-asian: traditional;</description></item><item><title>浅谈CSS动画</title><link>https://chenkai.life/css/css-animation/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-animation/</guid><description>本文简单介绍如何定义 css 动画
transition transitions 可以决定哪些属性发生动画效果transition-property (明确地列出这些属性,如果省略则包含所有属性)，何时开始transition-delay (设置 delay），持续多久transition-duration (设置 duration) 以及如何动画transition-timing-function (定义timing function，比如匀速地或先快后慢)
如下面指定字体大小颜色和字体发生动画效果
.transition-box{ font-size: 1rem; color: red; transition: color 2s, font-size 2s; } transition 的发生需要属性被修改时才会触发，比如 hover 时我们修改字体大小和颜色，如果没有定义 transition 这些属性会立即修改，
.transition-box:hover { font-size: 2rem; color: green; } 把鼠标放上查看效果 CSS 过渡 由简写属性transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间。
也可以用下面子属性来控制过渡的各部分
transition-property: color, font-size; transition-duration: 4s; transition-timing-function: ease; transition-delay: 0s; transition 的特点 只能在 css 属性变化时被动触发
transition 是一次性的，不能重复发生，除非一再触发
transition 只能定义开始状态和结束状态，不能定义中间状态
animation animation 属性用来指定一组或多组动画，每组之间用逗号相隔,是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。</description></item><item><title>组件间样式隔离的几种方案</title><link>https://chenkai.life/css/css-web-compoent-isolation/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-web-compoent-isolation/</guid><description>CSS 即层叠样式表(Cascading Style Sheets）是一种样式表语言，它没有作用域的概念，引入即全局生效的，但一个样式是否起作用由多个因素共同决定，比如：
重要程度 优先级 样式加载顺序 所以当我们在页面中使用时可能会遇到组件间的样式互相影响的情况，特别是引入了多个组件库或者类名命名不规范时，我们就需要对样式进行隔离，这样就可以避免样式冲突。下面我介绍几种方案： 类名添加特定的前缀 一般来说，我们会在组件内部使用一个特定的前缀，避免组件之间的样式冲突。比如 antd 的组件内部的样式，都会使用ant-前缀，element-ui 的组件内部的样式，都会使用el-前缀。 由于原生 css 的功能太弱鸡了, 我们在实际开发中一般使用 css 预处理框架如 less, sass 等，对于这种我们也可以使用一个类似的功能。
对于 less // button.less @name: v-; .@{name}button { background-color: green; } // 编译为 // .v-button { // background-color: green; // } 重写前缀
@import &amp;#34;button.less&amp;#34;; @name: k-; // 编译为 // .k-button { // background-color: green; // } 对于 sass sass 目前版本支持与 less 类似的写法，但是 Sass 团队不鼓励继续使用@import规则。 并计划在未来几年逐步淘汰它，作为替代方案，他们推荐使用@use规则。详细原因请参考https://sass-lang.com/documentation/at-rules/import。
/* button.scss */ $name: v-; @mixin configure($name: $name) { @if $name { $name: $name !</description></item></channel></rss>