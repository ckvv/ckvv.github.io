<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=theme-color content="#ffffff"><meta name=color-scheme content="light dark"><meta name=description content="在React中，如果在编写函数组件并需要向其添加一些 state，以前的做法是必须将其它转化为 class。通过一个实例化的class，保存组件的state等状态，对于每一次更新只需要调用render方法就可以。但是 Class组件在变得复杂之后会变得难以维护。
在function组件中，没有一个状态去保存这些信息，每一次函数上下文执行，所有变量，常量都重新声明，执行完毕，再被垃圾机制回收。为了保存一些状态,执行一些副作用钩子,React 16.8新增了React Hooks，去帮助记录组件的状态，处理一些额外的副作用。通过React Hook 可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。你可以在现有的函数组件中使用 Hook，所以通常来说hook使得在组件之间复用状态逻辑变得方便、更容易实现代码的关注点分离。
Hooks的原理 React 保持对当前渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。
每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 useState() 调用会得到各自独立的本地 state 的原因。
// 每次执行一个`hooks`函数，都产生一个`hook`对象，里面保存了当前`hook`信息, // 然后将每个`hooks`以链表形式串联起来，并赋值给`workInProgress`的`memoizedState`。 // 也就证实了上述所说的，函数组件用`memoizedState`存放`hooks`链表。 function mountWorkInProgressHook(): Hook { const hook: Hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // This is the first hook in the list currentlyRenderingFiber."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="React Hooks 基础"><meta name=twitter:description content="在React中，如果在编写函数组件并需要向其添加一些 state，以前的做法是必须将其它转化为 class。通过一个实例化的class，保存组件的state等状态，对于每一次更新只需要调用render方法就可以。但是 Class组件在变得复杂之后会变得难以维护。
在function组件中，没有一个状态去保存这些信息，每一次函数上下文执行，所有变量，常量都重新声明，执行完毕，再被垃圾机制回收。为了保存一些状态,执行一些副作用钩子,React 16.8新增了React Hooks，去帮助记录组件的状态，处理一些额外的副作用。通过React Hook 可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。你可以在现有的函数组件中使用 Hook，所以通常来说hook使得在组件之间复用状态逻辑变得方便、更容易实现代码的关注点分离。
Hooks的原理 React 保持对当前渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。
每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 useState() 调用会得到各自独立的本地 state 的原因。
// 每次执行一个`hooks`函数，都产生一个`hook`对象，里面保存了当前`hook`信息, // 然后将每个`hooks`以链表形式串联起来，并赋值给`workInProgress`的`memoizedState`。 // 也就证实了上述所说的，函数组件用`memoizedState`存放`hooks`链表。 function mountWorkInProgressHook(): Hook { const hook: Hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // This is the first hook in the list currentlyRenderingFiber."><meta property="og:title" content="React Hooks 基础"><meta property="og:description" content="在React中，如果在编写函数组件并需要向其添加一些 state，以前的做法是必须将其它转化为 class。通过一个实例化的class，保存组件的state等状态，对于每一次更新只需要调用render方法就可以。但是 Class组件在变得复杂之后会变得难以维护。
在function组件中，没有一个状态去保存这些信息，每一次函数上下文执行，所有变量，常量都重新声明，执行完毕，再被垃圾机制回收。为了保存一些状态,执行一些副作用钩子,React 16.8新增了React Hooks，去帮助记录组件的状态，处理一些额外的副作用。通过React Hook 可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。你可以在现有的函数组件中使用 Hook，所以通常来说hook使得在组件之间复用状态逻辑变得方便、更容易实现代码的关注点分离。
Hooks的原理 React 保持对当前渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。
每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 useState() 调用会得到各自独立的本地 state 的原因。
// 每次执行一个`hooks`函数，都产生一个`hook`对象，里面保存了当前`hook`信息, // 然后将每个`hooks`以链表形式串联起来，并赋值给`workInProgress`的`memoizedState`。 // 也就证实了上述所说的，函数组件用`memoizedState`存放`hooks`链表。 function mountWorkInProgressHook(): Hook { const hook: Hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // This is the first hook in the list currentlyRenderingFiber."><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/react/react-hooks/"><meta property="article:section" content="react"><meta property="article:published_time" content="2022-02-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-25T10:14:16+08:00"><title>React Hooks 基础 · CK's Blog</title><link rel=canonical href=https://chenkai.life/react/react-hooks/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.d12542c00c198b6a07ca9ea5981102805aecab0f5dfd5e3273d8c179088712c4.css integrity="sha256-0SVCwAwZi2oHyp6lmBECgFrsqw9d/V4yc9jBeQiHEsQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/favicon.ico><link rel=apple-touch-icon type=image/png sizes=256x256 href=/images/favicon-512x512.png><meta name=generator content="Hugo 0.119.0"><link rel=manifest href=/manifest.webmanifest></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><details id=table-of-contents-wapper><summary><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></summary></details><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/marks/>Marks</a></li><li class=navigation-item><a class=navigation-link href=https://github.com/ckvv/ckvv.github.io/tree/main/content>Create</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=github>GitHub</button>
<button class=search-btn data-type=google>Google</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/react/react-hooks/>React Hooks 基础</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title rel=noopener target=_blank href=https://github.com/ckvv/ckvv.github.io/edit/main/content/react/react-hooks.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2022-02-21T00:00:00Z>2022-02-21</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/react/>React</a></span></div></div><p>在React中，如果在编写函数组件并需要向其添加一些 state，以前的做法是必须将其它转化为 class。通过一个实例化的<code>class</code>，保存组件的<code>state</code>等状态，对于每一次更新只需要调用<code>render</code>方法就可以。但是 <a href=https://reactjs.org/docs/react-component.html>Class组件</a>在变得复杂之后会变得难以维护。</p><p>在<code>function</code>组件中，没有一个状态去保存这些信息，每一次函数上下文执行，所有变量，常量都重新声明，执行完毕，再被垃圾机制回收。为了保存一些状态,执行一些副作用钩子,React 16.8新增了<code>React Hooks</code>，去帮助记录组件的状态，处理一些额外的副作用。通过<code>React Hook</code> 可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 React 特性。</p><p>Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，<code>useState</code> 是允许你在 React 函数组件中添加 state 的 Hook。你可以在现有的函数组件中使用 Hook，所以通常来说<code>hook</code>使得在组件之间复用状态逻辑变得方便、更容易实现代码的关注点分离。</p><h2 id=hooks的原理>Hooks的原理
<a class=heading-link href=#hooks%e7%9a%84%e5%8e%9f%e7%90%86><i class="fa fa-link" aria-hidden=true></i></a></h2><p>React 保持对当前渲染中的组件的追踪。多亏了 <a href=https://zh-hans.reactjs.org/docs/hooks-rules.html>Hook 规范</a>，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。</p><p>每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 <code>useState()</code> 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 <code>useState()</code> 调用会得到各自独立的本地 state 的原因。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// 每次执行一个`hooks`函数，都产生一个`hook`对象，里面保存了当前`hook`信息,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 然后将每个`hooks`以链表形式串联起来，并赋值给`workInProgress`的`memoizedState`。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 也就证实了上述所说的，函数组件用`memoizedState`存放`hooks`链表。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mountWorkInProgressHook</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Hook</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hook</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Hook</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memoizedState</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>baseState</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>baseQueue</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>next</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>workInProgressHook</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This is the first hook in the list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>currentlyRenderingFiber</span>.<span style=color:#a6e22e>memoizedState</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>workInProgressHook</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>hook</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Append to the end of the list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>workInProgressHook</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>workInProgressHook</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>hook</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>workInProgressHook</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所以一旦在条件语句中声明<code>hooks</code>，在下一次函数组件更新，<code>hooks</code>链表结构，将会被破坏，<code>current</code>树的<code>memoizedState</code>缓存<code>hooks</code>信息，和当前<code>workInProgress</code>不一致，如果涉及到读取<code>state</code>等操作，就会发生异常</p><h2 id=hooks的使用限制>Hooks的使用限制
<a class=heading-link href=#hooks%e7%9a%84%e4%bd%bf%e7%94%a8%e9%99%90%e5%88%b6><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=只在最顶层使用-hook>只在最顶层使用 Hook
<a class=heading-link href=#%e5%8f%aa%e5%9c%a8%e6%9c%80%e9%a1%b6%e5%b1%82%e4%bd%bf%e7%94%a8-hook><i class="fa fa-link" aria-hidden=true></i></a></h3><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。参考<code>Hooks的原理</code></p><blockquote><p>如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的<em>内部</em>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>useEffect</span>(<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>persistForm</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 👍 将条件判断放置在 effect 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>name</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>localStorage</span>.<span style=color:#a6e22e>setItem</span>(<span style=color:#e6db74>&#39;formData&#39;</span>, <span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div></blockquote><h3 id=只在-react-函数中调用-hook>只在 React 函数中调用 Hook
<a class=heading-link href=#%e5%8f%aa%e5%9c%a8-react-%e5%87%bd%e6%95%b0%e4%b8%ad%e8%b0%83%e7%94%a8-hook><i class="fa fa-link" aria-hidden=true></i></a></h3><p><strong>不要在普通的 JavaScript 函数中调用 Hook</strong>你可以：</p><ul><li>✅ 在 React 的函数组件中调用 Hook</li><li>✅ 在自定义 Hook 中调用其他 Hook</li></ul><p>遵循此规则，确保组件的状态逻辑在代码中清晰可见。</p><h3 id=自定义-hook-必须以-use-开头>自定义 Hook 必须以 “<code>use</code>” 开头
<a class=heading-link href=#%e8%87%aa%e5%ae%9a%e4%b9%89-hook-%e5%bf%85%e9%a1%bb%e4%bb%a5-use-%e5%bc%80%e5%a4%b4><i class="fa fa-link" aria-hidden=true></i></a></h3><p>这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 <a href=https://zh-hans.reactjs.org/docs/hooks-rules.html>Hook 的规则</a>。</p><h2 id=参考文档>参考文档
<a class=heading-link href=#%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3><i class="fa fa-link" aria-hidden=true></i></a></h2><ul><li><p><a href=https://react.docschina.org/reference/react>https://react.docschina.org/reference/react</a></p></li><li><p><a href=https://zhuanlan.zhihu.com/p/376914196>https://zhuanlan.zhihu.com/p/376914196</a></p></li></ul><div id=cusdis_thread data-host=https://cusdis.com data-app-id=c2b015f9-9a4b-4997-b66f-f9c6ca26ebdd data-page-id=fade26ff9e0c2bbbc44ff7101a762533 data-page-url=https://chenkai.life/react/react-hooks/ data-page-title="React Hooks 基础" data-iframe=/js/cusdis/iframe.umd.js data-style=/js/cusdis/style.css></div></article></section></div></main><script src=/js/coder.min.cb0c595e02234420f3ad3886bf4a9bd2874d0e1e78e090138a9ef158b35aaf17.js integrity="sha256-ywxZXgIjRCDzrTiGv0qb0odNDh544JATip7xWLNarxc="></script>
<script src=/js/custom.js></script>
<script src=/js/font.min.js></script></body><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></html>