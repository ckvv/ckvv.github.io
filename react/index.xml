<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reacts on CK's Blog</title><link>https://chenkai.life/react/</link><description>Recent content in Reacts on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 24 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://chenkai.life/react/index.xml" rel="self" type="application/rss+xml"/><item><title>React Hook Context</title><link>https://chenkai.life/react/react-hooks-context/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-context/</guid><description>useContext 使用 Context 深层传递参数
useContext(defaultValue) 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &amp;lt;MyContext.Provider&amp;gt; 的 value prop 决定。调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 通过使用 memoization 来优化。
当组件上层最近的 &amp;lt;MyContext.Provider&amp;gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。
基础用法 // ThemeContext.js import { useState, createContext, useContext } from &amp;#34;react&amp;#34;; const themes = { light: { color: &amp;#34;#000000&amp;#34;, background: &amp;#34;#eeeeee&amp;#34; }, dark: { color: &amp;#34;#ffffff&amp;#34;, background: &amp;#34;#222222&amp;#34; } }; // 设置Context 默认值 export const ThemeContext = createContext(themes.</description></item><item><title>React Hook Effect</title><link>https://chenkai.life/react/react-hooks-effect/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-effect/</guid><description>useEffect 每当你的组件渲染时，React 将更新屏幕，然后运行 useEffect 中的代码(屏幕更新渲染之后)
该 Hook 接收一个包含命令式、且可能有副作用代码的函数。在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。使用 useEffect 完成副作用操作。
通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。同时你也可以使用多个effect hook，React 将按照 effect 声明的顺序依次调用组件中的每一个 effect。
useEffect(setup, dependencies?) 参数
setup：处理 Effect 的函数。setup 函数选择性返回一个 清理（cleanup） 函数。当组件被添加到 DOM 的时候，React 将运行 setup 函数。在每次依赖项变更重新渲染后，React 将首先使用旧值运行 cleanup 函数（如果你提供了该函数），然后使用新值运行 setup 函数。在组件从 DOM 中移除后，React 将最后一次运行 cleanup 函数。 dependencies：setup 代码中引用的所有响应式值的列表。响应式值包括 props、state 以及所有直接在组件内部声明的变量和函数。如果你的代码检查工具 配置了 React，那么它将验证是否每个响应式值都被正确地指定为一个依赖项。依赖项列表的元素数量必须是固定的，并且必须像 [dep1, dep2, dep3] 这样内联编写。React 将使用 Object.is 来比较每个依赖项和它先前的值。如果省略此参数，则在每次重新渲染组件之后，将重新运行 Effect 函数。如果传递空数组则仅在 初始渲染后 运行(开发环境下除外)。 基础用法 function CountButton() { const [count, setCount] = useState(0); useEffect(()=&amp;gt;{ console.</description></item><item><title>React Hook Ref</title><link>https://chenkai.life/react/react-hooks-ref/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-ref/</guid><description>useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与state不同，更新 ref 不会重新渲染组件。
基础用法 一个常见的用例便是命令式地访问子组件
function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () =&amp;gt; { // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); }; return ( &amp;lt;&amp;gt; &amp;lt;input ref={inputEl} type=&amp;#34;text&amp;#34; /&amp;gt; &amp;lt;button onClick={onButtonClick}&amp;gt;Focus the input&amp;lt;/button&amp;gt; &amp;lt;/&amp;gt; ); } 保存实例变量 useRef() Hook 不仅可以用于 DOM refs。本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”, 类似于一个 class 的实例属性。useRef() 和自建一个 {current: ...} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象.</description></item><item><title>React Hook State</title><link>https://chenkai.life/react/react-hooks-state/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-state/</guid><description>useState 在函数组件中存储内部 state
const [state, setState] = useState(initialState); 参数:
initialState: state初始值, 如果传递函数作为 initialState，则它将被视为初始化函数。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。 返回值:
state: 当前的 state setState: 更新 state 的方法, 它接收一个新的 state 值并将组件的一次重新渲染加入队列。如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过 基础用法 这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加
function Counter(props) { const [count, setCount] = useState(props.initialCount) return ( &amp;lt;button type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; setCount(count + 1)}&amp;gt; count is: {count} &amp;lt;/button&amp;gt; ); } Counter.defaultProps = { initialCount: 10, } 值得注意的是，类似class 组件中的setState,在我们执行setCount时count的值不是立即更新的，而是在下一个重渲染时才会更新，后调用的 setCount() 将覆盖同一周期内先调用 setCount 的值。
// 所以如在同一周期内多次执行setCount setCount(count + 1); setCount(count + 2); setCount(count + 1); // 这相当于setCount(count + 1); 因此count数仅增加一,解决办法可以参考函数式更新</description></item><item><title>React Hook 其他</title><link>https://chenkai.life/react/react-hooks-%E5%85%B6%E4%BB%96/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-%E5%85%B6%E4%BB%96/</guid><description>useDebugValue useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。
useDebugValue(value) 基础用法 function testHook(initialCount) { const [count, setCount] = useState(initialCount) // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. &amp;#34;testHook: 好好学习&amp;#34; useDebugValue(&amp;#39;好好学习&amp;#39;); return [count, setCount]; } function Counter(props) { const [count, setCount] = testHook(props.initialCount); return ( &amp;lt;button type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; setCount(count + 1)}&amp;gt; count is: {count} &amp;lt;/button&amp;gt; ); } 延迟格式化 debug 值 在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。
因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。
例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用：</description></item><item><title>React Hook 性能</title><link>https://chenkai.life/react/react-hooks-%E6%80%A7%E8%83%BD/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-%E6%80%A7%E8%83%BD/</guid><description>useMemo 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。
传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴
如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。
**你只可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。**将来，React 可能会选择“遗忘”以前的一些 memoized 值并在下次渲染时重新计算它们
//当a&amp;amp;b不变时返回memoizedValue（引用不变） const memoizedValue = useMemo(() =&amp;gt; computeExpensiveValue(a, b), [a, b]); 基础用法 function CountButton() { let [ label, setLabel ] = useState(&amp;#39;&amp;#39;); let [ count, setCount ] = useState(0); // 如果依赖项label不变memoizedValue不会重新计算 const memoizedValue = useMemo(()=&amp;gt;{ console.log(&amp;#39;useMemo&amp;#39;); return label.toUpperCase(); }, [label]); return ( &amp;lt;div&amp;gt; lable: &amp;lt;input type=&amp;#34;text&amp;#34; onChange={(e) =&amp;gt; setLabel(e.target.value)}/&amp;gt; {memoizedValue} &amp;lt;button type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; setCount(count + 1)}&amp;gt; count is: {count} &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); } useCallback 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。</description></item><item><title>React Hooks 基础</title><link>https://chenkai.life/react/react-hooks/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks/</guid><description>在React中，如果在编写函数组件并需要向其添加一些 state，以前的做法是必须将其它转化为 class。通过一个实例化的class，保存组件的state等状态，对于每一次更新只需要调用render方法就可以。但是 Class组件在变得复杂之后会变得难以维护。
在function组件中，没有一个状态去保存这些信息，每一次函数上下文执行，所有变量，常量都重新声明，执行完毕，再被垃圾机制回收。为了保存一些状态,执行一些副作用钩子,React 16.8新增了React Hooks，去帮助记录组件的状态，处理一些额外的副作用。通过React Hook 可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。你可以在现有的函数组件中使用 Hook，所以通常来说hook使得在组件之间复用状态逻辑变得方便、更容易实现代码的关注点分离。
Hooks的原理 React 保持对当前渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。
每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 useState() 调用会得到各自独立的本地 state 的原因。
// 每次执行一个`hooks`函数，都产生一个`hook`对象，里面保存了当前`hook`信息, // 然后将每个`hooks`以链表形式串联起来，并赋值给`workInProgress`的`memoizedState`。 // 也就证实了上述所说的，函数组件用`memoizedState`存放`hooks`链表。 function mountWorkInProgressHook(): Hook { const hook: Hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // This is the first hook in the list currentlyRenderingFiber.</description></item></channel></rss>