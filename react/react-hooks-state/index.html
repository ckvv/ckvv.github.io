<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=theme-color content="#ffffff"><meta name=color-scheme content="light dark"><meta name=description content="useState 在函数组件中存储内部 state
const [state, setState] = useState(initialState); 参数:
initialState: state初始值, 如果传递函数作为 initialState，则它将被视为初始化函数。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。 返回值:
state: 当前的 state setState: 更新 state 的方法, 它接收一个新的 state 值并将组件的一次重新渲染加入队列。如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过 基础用法 这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加
function Counter(props) { const [count, setCount] = useState(props.initialCount) return ( <button type=&#34;button&#34; onClick={() => setCount(count + 1)}> count is: {count} </button> ); } Counter.defaultProps = { initialCount: 10, } 值得注意的是，类似class 组件中的setState,在我们执行setCount时count的值不是立即更新的，而是在下一个重渲染时才会更新，后调用的 setCount() 将覆盖同一周期内先调用 setCount 的值。
// 所以如在同一周期内多次执行setCount setCount(count + 1); setCount(count + 2); setCount(count + 1); // 这相当于setCount(count + 1); 因此count数仅增加一,解决办法可以参考函数式更新"><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="React Hook State"><meta name=twitter:description content="useState 在函数组件中存储内部 state
const [state, setState] = useState(initialState); 参数:
initialState: state初始值, 如果传递函数作为 initialState，则它将被视为初始化函数。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。 返回值:
state: 当前的 state setState: 更新 state 的方法, 它接收一个新的 state 值并将组件的一次重新渲染加入队列。如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过 基础用法 这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加
function Counter(props) { const [count, setCount] = useState(props.initialCount) return ( <button type=&#34;button&#34; onClick={() => setCount(count + 1)}> count is: {count} </button> ); } Counter.defaultProps = { initialCount: 10, } 值得注意的是，类似class 组件中的setState,在我们执行setCount时count的值不是立即更新的，而是在下一个重渲染时才会更新，后调用的 setCount() 将覆盖同一周期内先调用 setCount 的值。
// 所以如在同一周期内多次执行setCount setCount(count + 1); setCount(count + 2); setCount(count + 1); // 这相当于setCount(count + 1); 因此count数仅增加一,解决办法可以参考函数式更新"><meta property="og:title" content="React Hook State"><meta property="og:description" content="useState 在函数组件中存储内部 state
const [state, setState] = useState(initialState); 参数:
initialState: state初始值, 如果传递函数作为 initialState，则它将被视为初始化函数。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。 返回值:
state: 当前的 state setState: 更新 state 的方法, 它接收一个新的 state 值并将组件的一次重新渲染加入队列。如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过 基础用法 这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加
function Counter(props) { const [count, setCount] = useState(props.initialCount) return ( <button type=&#34;button&#34; onClick={() => setCount(count + 1)}> count is: {count} </button> ); } Counter.defaultProps = { initialCount: 10, } 值得注意的是，类似class 组件中的setState,在我们执行setCount时count的值不是立即更新的，而是在下一个重渲染时才会更新，后调用的 setCount() 将覆盖同一周期内先调用 setCount 的值。
// 所以如在同一周期内多次执行setCount setCount(count + 1); setCount(count + 2); setCount(count + 1); // 这相当于setCount(count + 1); 因此count数仅增加一,解决办法可以参考函数式更新"><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/react/react-hooks-state/"><meta property="article:section" content="react"><meta property="article:published_time" content="2024-08-24T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-19T20:55:17+08:00"><title>React Hook State · CK's Blog</title><link rel=canonical href=https://chenkai.life/react/react-hooks-state/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.d12542c00c198b6a07ca9ea5981102805aecab0f5dfd5e3273d8c179088712c4.css integrity="sha256-0SVCwAwZi2oHyp6lmBECgFrsqw9d/V4yc9jBeQiHEsQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/favicon.ico><link rel=apple-touch-icon type=image/png sizes=256x256 href=/images/favicon-512x512.png><meta name=generator content="Hugo 0.119.0"><link rel=manifest href=/manifest.webmanifest></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><details id=table-of-contents-wapper><summary><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></summary></details><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/marks/>Marks</a></li><li class=navigation-item><a class=navigation-link href=https://github.com/ckvv/ckvv.github.io/tree/main/content>Create</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=github>GitHub</button>
<button class=search-btn data-type=google>Google</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/react/react-hooks-state/>React Hook State</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title rel=noopener target=_blank href=https://github.com/ckvv/ckvv.github.io/edit/main/content/react/react-hooks-state.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2024-08-24T00:00:00Z>2024-08-24</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/react/>React</a></span></div></div><h2 id=usestate>useState
<a class=heading-link href=#usestate><i class="fa fa-link" aria-hidden=true></i></a></h2><p>在函数组件中存储内部 state</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>setState</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#a6e22e>initialState</span>);
</span></span></code></pre></div><p>参数:</p><ul><li><code>initialState</code>: state初始值, 如果传递函数作为 <code>initialState</code>，则它将被视为初始化函数。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。</li></ul><p>返回值:</p><ul><li><code>state</code>: 当前的 state</li><li><code>setState</code>: 更新 state 的方法, 它接收一个新的 state 值并将组件的一次重新渲染加入队列。如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过</li></ul><h3 id=基础用法>基础用法
<a class=heading-link href=#%e5%9f%ba%e7%a1%80%e7%94%a8%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h3><p>这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Counter</span>(<span style=color:#a6e22e>props</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>initialCount</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;button&#34;</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}&gt;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>count</span> <span style=color:#a6e22e>is</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>count</span>}
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>Counter</span>.<span style=color:#a6e22e>defaultProps</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>initialCount</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>值得注意的是，类似class 组件中的<code>setState</code>,在我们执行<code>setCount</code>时count的值不是立即更新的，而是在下一个重渲染时才会更新，后调用的 <code>setCount()</code> 将覆盖同一周期内先调用 setCount 的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>// 所以如在同一周期内多次执行setCount
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 这相当于setCount(count + 1);
</span></span></span></code></pre></div><p>因此count数仅增加一,解决办法可以参考<code>函数式更新</code></p><h3 id=更新状态中的对象和数组>更新状态中的对象和数组
<a class=heading-link href=#%e6%9b%b4%e6%96%b0%e7%8a%b6%e6%80%81%e4%b8%ad%e7%9a%84%e5%af%b9%e8%b1%a1%e5%92%8c%e6%95%b0%e7%bb%84><i class="fa fa-link" aria-hidden=true></i></a></h3><p>当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>position</span>, <span style=color:#a6e22e>setPosition</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>y</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setPosition</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>clientX</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>y</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>clientY</span>
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setPosition</span>({
</span></span><span style=display:flex><span>  ...<span style=color:#a6e22e>position</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>y</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>clientY</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=使用-immer-编写简洁的更新逻辑>使用 Immer 编写简洁的更新逻辑
<a class=heading-link href=#%e4%bd%bf%e7%94%a8-immer-%e7%bc%96%e5%86%99%e7%ae%80%e6%b4%81%e7%9a%84%e6%9b%b4%e6%96%b0%e9%80%bb%e8%be%91><i class="fa fa-link" aria-hidden=true></i></a></h3><p>由 Immer 提供的 draft 是一种特殊类型的对象，被称为 Proxy，它会记录你用它所进行的操作。这就是你能够随心所欲地直接修改对象的原因所在！从原理上说，Immer 会弄清楚 draft 对象的哪些部分被改变了，并会依照你的修改创建出一个全新的对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useImmer</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;use-immer&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>person</span>, <span style=color:#a6e22e>updatePerson</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useImmer</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Niki de Saint Phalle&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>artwork</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Blue Nana&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>city</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Hamburg&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>image</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;https://i.imgur.com/Sd1AgUOm.jpg&#39;</span>,
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>updatePerson</span>(<span style=color:#a6e22e>draft</span> =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>draft</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=函数式更新>函数式更新
<a class=heading-link href=#%e5%87%bd%e6%95%b0%e5%bc%8f%e6%9b%b4%e6%96%b0><i class="fa fa-link" aria-hidden=true></i></a></h3><p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给State Hook 的更新函数，该回调函数将接收先前的 state，并返回一个更新后的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>setCount</span>((<span style=color:#a6e22e>count</span>) =&gt; <span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> =&gt; <span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> =&gt; <span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> =&gt; <span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 这相当于setCount(count + 4);
</span></span></span></code></pre></div><p>与 class 组件中的 <code>setState</code> 方法不同，<code>setState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code> 结合展开运算符来达到合并更新对象的效果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>people</span>, <span style=color:#a6e22e>setPeople</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>18</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;小红&#39;</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setPeople</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>people</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 不会自动合并更新对象
</span></span></span><span style=display:flex><span><span style=color:#75715e>// people {age: 18}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setPeople</span>(<span style=color:#a6e22e>prevState</span> =&gt; {
</span></span><span style=display:flex><span>  ..<span style=color:#a6e22e>prevState</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>age</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>prevState</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// people {age: 19, name: &#39;小红&#39;}
</span></span></span></code></pre></div><h3 id=惰性初始-state>惰性初始 state
<a class=heading-link href=#%e6%83%b0%e6%80%a7%e5%88%9d%e5%a7%8b-state><i class="fa fa-link" aria-hidden=true></i></a></h3><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用（在严格模式中，React 将两次调用初始化函数）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>setState</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>initialState</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>someExpensiveComputation</span>(<span style=color:#a6e22e>props</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>initialState</span>;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=跳过-state-更新>跳过 state 更新
<a class=heading-link href=#%e8%b7%b3%e8%bf%87-state-%e6%9b%b4%e6%96%b0><i class="fa fa-link" aria-hidden=true></i></a></h3><p>如果您将 State Hook 更新为与当前状态相同的值，React 将跳过子组件的渲染及 effect 的执行。（React 使用 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description>Object.is</a> 来比较 state）</p><p>如下面由于<code>Object.is</code>对比前后两次的state值未改变(引用内存中的同一个对象),所以未触发组件的更新。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>CountButton</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>countObj</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>18</span>
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#a6e22e>countObj</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;button&#34;</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>countObj</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>countObj</span>);
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>countObj</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// setCount({...countObj}); 如果想要触发更新可以这样做
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }}&gt;
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>count</span> <span style=color:#a6e22e>is</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>count</span>.<span style=color:#a6e22e>value</span>}
</span></span><span style=display:flex><span>        &lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用-key-重置-state-状态>使用 key 重置 state 状态
<a class=heading-link href=#%e4%bd%bf%e7%94%a8-key-%e9%87%8d%e7%bd%ae-state-%e7%8a%b6%e6%80%81><i class="fa fa-link" aria-hidden=true></i></a></h3><p>当在相同的位置渲染相同的组件时，React 会保留状态。通过 key 传递给 组件，每当 key 变化时，React 将重新创建 DOM，并 重置 组件和它的所有子组件的 state</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>ProfilePage</span>({ <span style=color:#a6e22e>userId</span> }) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>Profile</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>userId</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>userId</span>}
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>userId</span>}
</span></span><span style=display:flex><span>    /&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Profile</span>({ <span style=color:#a6e22e>userId</span> }) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ✅ 当 key 变化时，该组件内的 comment 或其他 state 会自动被重置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>comment</span>, <span style=color:#a6e22e>setComment</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#e6db74>&#39;&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=存储前一次渲染的信息>存储前一次渲染的信息
<a class=heading-link href=#%e5%ad%98%e5%82%a8%e5%89%8d%e4%b8%80%e6%ac%a1%e6%b8%b2%e6%9f%93%e7%9a%84%e4%bf%a1%e6%81%af><i class="fa fa-link" aria-hidden=true></i></a></h3><p>当你在渲染期间调用 set 函数时，React 将在你的组件使用 return 语句退出后立即重新渲染该组件，<strong>并在渲染子组件前进行</strong>。这样，子组件就不需要进行两次渲染。你的组件函数的其余部分仍会执行（然后结果将被丢弃）。如果你的条件判断在所有 Hook 调用的下方，可以提前添加一个 return; 以便更早地重新开始渲染。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>CountLabel</span>({ <span style=color:#a6e22e>count</span> }) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>prevCount</span>, <span style=color:#a6e22e>setPrevCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#a6e22e>count</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>trend</span>, <span style=color:#a6e22e>setTrend</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 在渲染时调用 set 函数时，它必须位于条件语句中，例如 prevCount !== count，并且必须在该条件语句中调用 setPrevCount(count)。否则，你的组件将在循环中重新渲染
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>prevCount</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>count</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setPrevCount</span>(<span style=color:#a6e22e>count</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setTrend</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>prevCount</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;increasing&#39;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;decreasing&#39;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>h1</span>&gt;{<span style=color:#a6e22e>count</span>}&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>      {<span style=color:#a6e22e>trend</span> <span style=color:#f92672>&amp;&amp;</span> &lt;<span style=color:#f92672>p</span>&gt;<span style=color:#a6e22e>The</span> <span style=color:#a6e22e>count</span> <span style=color:#a6e22e>is</span> {<span style=color:#a6e22e>trend</span>}&lt;/<span style=color:#f92672>p</span>&gt;}
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=存储一个函数>存储一个函数
<a class=heading-link href=#%e5%ad%98%e5%82%a8%e4%b8%80%e4%b8%aa%e5%87%bd%e6%95%b0><i class="fa fa-link" aria-hidden=true></i></a></h3><p>你不能像这样把函数放入状态</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>setFn</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#a6e22e>someFunction</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleClick</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setFn</span>(<span style=color:#a6e22e>someOtherFunction</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>React 认为 someFunction 是一个 初始化函数，而 someOtherFunction 是一个 更新函数，于是它尝试调用它们并存储结果。要实际 存储 一个函数，你必须在两种情况下在它们之前加上 <code>() =></code>。然后 React 将存储你传递的函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>setFn</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(() =&gt; <span style=color:#a6e22e>someFunction</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleClick</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setFn</span>(() =&gt; <span style=color:#a6e22e>someOtherFunction</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=注意事项>注意事项
<a class=heading-link href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9><i class="fa fa-link" aria-hidden=true></i></a></h3><ul><li>set 函数 仅更新 下一次 渲染的状态变量。如果在调用 set 函数后读取状态变量，则 仍会得到在调用之前显示在屏幕上的旧值。</li><li>如果你提供的新值与当前 state 相同（由 Object.is 比较确定），React 将 跳过重新渲染该组件及其子组件。</li><li>React 会批量处理状态更新。它会在所有事件处理函数运行 并调用其 <code>set</code> 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。如果你需要强制 React 更早地更新屏幕，例如访问 DOM，你可以使用 <code>flushSync</code></li><li>在渲染期间，只允许在当前渲染组件内部调用 set 函数。React 将丢弃其输出并立即尝试使用新状态重新渲染。你可以使用它来存储 先前渲染中的信息</li><li>在严格模式中（开发环境），React 将 两次调用你的更新函数</li></ul><h2 id=usereducer>useReducer
<a class=heading-link href=#usereducer><i class="fa fa-link" aria-hidden=true></i></a></h2><p>对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新逻辑整合到一个外部函数中, 这个函数叫作 reducer。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#a6e22e>useReducer</span>(<span style=color:#a6e22e>reducer</span>, <span style=color:#a6e22e>initialArg</span>, <span style=color:#a6e22e>init</span><span style=color:#f92672>?</span>)
</span></span></code></pre></div><p>参数</p><ul><li>reducer <code>(state, action) => state</code>：用于更新 state 的纯函数。参数为 <code>state</code> 和 <code>action</code>，返回值是更新后的 state。state 与 action 可以是任意合法值。</li><li>initialArg：用于初始化 state 的任意值。初始值的计算逻辑取决于接下来的 init 参数。</li><li>init：用于计算初始值的函数。如果存在，使用 <code>init(initialArg)</code> 的执行结果作为初始值，否则使用 <code>initialArg</code>。</li></ul><p>返回值</p><ul><li>当前的 state。初次渲染时，它是 init(initialArg) 或 initialArg （如果没有 init 函数）。</li><li>dispatch <code>(action) => void</code> 函数。用于更新 state 并触发组件的重新渲染</li></ul><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p><blockquote><p><code>dispatch</code> 不会在重新渲染之间变化,所以可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code></p></blockquote><h3 id=基础用法-1>基础用法
<a class=heading-link href=#%e5%9f%ba%e7%a1%80%e7%94%a8%e6%b3%95-1><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>initialState</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>count</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>reducer</span>(<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>action</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>action</span>.<span style=color:#a6e22e>type</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;increment&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>count</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;decrement&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>count</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Counter</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>dispatch</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useReducer</span>(<span style=color:#a6e22e>reducer</span>, <span style=color:#a6e22e>initialState</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Count</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>count</span>}
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>dispatch</span>({<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;decrement&#39;</span>})}&gt;<span style=color:#f92672>-</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>dispatch</span>({<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;increment&#39;</span>})}&gt;<span style=color:#f92672>+</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=惰性初始化>惰性初始化
<a class=heading-link href=#%e6%83%b0%e6%80%a7%e5%88%9d%e5%a7%8b%e5%8c%96><i class="fa fa-link" aria-hidden=true></i></a></h3><p>你可以选择惰性地创建初始 state。为此，需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 state 将被设置为 <code>init(initialArg)</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>dispatch</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useReducer</span>(<span style=color:#a6e22e>reducer</span>, <span style=color:#a6e22e>initialArg</span>, <span style=color:#a6e22e>init</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// state = init(initialArg);
</span></span></span></code></pre></div><h3 id=跳过-dispatch>跳过 dispatch
<a class=heading-link href=#%e8%b7%b3%e8%bf%87-dispatch><i class="fa fa-link" aria-hidden=true></i></a></h3><p>与<code>useState</code>类似，如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>initialState</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>count</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>reducer</span>(<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>action</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>action</span>.<span style=color:#a6e22e>type</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;increment&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// ❌ Object.is 判断返回state相同，所以将跳过子组件的渲染及副作用的执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>state</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;decrement&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>state</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Counter</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>dispatch</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useReducer</span>(<span style=color:#a6e22e>reducer</span>, <span style=color:#a6e22e>initialState</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Count</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>count</span>}
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>dispatch</span>({<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;decrement&#39;</span>})}&gt;<span style=color:#f92672>-</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>dispatch</span>({<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;increment&#39;</span>})}&gt;<span style=color:#f92672>+</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=避免重新创建初始值>避免重新创建初始值
<a class=heading-link href=#%e9%81%bf%e5%85%8d%e9%87%8d%e6%96%b0%e5%88%9b%e5%bb%ba%e5%88%9d%e5%a7%8b%e5%80%bc><i class="fa fa-link" aria-hidden=true></i></a></h3><p>与<code>useState</code>类似</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>// 每一次渲染的时候都会被调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createInitialState</span>(<span style=color:#a6e22e>username</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TodoList</span>({ <span style=color:#a6e22e>username</span> }) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>dispatch</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useReducer</span>(<span style=color:#a6e22e>reducer</span>, <span style=color:#a6e22e>createInitialState</span>(<span style=color:#a6e22e>username</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>你可以通过给 useReducer 的第三个参数传入 初始化函数 来解决这个问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TodoList</span>({ <span style=color:#a6e22e>username</span> }) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>dispatch</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useReducer</span>(<span style=color:#a6e22e>reducer</span>, <span style=color:#a6e22e>username</span>, <span style=color:#a6e22e>createInitialState</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div id=cusdis_thread data-host=https://cusdis.com data-app-id=c2b015f9-9a4b-4997-b66f-f9c6ca26ebdd data-page-id=554f5f0d43f80ca0d9d450524d773a6b data-page-url=https://chenkai.life/react/react-hooks-state/ data-page-title="React Hook State" data-iframe=/js/cusdis/iframe.umd.js data-style=/js/cusdis/style.css></div></article></section></div></main><script src=/js/coder.min.cb0c595e02234420f3ad3886bf4a9bd2874d0e1e78e090138a9ef158b35aaf17.js integrity="sha256-ywxZXgIjRCDzrTiGv0qb0odNDh544JATip7xWLNarxc="></script>
<script src=/js/custom.js></script>
<script src=/js/font.min.js></script></body><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></html>