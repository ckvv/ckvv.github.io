<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=theme-color content="#ffffff"><meta name=color-scheme content="light dark"><meta name=description content="useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与state不同，更新 ref 不会重新渲染组件。
参考 const ref = useRef(initialValue) 参数
initialValue: ref 对象的 current 属性的初始值。可以是任意类型的值。这个参数在首次渲染后被忽略 返回值
ref: 返回一个只有一个current属性的对象, 初始值为传递的 initialValue。之后可以将其设置为其他值。如果将 ref 对象作为一个 JSX 节点的 ref 属性传递给 React，React 将为它设置 current 属性。 在后续的渲染中，useRef 将返回同一个对象。 注意事项
不要在渲染期间写入或者读取 ref.current 改变 ref.current 属性时，React 不会重新渲染组件 除了 初始化 外不要在渲染期间写入或者读取 ref.current 在严格模式下，React 将会 调用两次组件方法 通过 ref 操作 DOM 一个常见的用例便是命令式地访问子组件
function TextInputWithFocusButton() { const inputRef = useRef(null); const onButtonClick = () => { // 当 React 创建 DOM 节点并将其渲染到屏幕时，React 将会把 DOM 节点设置为 ref 对象的 current 属性 // 当节点从屏幕上移除时，React 将把 current 属性设置回 null // `current` 指向已挂载到 DOM 上的文本输入元素 inputRef."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="React Hook Ref"><meta name=twitter:description content="useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与state不同，更新 ref 不会重新渲染组件。
参考 const ref = useRef(initialValue) 参数
initialValue: ref 对象的 current 属性的初始值。可以是任意类型的值。这个参数在首次渲染后被忽略 返回值
ref: 返回一个只有一个current属性的对象, 初始值为传递的 initialValue。之后可以将其设置为其他值。如果将 ref 对象作为一个 JSX 节点的 ref 属性传递给 React，React 将为它设置 current 属性。 在后续的渲染中，useRef 将返回同一个对象。 注意事项
不要在渲染期间写入或者读取 ref.current 改变 ref.current 属性时，React 不会重新渲染组件 除了 初始化 外不要在渲染期间写入或者读取 ref.current 在严格模式下，React 将会 调用两次组件方法 通过 ref 操作 DOM 一个常见的用例便是命令式地访问子组件
function TextInputWithFocusButton() { const inputRef = useRef(null); const onButtonClick = () => { // 当 React 创建 DOM 节点并将其渲染到屏幕时，React 将会把 DOM 节点设置为 ref 对象的 current 属性 // 当节点从屏幕上移除时，React 将把 current 属性设置回 null // `current` 指向已挂载到 DOM 上的文本输入元素 inputRef."><meta property="og:title" content="React Hook Ref"><meta property="og:description" content="useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与state不同，更新 ref 不会重新渲染组件。
参考 const ref = useRef(initialValue) 参数
initialValue: ref 对象的 current 属性的初始值。可以是任意类型的值。这个参数在首次渲染后被忽略 返回值
ref: 返回一个只有一个current属性的对象, 初始值为传递的 initialValue。之后可以将其设置为其他值。如果将 ref 对象作为一个 JSX 节点的 ref 属性传递给 React，React 将为它设置 current 属性。 在后续的渲染中，useRef 将返回同一个对象。 注意事项
不要在渲染期间写入或者读取 ref.current 改变 ref.current 属性时，React 不会重新渲染组件 除了 初始化 外不要在渲染期间写入或者读取 ref.current 在严格模式下，React 将会 调用两次组件方法 通过 ref 操作 DOM 一个常见的用例便是命令式地访问子组件
function TextInputWithFocusButton() { const inputRef = useRef(null); const onButtonClick = () => { // 当 React 创建 DOM 节点并将其渲染到屏幕时，React 将会把 DOM 节点设置为 ref 对象的 current 属性 // 当节点从屏幕上移除时，React 将把 current 属性设置回 null // `current` 指向已挂载到 DOM 上的文本输入元素 inputRef."><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/react/react-hooks-ref/"><meta property="article:section" content="react"><meta property="article:published_time" content="2024-08-24T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-12T09:39:59+08:00"><title>React Hook Ref · CK's Blog</title><link rel=canonical href=https://chenkai.life/react/react-hooks-ref/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.d12542c00c198b6a07ca9ea5981102805aecab0f5dfd5e3273d8c179088712c4.css integrity="sha256-0SVCwAwZi2oHyp6lmBECgFrsqw9d/V4yc9jBeQiHEsQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/favicon.ico><link rel=apple-touch-icon type=image/png sizes=256x256 href=/images/favicon-512x512.png><meta name=generator content="Hugo 0.119.0"><link rel=manifest href=/manifest.webmanifest></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><details id=table-of-contents-wapper><summary><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></summary></details><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/marks/>Marks</a></li><li class=navigation-item><a class=navigation-link href=https://github.com/ckvv/ckvv.github.io/tree/main/content>Create</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=github>GitHub</button>
<button class=search-btn data-type=google>Google</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/react/react-hooks-ref/>React Hook Ref</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title rel=noopener target=_blank href=https://github.com/ckvv/ckvv.github.io/edit/main/content/react/react-hooks-ref.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2024-08-24T00:00:00Z>2024-08-24</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/react/>React</a></span></div></div><h2 id=useref>useRef
<a class=heading-link href=#useref><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数<code>initialValue</code>。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与<code>state</code>不同，更新 <code>ref</code> 不会重新渲染组件。</p><h3 id=参考>参考
<a class=heading-link href=#%e5%8f%82%e8%80%83><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ref</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>(<span style=color:#a6e22e>initialValue</span>)
</span></span></code></pre></div><p>参数</p><ul><li><code>initialValue</code>: ref 对象的 current 属性的初始值。可以是任意类型的值。这个参数在首次渲染后被忽略</li></ul><p>返回值</p><ul><li><code>ref</code>: 返回一个只有一个<code>current</code>属性的对象, 初始值为传递的 initialValue。之后可以将其设置为其他值。如果将 ref 对象作为一个 JSX 节点的 ref 属性传递给 React，React 将为它设置 current 属性。
在后续的渲染中，useRef 将返回同一个对象。</li></ul><p>注意事项</p><ul><li>不要在渲染期间写入或者读取 ref.current</li><li>改变 ref.current 属性时，React 不会重新渲染组件</li><li>除了 初始化 外不要在渲染期间写入或者读取 ref.current</li><li>在严格模式下，React 将会 调用两次组件方法</li></ul><h3 id=通过-ref-操作-dom>通过 ref 操作 DOM
<a class=heading-link href=#%e9%80%9a%e8%bf%87-ref-%e6%93%8d%e4%bd%9c-dom><i class="fa fa-link" aria-hidden=true></i></a></h3><p>一个常见的用例便是命令式地访问子组件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TextInputWithFocusButton</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>onButtonClick</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当 React 创建 DOM 节点并将其渲染到屏幕时，React 将会把 DOM 节点设置为 ref 对象的 current 属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 当节点从屏幕上移除时，React 将把 current 属性设置回 null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// `current` 指向已挂载到 DOM 上的文本输入元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>inputRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>focus</span>();
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text&#34;</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>onButtonClick</span>}&gt;<span style=color:#a6e22e>Focus</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>input</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=保存实例变量>保存实例变量
<a class=heading-link href=#%e4%bf%9d%e5%ad%98%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f><i class="fa fa-link" aria-hidden=true></i></a></h3><p><a href=https://react.docschina.org/docs/hooks-reference.html#useref><code>useRef()</code></a> Hook 不仅可以用于 DOM refs。本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”, 类似于一个 class 的实例属性。<code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象.</p><p>当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。即变更 <code>.current</code> 属性不会引发组件重新渲染。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TextInputWithFocusButton</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>countRes</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>countRes</span>.<span style=color:#a6e22e>current</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>countRes</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>countRes</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      }}&gt;<span style=color:#a6e22e>Focus</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>input</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>      {<span style=color:#a6e22e>countRes</span>.<span style=color:#a6e22e>current</span>}
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=获取上一轮的-props-或-state>获取上一轮的 props 或 state
<a class=heading-link href=#%e8%8e%b7%e5%8f%96%e4%b8%8a%e4%b8%80%e8%bd%ae%e7%9a%84-props-%e6%88%96-state><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>usePrevious</span>(<span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ref</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ref</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ref</span>.<span style=color:#a6e22e>current</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Counter</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>prevCount</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>usePrevious</span>(<span style=color:#a6e22e>count</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>h1</span><span style=color:#f92672>&gt;</span><span style=color:#a6e22e>Now</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>count</span>}, <span style=color:#a6e22e>before</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>prevCount</span>}<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/h1&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}<span style=color:#f92672>&gt;</span><span style=color:#a6e22e>Add</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/button&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/&gt;</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=回调ref>回调Ref
<a class=heading-link href=#%e5%9b%9e%e8%b0%83ref><i class="fa fa-link" aria-hidden=true></i></a></h3><p>如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，你也可以传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数,它能助你更精细地控制何时 refs 被设置和解除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TextInput</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>textInput</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 不需要使用useRef
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputRef</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>ele</span>)=&gt;{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>ele</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>textInput</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ele</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text&#34;</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; {<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>textInput</span>)}}&gt;<span style=color:#a6e22e>Focus</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>input</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 ref 回调管理 ref 列表</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>itemsRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getMap</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>itemsRef</span>.<span style=color:#a6e22e>current</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 首次运行时初始化 Map。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>itemsRef</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>itemsRef</span>.<span style=color:#a6e22e>current</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>li</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>cat</span>.<span style=color:#a6e22e>id</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>node</span> =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>map</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getMap</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>node</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Add to the Map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>map</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>cat</span>, <span style=color:#a6e22e>node</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Remove from the Map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>map</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>cat</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }}
</span></span><span style=display:flex><span>  &gt;
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>&lt;<span style=color:#f92672>li</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>cat</span>.<span style=color:#a6e22e>id</span>}
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>node</span> =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>map</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getMap</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add to the Map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>map</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>cat</span>, <span style=color:#a6e22e>node</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Remove from the Map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>map</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>cat</span>);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  }}
</span></span><span style=display:flex><span>&gt;
</span></span></code></pre></div><h3 id=更新-state-后立即访问-ref-dom>更新 state 后立即访问 ref Dom
<a class=heading-link href=#%e6%9b%b4%e6%96%b0-state-%e5%90%8e%e7%ab%8b%e5%8d%b3%e8%ae%bf%e9%97%ae-ref-dom><i class="fa fa-link" aria-hidden=true></i></a></h3><p>在第一次渲染期间，DOM 节点尚未创建，因此 ref.current 将为 null。在渲染更新的过程中，DOM 节点还没有更新。所以读取它们还为时过早, 要解决此问题，你可以强制 React 同步更新（“刷新”）DOM。 为此，从 <code>react-dom</code> 导入 <code>flushSync</code> 并将 state 更新包裹 到 <code>flushSync</code> 调用中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>//  flushSync 中的代码执行后，立即同步更新 DOM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>flushSync</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setTodos</span>([ ...<span style=color:#a6e22e>todos</span>, <span style=color:#a6e22e>newTodo</span>]);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#a6e22e>listRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>lastChild</span>.<span style=color:#a6e22e>scrollIntoView</span>();
</span></span></code></pre></div><h3 id=访问另一个组件的-dom-节点>访问另一个组件的 DOM 节点
<a class=heading-link href=#%e8%ae%bf%e9%97%ae%e5%8f%a6%e4%b8%80%e4%b8%aa%e7%bb%84%e4%bb%b6%e7%9a%84-dom-%e8%8a%82%e7%82%b9><i class="fa fa-link" aria-hidden=true></i></a></h3><p>默认情况下，React 不允许组件访问其他组件的 DOM 节点。甚至自己的子组件也不行，想要 暴露其 DOM 节点的组件必须选择该行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>// MyInput 组件是使用 forwardRef 声明的。 这让从上面接收的 inputRef 作为第二个参数 ref 传入组件
</span></span></span><span style=display:flex><span><span style=color:#75715e>// MyInput 组件将自己接收到的 ref 传递给它内部的 &lt;input&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// useImperativeHandle可以限制暴露的功能
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MyInput</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>forwardRef</span>((<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>ref</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>input</span> {<span style=color:#a6e22e>...props</span>} <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>ref</span>} /&gt;;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>&lt;<span style=color:#f92672>MyInput</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} /&gt;
</span></span></code></pre></div><h3 id=不要在渲染期间读取写入-ref>不要在渲染期间读取、写入 ref
<a class=heading-link href=#%e4%b8%8d%e8%a6%81%e5%9c%a8%e6%b8%b2%e6%9f%93%e6%9c%9f%e9%97%b4%e8%af%bb%e5%8f%96%e5%86%99%e5%85%a5-ref><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>MyComponent</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 🚩 不要在渲染期间写入 ref
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>myRef</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 🚩 不要在渲染期间读取 ref
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>h1</span>&gt;{<span style=color:#a6e22e>myOtherRef</span>.<span style=color:#a6e22e>current</span>}&lt;/<span style=color:#f92672>h1</span>&gt;;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以在 事件处理程序或者 Effect 中读取和写入 ref。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>MyComponent</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ✅ 可以在 Effect 中读取和写入 ref
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>myRef</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>;
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleClick</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ✅ 可以在事件处理程序中读取和写入 ref
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>doSomething</span>(<span style=color:#a6e22e>myOtherRef</span>.<span style=color:#a6e22e>current</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>React 的渲染过程需要是可预测和确定的。如果在渲染期间允许读取或写入 ref，可能会导致渲染结果的不确定性</li><li>读取或写入 ref 可能会触发组件的重新渲染，从而导致无限循环</li><li>React 通常会对多个状态更新进行批处理，以提高性能。如果在渲染期间允许读取或写入 ref，可能会破坏这种批处理机制。因为 ref 的值不受 React 的状态管理系统控制，直接读取或写入 ref 可能会导致不一致的状态和渲染结果。</li><li>React 也支持异步更新，例如在使用 setState 或 useState 的回调函数中进行状态更新时，这些更新可能会被延迟执行。如果在渲染期间读取或写入 ref，可能会导致与异步更新的不一致性</li><li>便于错误追踪和调试，明确错误来源，</li></ul><h3 id=避免重复创建-ref-的内容>避免重复创建 ref 的内容
<a class=heading-link href=#%e9%81%bf%e5%85%8d%e9%87%8d%e5%a4%8d%e5%88%9b%e5%bb%ba-ref-%e7%9a%84%e5%86%85%e5%ae%b9><i class="fa fa-link" aria-hidden=true></i></a></h3><p>React 会保存 ref 初始值，并在后续的渲染中忽略它, 如 <code>const playerRef = useRef(new VideoPlayer())</code>，虽然 new VideoPlayer() 的结果只会在首次渲染时使用，但是依然在每次渲染时都在调用这个方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Video</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>playerRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 通常情况下，在渲染过程中写入或读取 ref.current 是不允许的。然而，在这种情况下是可以的，因为结果总是一样的，而且条件只在初始化时执行，所以是完全可预测的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>playerRef</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>playerRef</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>VideoPlayer</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=自定义组件的-ref>自定义组件的 ref
<a class=heading-link href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bb%84%e4%bb%b6%e7%9a%84-ref><i class="fa fa-link" aria-hidden=true></i></a></h3><p>默认情况下，自定义组件不会暴露它们内部 DOM 节点的 ref。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>// 一个组件可以指定将它的 ref “转发”给一个子组件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MyInput</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>forwardRef</span>((<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>ref</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>input</span> {<span style=color:#a6e22e>...props</span>} <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>ref</span>} /&gt;;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=useimperativehandle>useImperativeHandle
<a class=heading-link href=#useimperativehandle><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。<code>useImperativeHandle</code> 应当与 <a href=https://react.docschina.org/reference/react/forwardRef><code>forwardRef</code></a> 一起使用：</p><h3 id=参考-1>参考
<a class=heading-link href=#%e5%8f%82%e8%80%83-1><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>useImperativeHandle</span>(<span style=color:#a6e22e>ref</span>, <span style=color:#a6e22e>createHandle</span>, <span style=color:#a6e22e>dependencies</span><span style=color:#f92672>?</span>)
</span></span></code></pre></div><p>参数</p><ul><li><code>ref</code>：该 ref 是你从 forwardRef 渲染函数 中获得的第二个参数</li><li><code>create</code>Handle：该函数无需参数，它返回你想要暴露的 ref 的句柄。该句柄可以包含任何类型。通常，你会返回一个包含你想暴露的方法的对象</li><li><code>dependencies</code>：createHandle 代码中所用到的所有反应式的值的列表。 如果一次重新渲染导致某些依赖项发生了改变，或你没有提供这个参数列表，createHandle 将会被重新执行，而新生成的句柄则会被分配给 ref</li></ul><p>返回值
undefined</p><h3 id=基础用法>基础用法
<a class=heading-link href=#%e5%9f%ba%e7%a1%80%e7%94%a8%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h3><p>父组件可以调用 <code>inputRef.current.focus()</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>//该渲染函数会将 ref 传递给 &lt;input ref={ref}&gt; 元素。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>FancyInput</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>forwardRef</span>(<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>FancyInput</span>(<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>ref</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useImperativeHandle</span>(<span style=color:#a6e22e>ref</span>, () =&gt; ({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>focus</span><span style=color:#f92672>:</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>inputRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>focus</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} /&gt;;
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Wrapper</span>(){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// React 会将 &lt;FancyButton ref={ref}&gt; 元素的 ref 作为第二个参数传递给 React.forwardRef 函数中的渲染函数。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>FancyInput</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>inputRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>focus</span>()}&gt;<span style=color:#a6e22e>focus</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=createhandle-条件执行>createHandle 条件执行
<a class=heading-link href=#createhandle-%e6%9d%a1%e4%bb%b6%e6%89%a7%e8%a1%8c><i class="fa fa-link" aria-hidden=true></i></a></h3><p>默认情况下，在组建重新渲染后 <code>useImperativeHandle</code> 中的 <code>createHandle</code> 均会执行，为了不必要的性能损失我们可以传入依赖避免不必要的性能损失</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>useImperativeHandle</span>(<span style=color:#a6e22e>ref</span>, () =&gt; ({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>count</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>focus</span><span style=color:#f92672>:</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inputRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>focus</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}), [<span style=color:#a6e22e>count</span>]);
</span></span></code></pre></div><h3 id=注意事项>注意事项
<a class=heading-link href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9><i class="fa fa-link" aria-hidden=true></i></a></h3><ul><li><strong>不要滥用 ref</strong>。 你应当仅在你没法通过 prop 来表达 命令式 行为的时候才使用 ref：例如，滚动到指定节点、聚焦某个节点、触发一次动画，以及选择文本等等</li><li><strong>如果可以通过 prop 实现，那就不应该使用 ref</strong>：你不应该从一个 Model 组件暴露出 {open, close} 这样的命令式句柄，最好是像 <modal isopen={isOpen}>这样，将 isOpen 作为一个 prop。副作用 可以帮你通过 prop 来暴露一些命令式的行为。</li></ul><div id=cusdis_thread data-host=https://cusdis.com data-app-id=c2b015f9-9a4b-4997-b66f-f9c6ca26ebdd data-page-id=e7f74755385b2fcc3a192fa47911c8a3 data-page-url=https://chenkai.life/react/react-hooks-ref/ data-page-title="React Hook Ref" data-iframe=/js/cusdis/iframe.umd.js data-style=/js/cusdis/style.css></div></article></section></div></main><script src=/js/coder.min.cb0c595e02234420f3ad3886bf4a9bd2874d0e1e78e090138a9ef158b35aaf17.js integrity="sha256-ywxZXgIjRCDzrTiGv0qb0odNDh544JATip7xWLNarxc="></script>
<script src=/js/custom.js></script>
<script src=/js/font.min.js></script></body><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></html>