<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=theme-color content="#ffffff"><meta name=color-scheme content="light dark"><meta name=description content="useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与state不同，更新 ref 不会重新渲染组件。
基础用法 一个常见的用例便是命令式地访问子组件
function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () => { // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); }; return ( <> <input ref={inputEl} type=&#34;text&#34; /> <button onClick={onButtonClick}>Focus the input</button> </> ); } 保存实例变量 useRef() Hook 不仅可以用于 DOM refs。本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”, 类似于一个 class 的实例属性。useRef() 和自建一个 {current: ...} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="React Hook Ref"><meta name=twitter:description content="useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与state不同，更新 ref 不会重新渲染组件。
基础用法 一个常见的用例便是命令式地访问子组件
function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () => { // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); }; return ( <> <input ref={inputEl} type=&#34;text&#34; /> <button onClick={onButtonClick}>Focus the input</button> </> ); } 保存实例变量 useRef() Hook 不仅可以用于 DOM refs。本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”, 类似于一个 class 的实例属性。useRef() 和自建一个 {current: ...} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象."><meta property="og:title" content="React Hook Ref"><meta property="og:description" content="useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与state不同，更新 ref 不会重新渲染组件。
基础用法 一个常见的用例便是命令式地访问子组件
function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () => { // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); }; return ( <> <input ref={inputEl} type=&#34;text&#34; /> <button onClick={onButtonClick}>Focus the input</button> </> ); } 保存实例变量 useRef() Hook 不仅可以用于 DOM refs。本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”, 类似于一个 class 的实例属性。useRef() 和自建一个 {current: ...} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象."><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/react/react-hooks-ref/"><meta property="article:section" content="react"><meta property="article:published_time" content="2024-08-24T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-25T10:14:16+08:00"><title>React Hook Ref · CK's Blog</title><link rel=canonical href=https://chenkai.life/react/react-hooks-ref/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.d12542c00c198b6a07ca9ea5981102805aecab0f5dfd5e3273d8c179088712c4.css integrity="sha256-0SVCwAwZi2oHyp6lmBECgFrsqw9d/V4yc9jBeQiHEsQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/favicon.ico><link rel=apple-touch-icon type=image/png sizes=256x256 href=/images/favicon-512x512.png><meta name=generator content="Hugo 0.119.0"><link rel=manifest href=/manifest.webmanifest></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><details id=table-of-contents-wapper><summary><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></summary></details><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/marks/>Marks</a></li><li class=navigation-item><a class=navigation-link href=https://github.com/ckvv/ckvv.github.io/tree/main/content>Create</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=github>GitHub</button>
<button class=search-btn data-type=google>Google</button></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://chenkai.life/react/react-hooks-ref/>React Hook Ref</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title rel=noopener target=_blank href=https://github.com/ckvv/ckvv.github.io/edit/main/content/react/react-hooks-ref.md>编辑</a></div></header><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2024-08-24T00:00:00Z>2024-08-24</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/react/>React</a></span></div></div><h2 id=useref>useRef
<a class=heading-link href=#useref><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数<code>initialValue</code>。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与<code>state</code>不同，更新 <code>ref</code> 不会重新渲染组件。</p><h3 id=基础用法>基础用法
<a class=heading-link href=#%e5%9f%ba%e7%a1%80%e7%94%a8%e6%b3%95><i class="fa fa-link" aria-hidden=true></i></a></h3><p>一个常见的用例便是命令式地访问子组件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TextInputWithFocusButton</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputEl</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>onButtonClick</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// `current` 指向已挂载到 DOM 上的文本输入元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>inputEl</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>focus</span>();
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputEl</span>} <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text&#34;</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>onButtonClick</span>}&gt;<span style=color:#a6e22e>Focus</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>input</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=保存实例变量>保存实例变量
<a class=heading-link href=#%e4%bf%9d%e5%ad%98%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f><i class="fa fa-link" aria-hidden=true></i></a></h3><p><a href=https://react.docschina.org/docs/hooks-reference.html#useref><code>useRef()</code></a> Hook 不仅可以用于 DOM refs。本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”, 类似于一个 class 的实例属性。<code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象.</p><p>当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。即变更 <code>.current</code> 属性不会引发组件重新渲染。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TextInputWithFocusButton</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>countRes</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>countRes</span>.<span style=color:#a6e22e>current</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>countRes</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>countRes</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      }}&gt;<span style=color:#a6e22e>Focus</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>input</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>      {<span style=color:#a6e22e>countRes</span>.<span style=color:#a6e22e>current</span>}
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=获取上一轮的-props-或-state>获取上一轮的 props 或 state
<a class=heading-link href=#%e8%8e%b7%e5%8f%96%e4%b8%8a%e4%b8%80%e8%bd%ae%e7%9a%84-props-%e6%88%96-state><i class="fa fa-link" aria-hidden=true></i></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>usePrevious</span>(<span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ref</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ref</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ref</span>.<span style=color:#a6e22e>current</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Counter</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>prevCount</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>usePrevious</span>(<span style=color:#a6e22e>count</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>h1</span><span style=color:#f92672>&gt;</span><span style=color:#a6e22e>Now</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>count</span>}, <span style=color:#a6e22e>before</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>prevCount</span>}<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/h1&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}<span style=color:#f92672>&gt;</span><span style=color:#a6e22e>Add</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/button&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/&gt;</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=回调ref>回调Ref
<a class=heading-link href=#%e5%9b%9e%e8%b0%83ref><i class="fa fa-link" aria-hidden=true></i></a></h3><p>如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，你也可以传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数,它能助你更精细地控制何时 refs 被设置和解除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TextInput</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>textInput</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 不需要使用useRef
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputRef</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>ele</span>)=&gt;{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>ele</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>textInput</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ele</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text&#34;</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; {<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>textInput</span>)}}&gt;<span style=color:#a6e22e>Focus</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>input</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 ref 回调管理 ref 列表</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>itemsRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getMap</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>itemsRef</span>.<span style=color:#a6e22e>current</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 首次运行时初始化 Map。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>itemsRef</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>itemsRef</span>.<span style=color:#a6e22e>current</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>li</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>cat</span>.<span style=color:#a6e22e>id</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>node</span> =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>map</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getMap</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>node</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Add to the Map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>map</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>cat</span>, <span style=color:#a6e22e>node</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Remove from the Map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>map</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>cat</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }}
</span></span><span style=display:flex><span>  &gt;
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>&lt;<span style=color:#f92672>li</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>cat</span>.<span style=color:#a6e22e>id</span>}
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>node</span> =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>map</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getMap</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add to the Map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>map</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>cat</span>, <span style=color:#a6e22e>node</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Remove from the Map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>map</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>cat</span>);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  }}
</span></span><span style=display:flex><span>&gt;
</span></span></code></pre></div><h3 id=更新-state-后立即访问-ref-dom>更新 state 后立即访问 ref Dom
<a class=heading-link href=#%e6%9b%b4%e6%96%b0-state-%e5%90%8e%e7%ab%8b%e5%8d%b3%e8%ae%bf%e9%97%ae-ref-dom><i class="fa fa-link" aria-hidden=true></i></a></h3><p>在第一次渲染期间，DOM 节点尚未创建，因此 ref.current 将为 null。在渲染更新的过程中，DOM 节点还没有更新。所以读取它们还为时过早, 要解决此问题，你可以强制 React 同步更新（“刷新”）DOM。 为此，从 <code>react-dom</code> 导入 <code>flushSync</code> 并将 state 更新包裹 到 <code>flushSync</code> 调用中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>//  flushSync 中的代码执行后，立即同步更新 DOM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>flushSync</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setTodos</span>([ ...<span style=color:#a6e22e>todos</span>, <span style=color:#a6e22e>newTodo</span>]);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#a6e22e>listRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>lastChild</span>.<span style=color:#a6e22e>scrollIntoView</span>();
</span></span></code></pre></div><h3 id=访问另一个组件的-dom-节点>访问另一个组件的 DOM 节点
<a class=heading-link href=#%e8%ae%bf%e9%97%ae%e5%8f%a6%e4%b8%80%e4%b8%aa%e7%bb%84%e4%bb%b6%e7%9a%84-dom-%e8%8a%82%e7%82%b9><i class="fa fa-link" aria-hidden=true></i></a></h3><p>默认情况下，React 不允许组件访问其他组件的 DOM 节点。甚至自己的子组件也不行，想要 暴露其 DOM 节点的组件必须选择该行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>// MyInput 组件是使用 forwardRef 声明的。 这让从上面接收的 inputRef 作为第二个参数 ref 传入组件
</span></span></span><span style=display:flex><span><span style=color:#75715e>// MyInput 组件将自己接收到的 ref 传递给它内部的 &lt;input&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// useImperativeHandle可以限制暴露的功能
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MyInput</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>forwardRef</span>((<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>ref</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>input</span> {<span style=color:#a6e22e>...props</span>} <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>ref</span>} /&gt;;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>&lt;<span style=color:#f92672>MyInput</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} /&gt;
</span></span></code></pre></div><h2 id=useimperativehandle>useImperativeHandle
<a class=heading-link href=#useimperativehandle><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。<code>useImperativeHandle</code> 应当与 <a href=https://react.docschina.org/reference/react/forwardRef><code>forwardRef</code></a> 一起使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>useImperativeHandle</span>(<span style=color:#a6e22e>ref</span>, <span style=color:#a6e22e>createHandle</span>, [<span style=color:#a6e22e>deps</span>])
</span></span></code></pre></div><h3 id=基础用法-1>基础用法
<a class=heading-link href=#%e5%9f%ba%e7%a1%80%e7%94%a8%e6%b3%95-1><i class="fa fa-link" aria-hidden=true></i></a></h3><p>父组件可以调用 <code>inputRef.current.focus()</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>//该渲染函数会将 ref 传递给 &lt;input ref={ref}&gt; 元素。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>FancyInput</span>(<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>ref</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useImperativeHandle</span>(<span style=color:#a6e22e>ref</span>, () =&gt; ({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>focus</span><span style=color:#f92672>:</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>inputRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>focus</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} /&gt;;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>FancyInput</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>forwardRef</span>(<span style=color:#a6e22e>FancyInput</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Wrapper</span>(){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRef</span>();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// React 会将 &lt;FancyButton ref={ref}&gt; 元素的 ref 作为第二个参数传递给 React.forwardRef 函数中的渲染函数。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>FancyInput</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>inputRef</span>} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{() =&gt; <span style=color:#a6e22e>inputRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>focus</span>()}&gt;<span style=color:#a6e22e>focus</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=createhandle条件执行>createHandle条件执行
<a class=heading-link href=#createhandle%e6%9d%a1%e4%bb%b6%e6%89%a7%e8%a1%8c><i class="fa fa-link" aria-hidden=true></i></a></h3><p>默认情况下，在组建重新渲染后useImperativeHandle中的createHandle 均会执行，为了不必要的性能损失我们可以传入依赖避免不必要的性能损失</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>useImperativeHandle</span>(<span style=color:#a6e22e>ref</span>, () =&gt; ({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>count</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>focus</span><span style=color:#f92672>:</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inputRef</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>focus</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}), [<span style=color:#a6e22e>count</span>]);
</span></span></code></pre></div><div id=cusdis_thread data-host=https://cusdis.com data-app-id=c2b015f9-9a4b-4997-b66f-f9c6ca26ebdd data-page-id=e7f74755385b2fcc3a192fa47911c8a3 data-page-url=https://chenkai.life/react/react-hooks-ref/ data-page-title="React Hook Ref" data-iframe=/js/cusdis/iframe.umd.js data-style=/js/cusdis/style.css></div></article></section></div></main><script src=/js/coder.min.cb0c595e02234420f3ad3886bf4a9bd2874d0e1e78e090138a9ef158b35aaf17.js integrity="sha256-ywxZXgIjRCDzrTiGv0qb0odNDh544JATip7xWLNarxc="></script>
<script src=/js/custom.js></script>
<script src=/js/font.min.js></script></body><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></html>