<!DOCTYPE html><html lang="zh-CN" class="h-full bg-white"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.ico"><meta name="generator" content="Astro v5.7.4"><!-- Canonical URL --><link rel="canonical" href="https://ckvv.net/blog/javascript/js-this/"><!-- Primary Meta Tags --><title>js中的this</title><meta name="title" content="js中的this"><meta name="description" content="The blog of ckvv"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://ckvv.net/blog/javascript/js-this/"><meta property="og:title" content="js中的this"><meta property="og:description" content="The blog of ckvv"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://ckvv.net/blog/javascript/js-this/"><meta property="twitter:title" content="js中的this"><meta property="twitter:description" content="The blog of ckvv"><link rel="stylesheet" href="/_astro/about.CAaTz6gG.css">
<style>.outline-item-active[data-astro-cid-v2nb7cev]{color:var(--color-sky-700)}
</style></head> <body class="flex flex-col min-h-full"> <header class="sticky top-0 px-4 bg-white z-10 shadow-md"> <nav class="w-full max-w-6xl m-auto elect-none flex justify-between items-center text-2xl my-4"> <div class="flex gap-2 md:gap-4 items-center font-bold"> <h2><a href="/">CK Blog</a></h2> </div> <div class="flex gap-2 md:gap-4"> <a href="/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1"> Home <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-width duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="/tag/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1"> Tag <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-width duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="/assets/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center hidden md:inline"> Assets <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-width duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="/about/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1"> About <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-width duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="https://github.com/ckvv/ckvv.github.io" target="_blank" aria-label="GitHub" class="hidden md:inline"> <svg width="32" height="32" viewBox="0 0 32 32" fill="none">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16 0C7.16 0 0 7.16 0 16C0 23.08 4.58 29.06 10.94 31.18C11.74 31.32 12.04 30.84 12.04 30.42C12.04 30.04 12.02 28.78 12.02 27.44C8 28.18 6.96 26.46 6.64 25.56C6.46 25.1 5.68 23.68 5 23.3C4.44 23 3.64 22.26 4.98 22.24C6.24 22.22 7.14 23.4 7.44 23.88C8.88 26.3 11.18 25.62 12.1 25.2C12.24 24.16 12.66 23.46 13.12 23.06C9.56 22.66 5.84 21.28 5.84 15.16C5.84 13.42 6.46 11.98 7.48 10.86C7.32 10.46 6.76 8.82 7.64 6.62C7.64 6.62 8.98 6.2 12.04 8.26C13.32 7.9 14.68 7.72 16.04 7.72C17.4 7.72 18.76 7.9 20.04 8.26C23.1 6.18 24.44 6.62 24.44 6.62C25.32 8.82 24.76 10.46 24.6 10.86C25.62 11.98 26.24 13.4 26.24 15.16C26.24 21.3 22.5 22.66 18.94 23.06C19.52 23.56 20.02 24.52 20.02 26.02C20.02 28.16 20 29.88 20 30.42C20 30.84 20.3 31.34 21.1 31.18C27.42 29.06 32 23.06 32 16C32 7.16 24.84 0 16 0V0Z" fill="#24292E" />
</svg> </a> </div> </nav> </header> <main class="w-full max-w-5xl mx-auto px-4 py-8 flex-grow font-tabular-nums">  <h1 class="text-4xl font-bold my-4">js中的this</h1>
  <div class="my-2 flex justify-between items-center"><div class="flex gap-4"><a href="/tag/javascript/" class="bg-gray-100 hover:bg-gray-300 text-sky-700 px-2 py-1 rounded cursor-pointer"> javascript </a></div><span class="tabular-nums"> 2021/07/09 </span></div>
  <div class="sticky z-10 top-20 inline-block text-left w-full" data-astro-cid-v2nb7cev><div class="2xl:hidden flex justify-end" data-astro-cid-v2nb7cev><button type="button" class="inline-flex justify-center gap-x-1.5 rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-900 hover:bg-gray-50" id="menu-button" aria-expanded="false" aria-haspopup="true" data-astro-cid-v2nb7cev>
On this page
<svg class="-mr-1 size-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" data-astro-cid-v2nb7cev><path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" data-astro-cid-v2nb7cev></path></svg></button></div><div id="md-outline-content" class="max-h-[calc(100vh-200px)] overflow-auto hidden absolute right-0 py-2 mt-2 min-w-48 max-w-full origin-top-right rounded-md bg-white ring-1 shadow-lg ring-black/5 focus:outline-hidden 2xl:-right-12 2xl:float-right 2xl:translate-x-full 2xl:max-w-[min(calc(50vw-580px),320px)]" aria-orientation="vertical" aria-labelledby="menu-button" tabindex="-1" data-astro-cid-v2nb7cev><a class="outline-item block px-4 py-1 text-sm break-all" href="#全局环境" data-astro-cid-v2nb7cev>全局环境</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#函数运行内环境" data-astro-cid-v2nb7cev>函数（运行内）环境</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#箭头函数" data-astro-cid-v2nb7cev>箭头函数</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#作为对象的方法" data-astro-cid-v2nb7cev>作为对象的方法</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#原型链中的-this" data-astro-cid-v2nb7cev>原型链中的 this</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#getter-与-setter-中的-this" data-astro-cid-v2nb7cev>getter 与 setter 中的 this</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#作为构造函数" data-astro-cid-v2nb7cev>作为构造函数</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#作为一个-dom-事件处理函数" data-astro-cid-v2nb7cev>作为一个 DOM 事件处理函数</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#作为一个内联事件处理函数" data-astro-cid-v2nb7cev>作为一个内联事件处理函数</a></div></div><script type="module">function f(n,o){let r,t;return(...c)=>{t?(clearTimeout(r),r=setTimeout(()=>{Date.now()-t>=o&&(n(...c),t=Date.now())},o-(Date.now()-t))):(n(...c),t=Date.now())}}function u(n){const o=document.getElementById("menu-button"),r=document.getElementById("md-outline-content"),t=n===void 0?o.getAttribute("aria-expanded")==="true":!n;o.setAttribute("aria-expanded",`${!t}`),r.style.display=t?"none":"block"}function l(){window.innerWidth>=1536&&u(!0)}window.addEventListener("resize",l);document.addEventListener("DOMContentLoaded",()=>{l();const n=document.getElementById("md-outline-content");n.onclick=e=>{e.preventDefault();const i=document.querySelector(e.target.getAttribute("href"));i&&window.scrollTo({top:i.offsetTop-64,behavior:"smooth"})};const o=document.getElementById("menu-button");o.onclick=()=>u(),document.onclick=e=>{if(window.innerWidth>=1536)return;const i=document.getElementById("md-outline-content");e.target.id!=="menu-button"&&!i.contains(e.target)&&o.getAttribute("aria-expanded")==="true"&&u()};const r=document.querySelector(".content").querySelectorAll("h1, h2, h3"),t=document.querySelectorAll(".outline-item"),c={root:null,rootMargin:"0px",threshold:.6},a=f(e=>{e.forEach(i=>{if(i.isIntersecting){const b=i.target.getAttribute("id");t.forEach(s=>{const d=`#${b}`;s.classList.remove("outline-item-active"),s.getAttribute("href")===d&&(s.classList.add("outline-item-active"),history.replaceState(null,"",d))})}})},200),m=new IntersectionObserver(a,c);r.forEach(e=>{m.observe(e)})});</script><div class="content"> <p>js 中 this 指当前执行代码的环境对象，this 不能在执行期间被赋值如<code>this = null</code>，在绝大多数情况下，函数的调用方式决定了 this 的值</p>
<h2 id="全局环境">全局环境</h2>
<p>浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#6A737D">// 在浏览器中, window 对象同时也是全局对象：</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#F97583"> ===</span><span style="color:#E1E4E8"> window); </span><span style="color:#6A737D">// true</span></span>
<span class="line"><span style="color:#E1E4E8">a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 37</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(window.a); </span><span style="color:#6A737D">// 37</span></span>
<span class="line"><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.b </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> 'MDN'</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(window.b); </span><span style="color:#6A737D">// "MDN"</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(b); </span><span style="color:#6A737D">// "MDN"</span></span></code></pre>
<p>node 环境中 this 是一个空对象</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">//  {}</span></span></code></pre>
<h2 id="函数运行内环境">函数（运行内）环境</h2>
<p>在函数内部，this 的值取决于函数被调用的方式</p>
<p>因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> f1</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#6A737D">// 在浏览器中：</span></span>
<span class="line"><span style="color:#B392F0">f1</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> window; </span><span style="color:#6A737D">// 在浏览器中，全局对象是window</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 在Node中：</span></span>
<span class="line"><span style="color:#B392F0">f1</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> global;</span></span></code></pre>
<p>严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#9ECBFF">'use strict'</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// 这里是严格模式</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> f2</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">f2</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> undefined</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">window.</span><span style="color:#B392F0">f2</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">//  window</span></span></code></pre>
<p>如果要想把 this 的值从一个环境传到另一个，就要用 call 或 apply 方法</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#6A737D">// 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> { a: </span><span style="color:#9ECBFF">'Custom'</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 这个属性是在global对象定义的。</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> a</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> 'Global'</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> whatsThis</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">arg</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.a; </span><span style="color:#6A737D">// this的值取决于函数的调用方式</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">whatsThis</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// 'Global'</span></span>
<span class="line"><span style="color:#E1E4E8">whatsThis.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(obj); </span><span style="color:#6A737D">// 'Custom'</span></span>
<span class="line"><span style="color:#E1E4E8">whatsThis.</span><span style="color:#B392F0">apply</span><span style="color:#E1E4E8">(obj); </span><span style="color:#6A737D">// 'Custom'</span></span></code></pre>
<p>当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自 Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> add</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">c</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">d</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.a </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.b </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> d;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> o</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> { a: </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, b: </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 第一个参数是作为‘this’使用的对象</span></span>
<span class="line"><span style="color:#6A737D">// 后续参数作为参数传递给函数调用</span></span>
<span class="line"><span style="color:#E1E4E8">add.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(o, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// 1 + 3 + 5 + 7 = 16</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 第一个参数也是作为‘this’使用的对象</span></span>
<span class="line"><span style="color:#6A737D">// 第二个参数是一个数组，数组里的元素用作函数调用中的参数</span></span>
<span class="line"><span style="color:#E1E4E8">add.</span><span style="color:#B392F0">apply</span><span style="color:#E1E4E8">(o, [</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">20</span><span style="color:#E1E4E8">]); </span><span style="color:#6A737D">// 1 + 3 + 10 + 20 = 34</span></span></code></pre>
<p>使用 call 和 apply 函数的时候要注意，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。因此，如果传递的值是一个原始值比如 7 或 ‘foo’，那么就会使用相关构造函数将它转换为对象，所以原始值 7 会被转换为对象，像 new Number(7) 这样，而字符串 ‘foo’ 转化成 new String(‘foo’) 这样，例如：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> bar</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#6A737D">// 原始值 7 被隐式转换为对象</span></span>
<span class="line"><span style="color:#E1E4E8">bar.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// Number {7}</span></span></code></pre>
<p>ECMAScript 5 引入了 Function.prototype.bind。调用 f.bind(someObject)会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> f</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.a;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> g</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> f.</span><span style="color:#B392F0">bind</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  a: </span><span style="color:#9ECBFF">'azerty'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">g</span><span style="color:#E1E4E8">()); </span><span style="color:#6A737D">// azerty</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> h</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> g.</span><span style="color:#B392F0">bind</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  a: </span><span style="color:#9ECBFF">'yoo'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">}); </span><span style="color:#6A737D">// bind只生效一次！</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">h</span><span style="color:#E1E4E8">()); </span><span style="color:#6A737D">// azerty</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> o</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  a: </span><span style="color:#79B8FF">37</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  f,</span></span>
<span class="line"><span style="color:#E1E4E8">  g,</span></span>
<span class="line"><span style="color:#E1E4E8">  h,</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(o.</span><span style="color:#B392F0">f</span><span style="color:#E1E4E8">(), o.</span><span style="color:#B392F0">g</span><span style="color:#E1E4E8">(), o.</span><span style="color:#B392F0">h</span><span style="color:#E1E4E8">()); </span><span style="color:#6A737D">// 37, azerty, azerty</span></span></code></pre>
<h2 id="箭头函数">箭头函数</h2>
<p>在箭头函数中，this 与封闭词法环境的 this 保持一致。在全局代码中，它将被设置为全局对象,无论如何，foo 的 this 被设置为他被创建时的环境</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> globalObject</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#B392F0"> foo</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> () </span><span style="color:#F97583">=></span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">foo</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> globalObject); </span><span style="color:#6A737D">// true</span></span></code></pre>
<p>如果将 this 传递给 call、bind、或者 apply，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为 null。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> { foo };</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(obj.</span><span style="color:#B392F0">foo</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> globalObject); </span><span style="color:#6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 尝试使用call来设定this</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(foo.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(obj) </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> globalObject); </span><span style="color:#6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 尝试使用bind来设定this</span></span>
<span class="line"><span style="color:#E1E4E8">foo </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> foo.</span><span style="color:#B392F0">bind</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">foo</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> globalObject); </span><span style="color:#6A737D">// true</span></span></code></pre>
<p>箭头函数的 this 被设置为封闭的词法环境,一个赋值给了 obj.bar 的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 A 调用时，函数 B 的 this 被永久设置为 obj.bar（函数 A）的 this。当返回的函数（函数 B）被调用时，它 this 始终是最初设置的</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#6A737D">// 创建一个含有bar方法的obj对象，</span></span>
<span class="line"><span style="color:#6A737D">// bar返回一个函数，</span></span>
<span class="line"><span style="color:#6A737D">// 这个函数返回this，</span></span>
<span class="line"><span style="color:#6A737D">// 这个返回的函数是以箭头函数创建的，</span></span>
<span class="line"><span style="color:#6A737D">// 所以它的this被永久绑定到了它外层函数的this。</span></span>
<span class="line"><span style="color:#6A737D">// bar的值可以在调用中设置，这反过来又设置了返回函数的值。</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  bar</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#B392F0"> x</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> () </span><span style="color:#F97583">=></span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> x;</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。</span></span>
<span class="line"><span style="color:#6A737D">// 将返回的函数的引用赋值给fn。</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> fn</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> obj.</span><span style="color:#B392F0">bar</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 直接调用fn而不设置this，</span></span>
<span class="line"><span style="color:#6A737D">// 通常(即不使用箭头函数的情况)默认为全局对象</span></span>
<span class="line"><span style="color:#6A737D">// 若在严格模式则为undefined</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">fn</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> obj); </span><span style="color:#6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 但是注意，如果你只是引用obj的方法，</span></span>
<span class="line"><span style="color:#6A737D">// 而没有调用它</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> fn2</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> obj.bar;</span></span>
<span class="line"><span style="color:#6A737D">// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">fn2</span><span style="color:#E1E4E8">()() </span><span style="color:#F97583">==</span><span style="color:#E1E4E8"> window); </span><span style="color:#6A737D">// true</span></span></code></pre>
<h2 id="作为对象的方法">作为对象的方法</h2>
<p>当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象;
当 o.f()被调用时，函数内的 this 将绑定到 o 对象</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> o</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  prop: </span><span style="color:#79B8FF">37</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">  f</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.prop;</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(o.</span><span style="color:#B392F0">f</span><span style="color:#E1E4E8">()); </span><span style="color:#6A737D">// logs 37</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">window.prop </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">a </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> o.f;</span></span>
<span class="line"><span style="color:#B392F0">a</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// 3</span></span></code></pre>
<p><strong>注意</strong>
这样的行为，根本不受函数定义方式或位置的影响。在前面的例子中，我们在定义对象 o 的同时，将函数内联定义为成员 f 。但是，我们也可以先定义函数，然后再将其附属到 o.f。这样做会导致相同的行为：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> o</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> { prop: </span><span style="color:#79B8FF">37</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> independent</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.prop;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">o.f </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> independent;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(o.</span><span style="color:#B392F0">f</span><span style="color:#E1E4E8">()); </span><span style="color:#6A737D">// logs 37</span></span></code></pre>
<p><strong>这表明函数是从 o 的 f 成员调用的才是重点</strong></p>
<p>this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 g 当作对象 o.b 的函数调用。在这次执行期间，函数中的 this 将指向 o.b。事实证明，这与他是对象 o 的成员没有多大关系，最靠近的引用才是最重要的</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#E1E4E8">o.b </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> { g: independent, prop: </span><span style="color:#79B8FF">42</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(o.b.</span><span style="color:#B392F0">g</span><span style="color:#E1E4E8">()); </span><span style="color:#6A737D">// 42</span></span></code></pre>
<h2 id="原型链中的-this">原型链中的 this</h2>
<p>如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法在对象上一样</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> o</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  f</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.a </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.b;</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> p</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">create</span><span style="color:#E1E4E8">(o);</span></span>
<span class="line"><span style="color:#E1E4E8">p.a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">p.b </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(p.</span><span style="color:#B392F0">f</span><span style="color:#E1E4E8">()); </span><span style="color:#6A737D">// 5</span></span></code></pre>
<p>在这个例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。虽然在对 f 的查找过程中，最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p。也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p。这是 JavaScript 的原型继承中的一个有趣的特性。</p>
<h2 id="getter-与-setter-中的-this">getter 与 setter 中的 this</h2>
<p>再次，相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> sum</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.a </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.b </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.c;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> o</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  a: </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  b: </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  c: </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">  get</span><span style="color:#B392F0"> average</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.a </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.b </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.c) </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">Object.</span><span style="color:#B392F0">defineProperty</span><span style="color:#E1E4E8">(o, </span><span style="color:#9ECBFF">'sum'</span><span style="color:#E1E4E8">, {</span></span>
<span class="line"><span style="color:#E1E4E8">  get: sum,</span></span>
<span class="line"><span style="color:#E1E4E8">  enumerable: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  configurable: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(o.average, o.sum); </span><span style="color:#6A737D">// logs 2, 6</span></span></code></pre>
<h2 id="作为构造函数">作为构造函数</h2>
<p>当一个函数用作构造函数时（使用 new 关键字），它的 this 被绑定到正在构造的新对象。虽然构造器返回的默认值是 this 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 this 对象）</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#6A737D">/*</span></span>
<span class="line"><span style="color:#6A737D"> * 构造函数这样工作:</span></span>
<span class="line"><span style="color:#6A737D"> *</span></span>
<span class="line"><span style="color:#6A737D"> * function MyConstructor(){</span></span>
<span class="line"><span style="color:#6A737D"> *   // 函数实体写在这里</span></span>
<span class="line"><span style="color:#6A737D"> *   // 根据需要在this上创建属性，然后赋值给它们，比如：</span></span>
<span class="line"><span style="color:#6A737D"> *   this.fum = "nom";</span></span>
<span class="line"><span style="color:#6A737D"> *   // 等等...</span></span>
<span class="line"><span style="color:#6A737D"> *</span></span>
<span class="line"><span style="color:#6A737D"> *   // 如果函数具有返回对象的return语句，</span></span>
<span class="line"><span style="color:#6A737D"> *   // 则该对象将是 new 表达式的结果。</span></span>
<span class="line"><span style="color:#6A737D"> *   // 否则，表达式的结果是当前绑定到 this 的对象。</span></span>
<span class="line"><span style="color:#6A737D"> *   //（即通常看到的常见情况）。</span></span>
<span class="line"><span style="color:#6A737D"> * }</span></span>
<span class="line"><span style="color:#6A737D"> */</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> C</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#79B8FF">  this</span><span style="color:#E1E4E8">.a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 37</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> o </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> C</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(o.a); </span><span style="color:#6A737D">// logs 37</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> C2</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#79B8FF">  this</span><span style="color:#E1E4E8">.a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 37</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> { a: </span><span style="color:#79B8FF">38</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">o </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> C2</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(o.a); </span><span style="color:#6A737D">// logs 38</span></span></code></pre>
<h2 id="作为一个-dom-事件处理函数">作为一个 DOM 事件处理函数</h2>
<p>当函数被用作事件处理函数时，它的 this 指向触发事件的元素（一些浏览器在使用非 addEventListener 的函数动态添加监听函数时不遵守这个约定)</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#6A737D">// 被调用时，将关联的元素变成蓝色</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> bluify</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">e</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#F97583"> ===</span><span style="color:#E1E4E8"> e.currentTarget); </span><span style="color:#6A737D">// 总是 true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // 当 currentTarget 和 target 是同一个对象时为 true</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#F97583"> ===</span><span style="color:#E1E4E8"> e.target);</span></span>
<span class="line"><span style="color:#79B8FF">  this</span><span style="color:#E1E4E8">.style.backgroundColor </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> '#A5D9F3'</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 获取文档中的所有元素的列表</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> elements</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> document.</span><span style="color:#B392F0">getElementsByTagName</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'*'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> elements.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  elements[i].</span><span style="color:#B392F0">addEventListener</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'click'</span><span style="color:#E1E4E8">, bluify, </span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="作为一个内联事件处理函数">作为一个内联事件处理函数</h2>
<p>当代码被内联 on-event 处理函数调用时，它的 this 指向监听器所在的 DOM 元素</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="html"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> onclick</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"</span><span style="color:#B392F0">alert</span><span style="color:#9ECBFF">(</span><span style="color:#79B8FF">this</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">tagName</span><span style="color:#9ECBFF">.</span><span style="color:#B392F0">toLowerCase</span><span style="color:#9ECBFF">());"</span><span style="color:#E1E4E8">>Show this&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span></code></pre>
<p>注意只有外层代码中的 this 是这样设置的</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="html"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> onclick</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"</span><span style="color:#B392F0">alert</span><span style="color:#9ECBFF">((</span><span style="color:#F97583">function</span><span style="color:#9ECBFF">(){</span><span style="color:#F97583">return</span><span style="color:#79B8FF"> this</span><span style="color:#9ECBFF">})());"</span><span style="color:#E1E4E8">>Show inner this&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span></code></pre>
<p>在这种情况下，没有设置内部函数的 this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置 this 时指向的默认对象）</p> </div> <a class="flex gap-1 my-4 text-blue-600 cursor-pointer select-none" href="https://github.com/ckvv/ckvv.github.io/tree/main/content/javascript/js-this.md"> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" class="w-4">
  <path d="M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
  <path d="M18.375 2.625a2.121 2.121 0 1 1 3 3L12 15l-4 1 1-4Z" />
</svg>
Edit this page on GitHub
</a> <script src="https://giscus.app/client.js" data-repo="ckvv/ckvv.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzODQzNjA2OTQ=" data-category="Announcements" data-category-id="DIC_kwDOFujg9s4CpN2G" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
</script>  </main> </body></html>