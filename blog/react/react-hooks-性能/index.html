<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.ico"><meta name="generator" content="Astro v5.1.5"><!-- Canonical URL --><link rel="canonical" href="https://ckvv.net/blog/react/react-hooks-%E6%80%A7%E8%83%BD/"><!-- Primary Meta Tags --><title>React Hook 性能</title><meta name="title" content="React Hook 性能"><meta name="description" content="Welcome to my website!"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://ckvv.net/blog/react/react-hooks-%E6%80%A7%E8%83%BD/"><meta property="og:title" content="React Hook 性能"><meta property="og:description" content="Welcome to my website!"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://ckvv.net/blog/react/react-hooks-%E6%80%A7%E8%83%BD/"><meta property="twitter:title" content="React Hook 性能"><meta property="twitter:description" content="Welcome to my website!"><link rel="stylesheet" href="/_astro/about.DdOsgNx_.css">
<style>.outline-item-active[data-astro-cid-v2nb7cev]{color:#0284c7!important}
</style></head> <body class="flex flex-col"> <header class="sticky top-0 px-4 bg-white opacity-1 z-10 shadow-md"> <nav class="w-full max-w-6xl m-auto elect-none flex justify-between items-center text-2xl my-4"> <div class="flex gap-2 md:gap-4 items-center font-bold"> <h2><a href="/">CK Blog</a></h2> </div> <div class="flex gap-2 md:gap-4"> <a href="/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1"> Home <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-width duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="/tag/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1"> Tag <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-width duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="/assets/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center hidden md:inline"> Assets <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-width duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="/about/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1"> About <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-width duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="https://github.com/ckvv/ckvv.github.io" target="_blank" aria-label="GitHub" class="hidden md:inline"> <svg viewBox="0 0 32 32" role="img" width="32" height="32" fill="none">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16 0C7.16 0 0 7.16 0 16C0 23.08 4.58 29.06 10.94 31.18C11.74 31.32 12.04 30.84 12.04 30.42C12.04 30.04 12.02 28.78 12.02 27.44C8 28.18 6.96 26.46 6.64 25.56C6.46 25.1 5.68 23.68 5 23.3C4.44 23 3.64 22.26 4.98 22.24C6.24 22.22 7.14 23.4 7.44 23.88C8.88 26.3 11.18 25.62 12.1 25.2C12.24 24.16 12.66 23.46 13.12 23.06C9.56 22.66 5.84 21.28 5.84 15.16C5.84 13.42 6.46 11.98 7.48 10.86C7.32 10.46 6.76 8.82 7.64 6.62C7.64 6.62 8.98 6.2 12.04 8.26C13.32 7.9 14.68 7.72 16.04 7.72C17.4 7.72 18.76 7.9 20.04 8.26C23.1 6.18 24.44 6.62 24.44 6.62C25.32 8.82 24.76 10.46 24.6 10.86C25.62 11.98 26.24 13.4 26.24 15.16C26.24 21.3 22.5 22.66 18.94 23.06C19.52 23.56 20.02 24.52 20.02 26.02C20.02 28.16 20 29.88 20 30.42C20 30.84 20.3 31.34 21.1 31.18C27.42 29.06 32 23.06 32 16C32 7.16 24.84 0 16 0V0Z" fill="#24292E" />
</svg> </a> </div> </nav> </header> <main class="w-full max-w-5xl mx-auto px-4 py-8 flex-grow">  <h1 class="text-4xl font-bold my-4">React Hook 性能</h1> <div class="my-2 flex justify-between"> <div class="flex gap-4"> <a href="/tag/react/" class="bg-gray-100 hover:bg-gray-300 text-sky-700 px-2 py-1 rounded cursor-pointer"> react </a> </div> <span> 2024/08/24 </span> </div> <div class="content"> <div class="sticky z-10 top-20 inline-block text-left w-full" data-astro-cid-v2nb7cev><div class="2xl:hidden flex justify-end" data-astro-cid-v2nb7cev><button type="button" class="inline-flex justify-center gap-x-1.5 rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-900 hover:bg-gray-50" id="menu-button" aria-expanded="false" aria-haspopup="true" data-astro-cid-v2nb7cev>
On this page
<svg class="-mr-1 size-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" data-astro-cid-v2nb7cev><path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" data-astro-cid-v2nb7cev></path></svg></button></div><div id="md-outline-content" class="hidden absolute right-0 mt-2 max-w-full origin-top-right rounded-md bg-white ring-1 shadow-lg ring-black/5 focus:outline-hidden 2xl:-right-12 2xl:float-right 2xl:translate-x-full 2xl:max-w-[min(calc(50vw-580px),320px)]" aria-orientation="vertical" aria-labelledby="menu-button" tabindex="-1" data-astro-cid-v2nb7cev><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#usememo" data-astro-cid-v2nb7cev>useMemo</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#参考" data-astro-cid-v2nb7cev>参考</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#注意事项" data-astro-cid-v2nb7cev>注意事项</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#基础用法" data-astro-cid-v2nb7cev>基础用法</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#跳过组件的重新渲染" data-astro-cid-v2nb7cev>跳过组件的重新渲染</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#usecallback" data-astro-cid-v2nb7cev>useCallback</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#参考-1" data-astro-cid-v2nb7cev>参考</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#跳过组件的重新渲染-1" data-astro-cid-v2nb7cev>跳过组件的重新渲染</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#防止频繁触发-effect" data-astro-cid-v2nb7cev>防止频繁触发 Effect</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#优化自定义-hook" data-astro-cid-v2nb7cev>优化自定义 Hook</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#usetransition" data-astro-cid-v2nb7cev>useTransition</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#参考-2" data-astro-cid-v2nb7cev>参考</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#将状态更新标记为非阻塞的-transition" data-astro-cid-v2nb7cev>将状态更新标记为非阻塞的 transition</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#在-transition-中更新父组件" data-astro-cid-v2nb7cev>在 transition 中更新父组件</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#在-transition-中无法更新输入框内容" data-astro-cid-v2nb7cev>在 transition 中无法更新输入框内容</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#usedeferredvalue" data-astro-cid-v2nb7cev>useDeferredValue</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#参考-3" data-astro-cid-v2nb7cev>参考</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#延迟渲染-ui-的某些部分" data-astro-cid-v2nb7cev>延迟渲染 UI 的某些部分</a><a class="outline-item block px-4 py-1 text-sm !text-gray-600" href="#react-compiler-react-编译器" data-astro-cid-v2nb7cev>React Compiler (React 编译器)</a></div></div><script type="module">function g(e,r){let n,o;return(...i)=>{o?(clearTimeout(n),n=setTimeout(()=>{Date.now()-o>=r&&(e(...i),o=Date.now())},r-(Date.now()-o))):(e(...i),o=Date.now())}}function s(){const e=document.getElementById("menu-button"),r=document.getElementById("md-outline-content"),n=e.getAttribute("aria-expanded")==="true";e.setAttribute("aria-expanded",`${!n}`),r.style.display=n?"none":"block"}document.addEventListener("DOMContentLoaded",()=>{const e=window.innerWidth>=1536;e&&s();const r=document.getElementById("md-outline-content");r.onclick=t=>{t.preventDefault();const c=document.querySelector(t.target.getAttribute("href"));c&&window.scrollTo({top:c.offsetTop-64,behavior:"smooth"})};const n=document.getElementById("menu-button");n.onclick=s,document.onclick=t=>{if(e)return;const c=document.getElementById("md-outline-content");t.target.id!=="menu-button"&&!c.contains(t.target)&&n.getAttribute("aria-expanded")==="true"&&s()};const o=document.querySelector(".content").querySelectorAll("h1, h2, h3"),i=document.querySelectorAll(".outline-item"),l={root:null,rootMargin:"0px",threshold:.6},d=g(t=>{t.forEach(c=>{if(c.isIntersecting){const b=c.target.getAttribute("id");i.forEach(u=>{const a=`#${b}`;u.classList.remove("outline-item-active"),u.getAttribute("href")===a&&(u.classList.add("outline-item-active"),history.replaceState(null,"",a))})}})},200),m=new IntersectionObserver(d,l);o.forEach(t=>{m.observe(t)})});</script> <h2 id="usememo">useMemo</h2>
<p>把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p>
<h3 id="参考">参考</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> cachedValue</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(calculateValue, dependencies</span><span style="color:#F97583">?</span><span style="color:#E1E4E8">)</span></span></code></pre>
<p>参数</p>
<ul>
<li><code>calculateValue</code>：要缓存计算值的函数。它应该是一个没有任何参数的纯函数，并且可以返回任意类型。React 将会在首次渲染时调用该函数</li>
<li><code>dependencies</code>: 如果 dependencies 没有发生变化，React 将直接返回相同值。否则，将会再次调用 calculateValue 并返回最新结果，然后缓存该结果以便下次重复使用</li>
</ul>
<p>返回值</p>
<ul>
<li>不带参数调用 calculateValue 的结果, 如果依赖项没有发生改变，它将返回上次缓存的值</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴</li>
<li>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</li>
<li>**你只可以把 <code>useMemo</code> 作为性能优化的手段，但不要把它当成语义上的保证。**将来，React 可能会选择“遗忘”以前的一些 memoized 值并在下次渲染时重新计算它们</li>
<li>你不能在循环语句或条件语句中调用它</li>
<li>在严格模式下，为了 帮你发现意外的错误，React 将会 调用你的计算函数两次</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#6A737D">// 当a&#x26;b不变时返回memoizedValue（引用不变）</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> memoizedValue</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> computeExpensiveValue</span><span style="color:#E1E4E8">(a, b), [a, b]);</span></span></code></pre>
<h3 id="基础用法">基础用法</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> CountButton</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">label</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setLabel</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">count</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setCount</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">  // 如果依赖项label不变memoizedValue不会重新计算</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> memoizedValue</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> label.</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [label]);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      lable:</span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">input</span><span style="color:#B392F0"> type</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">"text"</span><span style="color:#B392F0"> onChange</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{</span><span style="color:#FFAB70">e</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> setLabel</span><span style="color:#E1E4E8">(e.target.value)} /></span></span>
<span class="line"><span style="color:#E1E4E8">      {memoizedValue}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> type</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">"button"</span><span style="color:#B392F0"> onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> setCount</span><span style="color:#E1E4E8">(count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">)}></span></span>
<span class="line"><span style="color:#E1E4E8">        count is:</span></span>
<span class="line"><span style="color:#E1E4E8">        {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">        {count}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="跳过组件的重新渲染">跳过组件的重新渲染</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#6A737D">// 当一个组件重新渲染时，React 会递归地重新渲染它的所有子组件</span></span>
<span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> TodoList</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">todos</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">tab</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">theme</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#6A737D">  // 每当主题发生变化时，这将是一个不同的数组……</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> visibleTodos</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> filterTodos</span><span style="color:#E1E4E8">(todos, tab);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">div</span><span style="color:#B392F0"> className</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{theme}></span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#6A737D">/* ... 所以List的props永远不会一样，每次都会重新渲染 */</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#79B8FF">List</span><span style="color:#B392F0"> items</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{visibleTodos} /></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><code>useMemo</code> 中，你可以确保它在重新渲染之间具有相同值，直到依赖项发生变化</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> TodoList</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">todos</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">tab</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">theme</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#6A737D">  // 告诉 React 在重新渲染之间缓存你的计算结果...</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> visibleTodos</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">    () </span><span style="color:#F97583">=></span><span style="color:#B392F0"> filterTodos</span><span style="color:#E1E4E8">(todos, tab),</span></span>
<span class="line"><span style="color:#E1E4E8">    [todos, tab] </span><span style="color:#6A737D">// ...所以只要这些依赖项不变...</span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">div</span><span style="color:#B392F0"> className</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{theme}></span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#6A737D">/* ... List 也就会接受到相同的 props 并且会跳过重新渲染 */</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#79B8FF">List</span><span style="color:#B392F0"> items</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{visibleTodos} /></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 你也可以将 &#x3C;List /> JSX 节点本身包裹在 useMemo 中</span></span>
<span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> TodoList</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">todos</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">tab</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">theme</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> visibleTodos</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> filterTodos</span><span style="color:#E1E4E8">(todos, tab), [todos, tab]);</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> children</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> &#x3C;</span><span style="color:#79B8FF">List</span><span style="color:#B392F0"> items</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{visibleTodos} />, [visibleTodos]);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">div</span><span style="color:#B392F0"> className</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{theme}></span></span>
<span class="line"><span style="color:#E1E4E8">      {children}</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="usecallback">useCallback</h2>
<p>在组件顶层调用 useCallback 以便在多次渲染中缓存函数, 该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用<code>引用相等性</code>去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p>
<h3 id="参考-1">参考</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#B392F0">useCallback</span><span style="color:#E1E4E8">(fn, dependencies);</span></span></code></pre>
<p>参数</p>
<ul>
<li><code>fn</code>：在多次渲染中需要缓存的函数, React 不会调用此函数，而是返回此函数。你可以自己决定何时调用以及是否调用</li>
<li><code>dependencies</code>: 函数内部需要使用到的所有组件内部值的 依赖列表，在其变化时会重新调用回调函数</li>
</ul>
<p>返回值</p>
<ul>
<li>在初次渲染时，返回 fn 函数，在之后的渲染中, 如果依赖没有改变，返回上一次渲染中缓存的 fn 函数；否则返回这一次渲染传入的 fn</li>
</ul>
<p>注意事项</p>
<ul>
<li>如果你忘记使用依赖数组，useCallback 每一次都将返回一个新的函数</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#6A737D">// ``useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> ProductPage</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">productId</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">referrer</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">theme</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#6A737D">  // 在多次渲染中缓存函数</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> handleSubmit</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useCallback</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">orderDetails</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    post</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`/product/${</span><span style="color:#E1E4E8">productId</span><span style="color:#9ECBFF">}/buy`</span><span style="color:#E1E4E8">, {</span></span>
<span class="line"><span style="color:#E1E4E8">      referrer,</span></span>
<span class="line"><span style="color:#E1E4E8">      orderDetails,</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [productId, referrer]); </span><span style="color:#6A737D">// 只要这些依赖没有改变</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">div</span><span style="color:#B392F0"> className</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{theme}></span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#6A737D">/* ShippingForm 就会收到同样的 props 并且跳过重新渲染 */</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#79B8FF">ShippingForm</span><span style="color:#B392F0"> onSubmit</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{handleSubmit} /></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<blockquote>
<p>依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能</p>
</blockquote>
<h3 id="跳过组件的重新渲染-1">跳过组件的重新渲染</h3>
<p>下面的例子中如果<code>const getLabel = () => label.toUpperCase();</code> 当count改变时会导致CountButton重新渲染，每次都会重新声明<code>getLabel</code>函数导致传递给Label组件的引用发生改变，引起不必要的渲染。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { useCallback, useEffect, useState } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> 'react'</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Label</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">getLabel</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#B392F0">  useEffect</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">    // 如果getLabel引用改变会导致useEffect执行</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'useEffect: getLabel'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [getLabel]);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">label</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      { </span><span style="color:#B392F0">getLabel</span><span style="color:#E1E4E8">() }</span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">label</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> CountButton</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">label</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setLabel</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">count</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setCount</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">  // 如果label未改变每次重新渲染，返回的getLabel引用值相同</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> getLabel</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useCallback</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> label.</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [label]);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      lable:</span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">input</span><span style="color:#B392F0"> type</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">"text"</span><span style="color:#B392F0"> onChange</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{</span><span style="color:#FFAB70">e</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> setLabel</span><span style="color:#E1E4E8">(e.target.value)} /></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> type</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">"button"</span><span style="color:#B392F0"> onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> setCount</span><span style="color:#E1E4E8">(count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">)}></span></span>
<span class="line"><span style="color:#E1E4E8">        count is:</span></span>
<span class="line"><span style="color:#E1E4E8">        {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">        {count}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#79B8FF">Label</span><span style="color:#B392F0"> getLabel</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{getLabel} /></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="防止频繁触发-effect">防止频繁触发 Effect</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> ChatRoom</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">roomId</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">message</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setMessage</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> createOptions</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useCallback</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      serverUrl: </span><span style="color:#9ECBFF">'https://localhost:1234'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">      roomId: roomId</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [roomId]); </span><span style="color:#6A737D">// ✅ 仅当 roomId 更改时更改, 避免每一次渲染中都会发生改变</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">  useEffect</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> options</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createOptions</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> connection</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createConnection</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    connection.</span><span style="color:#B392F0">connect</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> () </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> connection.</span><span style="color:#B392F0">disconnect</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [createOptions]); </span><span style="color:#6A737D">// ✅ 仅当 createOptions 更改时更改</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 最好消除对函数依赖项的需求</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> ChatRoom</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">roomId</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">message</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setMessage</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">  useEffect</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    function</span><span style="color:#B392F0"> createOptions</span><span style="color:#E1E4E8">() { </span><span style="color:#6A737D">// ✅ 无需使用回调或函数依赖！</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        serverUrl: </span><span style="color:#9ECBFF">'https://localhost:1234'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">        roomId: roomId</span></span>
<span class="line"><span style="color:#E1E4E8">      };</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> options</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createOptions</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> connection</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createConnection</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    connection.</span><span style="color:#B392F0">connect</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> () </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> connection.</span><span style="color:#B392F0">disconnect</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [roomId]); </span><span style="color:#6A737D">// ✅ 仅当 roomId 更改时更改</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="优化自定义-hook">优化自定义 Hook</h3>
<p>自定义 Hook，返回的任何函数最后包裹在 <code>useCallback</code> 中</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> useRouter</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> { </span><span style="color:#79B8FF">dispatch</span><span style="color:#E1E4E8"> } </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useContext</span><span style="color:#E1E4E8">(RouterStateContext);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> navigate</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useCallback</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">url</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    dispatch</span><span style="color:#E1E4E8">({ type: </span><span style="color:#9ECBFF">'navigate'</span><span style="color:#E1E4E8">, url });</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [dispatch]);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> goBack</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useCallback</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    dispatch</span><span style="color:#E1E4E8">({ type: </span><span style="color:#9ECBFF">'back'</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#E1E4E8">  }, [dispatch]);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    navigate,</span></span>
<span class="line"><span style="color:#E1E4E8">    goBack,</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="usetransition">useTransition</h2>
<h3 id="参考-2">参考</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">isPending</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">startTransition</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useTransition</span><span style="color:#E1E4E8">();</span></span></code></pre>
<p>参数</p>
<ul>
<li>无</li>
</ul>
<p>返回值</p>
<ul>
<li><code>isPending</code> 告诉你是否存在待处理的 transition。</li>
<li><code>startTransition</code> 函数(<strong>必须是同步的</strong>)，你可以使用此方法将状态更新标记为 transition （缓慢的重新渲染不会冻结用户界面）。</li>
</ul>
<p>注意事项</p>
<ul>
<li>useTransition 是一个 Hook，因此不能在组件外部调用</li>
<li>传递给 startTransition 的函数不会被延迟执行， 但是在它运行的同时安排的任何状态更新都被标记为 transition</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">startTransition</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">  setPage</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'/about'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 1 2 3</span></span></code></pre>
<h3 id="将状态更新标记为非阻塞的-transition">将状态更新标记为非阻塞的 transition</h3>
<p>transition 可以使用户界面的更新在慢速设备上仍保持响应性。通过 transition，UI 仍将在重新渲染过程中保持响应性。例如用户点击一个选项卡，但改变了主意并点击另一个选项卡，他们可以在不等待第一个重新渲染完成的情况下完成操作。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> TabContainer</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">isPending</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">startTransition</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useTransition</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">tab</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setTab</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'about'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> selectTab</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">nextTab</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    startTransition</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      setTab</span><span style="color:#E1E4E8">(nextTab);</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#6A737D">  // ……</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="在-transition-中更新父组件">在 transition 中更新父组件</h3>
<p>由于父组件的状态更新在 onClick 事件处理程序内，所以该状态更新会被标记为 transition, 由于更新选定选项卡被标记为了 transition，因此它不会阻止用户交互</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { useTransition } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> 'react'</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> TabButton</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">children</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">isActive</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">onClick</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">isPending</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">startTransition</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useTransition</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (isActive) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> &#x3C;</span><span style="color:#85E89D">b</span><span style="color:#E1E4E8">>{children}&#x3C;/</span><span style="color:#85E89D">b</span><span style="color:#E1E4E8">>;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#6A737D">  // isPending 布尔值来向用户表明当前处于 transition 中</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (isPending) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> &#x3C;</span><span style="color:#85E89D">b</span><span style="color:#B392F0"> className</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">"pending"</span><span style="color:#B392F0"> style</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{{ color: </span><span style="color:#9ECBFF">'red'</span><span style="color:#E1E4E8"> }}>{children}&#x3C;/</span><span style="color:#85E89D">b</span><span style="color:#E1E4E8">>;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      startTransition</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        onClick</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">      });</span></span>
<span class="line"><span style="color:#E1E4E8">    }}</span></span>
<span class="line"><span style="color:#E1E4E8">    ></span></span>
<span class="line"><span style="color:#E1E4E8">      {children}</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="在-transition-中无法更新输入框内容">在 transition 中无法更新输入框内容</h3>
<p>这是因为 transition 是非阻塞的，但是在响应更改事件时更新输入应该是同步的。如果想在输入时运行一个 transition，那么有两种做法：</p>
<ul>
<li>声明两个独立的状态变量：一个用于输入状态（它总是同步更新），另一个用于在 transition 中更新。这样，便可以使用同步状态控制输入，并将用于 transition 的状态变量（它将“滞后”于输入）传递给其余的渲染逻辑。</li>
<li>或者使用一个状态变量，并添加 useDeferredValue，它将“滞后”于实际值，并自动触发非阻塞的重新渲染以“追赶”新值。</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">text</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setText</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">// ...</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> handleChange</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">e</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">  // ❌ 不应将受控输入框的状态变量标记为 transition</span></span>
<span class="line"><span style="color:#B392F0">  startTransition</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    setText</span><span style="color:#E1E4E8">(e.target.value);</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#6A737D">// ...</span></span>
<span class="line"><span style="color:#F97583">return</span><span style="color:#E1E4E8"> &#x3C;</span><span style="color:#85E89D">input</span><span style="color:#B392F0"> value</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{text} </span><span style="color:#B392F0">onChange</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{handleChange} />;</span></span></code></pre>
<h2 id="usedeferredvalue">useDeferredValue</h2>
<p>延迟更新 UI 的某些部分, 被推迟的“后台”渲染是可中断的。例如，如果你再次在输入框中输入，React 将会中断渲染，并从新值开始重新渲染。React 总是使用最新提供的值。</p>
<h3 id="参考-3">参考</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> deferredValue</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useDeferredValue</span><span style="color:#E1E4E8">(value);</span></span></code></pre>
<p>参数</p>
<ul>
<li>value：你想延迟的值，可以是任何类型</li>
</ul>
<p>返回值</p>
<ul>
<li>在组件的初始渲染期间，返回的延迟值将与你提供的值相同。但是在组件更新时，React 将会先尝试使用旧值进行重新渲染（因此它将返回旧值），然后再在后台使用新值进行另一个重新渲染（这时它将返回更新后的值）</li>
</ul>
<h3 id="延迟渲染-ui-的某些部分">延迟渲染 UI 的某些部分</h3>
<p>当你的 UI 某个部分重新渲染很慢、没有简单的优化方法，同时你又希望避免它阻塞其他 UI 的渲染时，使用 useDeferredValue 很有帮助。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#6A737D">// 有一个文本框和一个组件（例如图表或长列表），在每次按键时都会重新渲染</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> App</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">text</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setText</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">input</span><span style="color:#B392F0"> value</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{text} </span><span style="color:#B392F0">onChange</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{</span><span style="color:#FFAB70">e</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> setText</span><span style="color:#E1E4E8">(e.target.value)} /></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#79B8FF">SlowList</span><span style="color:#B392F0"> text</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{text} /></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> SlowList</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> memo</span><span style="color:#E1E4E8">(({ </span><span style="color:#FFAB70">text</span><span style="color:#E1E4E8"> }) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  // ...</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre>
<p>当这些 props 不同 时，并且实际上需要展示不同的视觉输出时，页面会变得很慢,主要的性能问题在于，每次你输入内容时，SlowList 都会接收新的 props，并重新渲染整个树结构，这会让输入感觉很卡顿。使用 useDeferredValue 能够优先更新输入框（必须快速更新），而不是更新结果列表（可以更新慢一些）</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#6A737D">// 这并没有让 SlowList 的重新渲染变快。然而，它告诉 React 可以将列表的重新渲染优先级降低，这样就不会阻塞按键输入</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> App</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">text</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setText</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> deferredText</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useDeferredValue</span><span style="color:#E1E4E8">(text);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">input</span><span style="color:#B392F0"> value</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{text} </span><span style="color:#B392F0">onChange</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{</span><span style="color:#FFAB70">e</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> setText</span><span style="color:#E1E4E8">(e.target.value)} /></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#79B8FF">SlowList</span><span style="color:#B392F0"> text</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{deferredText} /></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="react-compiler-react-编译器">React Compiler (React 编译器)</h3>
<p>为了优化应用程序，React Compiler 之前 我们需要通过useMemo、useCallback 和 React.memo 等 API 你可以告诉 React 如果它们的输入没有改变，你的应用程序的某些部分就不需要重新计算，从而减少了更新的工作。虽然功能强大，但很容易忘记应用记忆化或错误地应用它们。
React Compiler 是一个新的实验性编译器, 编译器利用其 JavaScript 和 React 规则的知识来自动记住组件和 hook 中的值或值组。如果它检测到规则的破坏，它将自动跳过这些组件或 hook，并继续安全地编译其他代码。</p>
<p>在 Vite 中启用</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="ts"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> react </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> '@vitejs/plugin-react'</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { defineConfig } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> 'vite'</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> ReactCompilerConfig</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> { </span><span style="color:#6A737D">/* ... */</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#B392F0"> defineConfig</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    plugins: [</span></span>
<span class="line"><span style="color:#B392F0">      react</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">        babel: {</span></span>
<span class="line"><span style="color:#E1E4E8">          plugins: [</span></span>
<span class="line"><span style="color:#E1E4E8">            [</span><span style="color:#9ECBFF">'babel-plugin-react-compiler'</span><span style="color:#E1E4E8">, ReactCompilerConfig],</span></span>
<span class="line"><span style="color:#E1E4E8">          ],</span></span>
<span class="line"><span style="color:#E1E4E8">        },</span></span>
<span class="line"><span style="color:#E1E4E8">      }),</span></span>
<span class="line"><span style="color:#E1E4E8">    ],</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 现在打开 React Devtools （v5.0+） 即可看到组件旁边显示 “Memo ✨ ”</span></span></code></pre>
<p>其他用法参考官网<a href="https://react.dev/learn/react-compiler">https://react.dev/learn/react-compiler</a></p> </div> <div id="cusdis_thread" class="mt-12" data-host="https://cusdis.com" data-app-id="c2b015f9-9a4b-4997-b66f-f9c6ca26ebdd" data-page-id="content/react/react-hooks-性能.md" data-page-url="content/react/react-hooks-性能.md" data-page-title="React Hook 性能" data-iframe="/js/cusdis/iframe.umd.js" data-style="/js/cusdis/style.css"></div> <script>
window.CUSDIS_LOCALE = {
  powered_by: '',
  post_comment: '发送',
  loading: '加载中...',
  // comment
  email: '邮箱(可选)',
  nickname: '昵称',
  reply_placeholder: '内容',
  reply_btn: '回复',
  sending: '发送中...',
  // reply
  mod_badge: '管理员',
  content_is_required: '内容不能为空',
  nickname_is_required: '昵称不能为空',
  comment_has_been_sent: '评论已发送, 管理员审核通过后会展示',
};
</script> <script async src="/js/cusdis/cusdis.min.js"></script>  </main> </body></html>