<!DOCTYPE html><html lang="zh-CN" class="h-full bg-white"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.ico"><meta name="generator" content="Astro v5.7.12"><!-- Canonical URL --><link rel="canonical" href="https://ckvv.net/blog/react/react-hooks-state/"><!-- Primary Meta Tags --><title>React Hook State</title><meta name="title" content="React Hook State"><meta name="description" content="I am a Web full-stack engineer. I like Vue.js and Node.js. This is my blog, where I mainly share my thoughts, experiences, or knowledge."><link rel="stylesheet" href="/_astro/about.B0Cw6WDJ.css">
<style>.outline-item-active[data-astro-cid-v2nb7cev]{color:var(--color-sky-700)}
</style></head> <body class="flex flex-col min-h-full"> <header class="sticky top-0 px-4 bg-white z-50 shadow-md"> <nav class="w-full max-w-6xl m-auto elect-none flex justify-between items-center text-2xl my-3 md:my-4"> <div class="flex gap-2 md:gap-4 items-center font-bold"> <h2><a href="/">CK Blog</a></h2> </div> <span data-astro-button-menu class="md:hidden select-none cursor-pointer text-3xl leading-none">☰</span> <div class="z-20 md:visible! flex gap-2 md:gap-4 flex-col md:flex-row max-md:absolute max-md:bg-white max-md:left-0 max-md:right-0 max-md:top-14 max-md:gap-4 max-md:py-6 max-md:shadow max-md:border-t max-md:border-gray-300 max-md:invisible"> <a href="/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1 justify-center"> Home <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-[width] duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a><a href="/tag/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1 justify-center"> Tag <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-[width] duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a><a href="/assets/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1 justify-center"> Assets <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-[width] duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a><a href="/about/" class="group clink cursor-pointer shrink-0 select-none relative flex items-center px-1 justify-center"> About <div class="h-1 bg-blue-500 w-0 group-hover:w-full transition-[width] duration-500 ease-in-out absolute -bottom-1 left-0" style=""></div> </a> <a href="https://github.com/ckvv/ckvv.github.io" target="_blank" aria-label="GitHub"> <svg width="32" height="32" viewBox="0 0 32 32" fill="none" class="m-auto">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16 0C7.16 0 0 7.16 0 16C0 23.08 4.58 29.06 10.94 31.18C11.74 31.32 12.04 30.84 12.04 30.42C12.04 30.04 12.02 28.78 12.02 27.44C8 28.18 6.96 26.46 6.64 25.56C6.46 25.1 5.68 23.68 5 23.3C4.44 23 3.64 22.26 4.98 22.24C6.24 22.22 7.14 23.4 7.44 23.88C8.88 26.3 11.18 25.62 12.1 25.2C12.24 24.16 12.66 23.46 13.12 23.06C9.56 22.66 5.84 21.28 5.84 15.16C5.84 13.42 6.46 11.98 7.48 10.86C7.32 10.46 6.76 8.82 7.64 6.62C7.64 6.62 8.98 6.2 12.04 8.26C13.32 7.9 14.68 7.72 16.04 7.72C17.4 7.72 18.76 7.9 20.04 8.26C23.1 6.18 24.44 6.62 24.44 6.62C25.32 8.82 24.76 10.46 24.6 10.86C25.62 11.98 26.24 13.4 26.24 15.16C26.24 21.3 22.5 22.66 18.94 23.06C19.52 23.56 20.02 24.52 20.02 26.02C20.02 28.16 20 29.88 20 30.42C20 30.84 20.3 31.34 21.1 31.18C27.42 29.06 32 23.06 32 16C32 7.16 24.84 0 16 0V0Z" fill="#24292E" />
</svg> </a> </div> </nav> </header> <script type="module">document.querySelector("[data-astro-button-menu]")?.addEventListener("click",e=>{const t=e.target?.nextElementSibling;t&&(getComputedStyle(t).visibility==="hidden"?(e.target.textContent="✕",t.style.visibility="visible"):(e.target.textContent="☰",t.style.visibility="hidden"))});</script> <main class="w-full max-w-5xl mx-auto px-4 py-8 flex-grow font-tabular-nums">  <h1 class="text-4xl font-bold my-4">React Hook State</h1>
  <div class="my-2 flex justify-between items-center"><div class="flex gap-4"><a href="/tag/react/" class="bg-gray-100 hover:bg-gray-300 text-sky-700 px-2 py-1 rounded cursor-pointer"> react </a></div><span class="tabular-nums"> 2024/08/24 </span></div>
  <div class="sticky z-10 top-20 inline-block text-left w-full" data-astro-cid-v2nb7cev><div class="2xl:hidden flex justify-end" data-astro-cid-v2nb7cev><button type="button" class="shadow-md inline-flex justify-center gap-x-1.5 rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-900 hover:bg-gray-50" id="menu-button" aria-expanded="false" aria-haspopup="true" data-astro-cid-v2nb7cev>
On this page
<svg class="-mr-1 size-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" data-astro-cid-v2nb7cev><path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" data-astro-cid-v2nb7cev></path></svg></button></div><div id="md-outline-content" class="max-h-[calc(100vh-200px)] overflow-auto hidden absolute right-0 py-2 mt-2 min-w-48 max-w-full origin-top-right rounded-md bg-white ring-1 shadow-lg ring-black/5 focus:outline-hidden 2xl:-right-12 2xl:float-right 2xl:translate-x-full 2xl:max-w-[min(calc(50vw-580px),320px)]" aria-orientation="vertical" aria-labelledby="menu-button" tabindex="-1" data-astro-cid-v2nb7cev><a class="outline-item block px-4 py-1 text-sm break-all" href="#usestate" data-astro-cid-v2nb7cev>useState</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#基础用法" data-astro-cid-v2nb7cev>基础用法</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#更新状态中的对象和数组" data-astro-cid-v2nb7cev>更新状态中的对象和数组</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#使用-immer-编写简洁的更新逻辑" data-astro-cid-v2nb7cev>使用 Immer 编写简洁的更新逻辑</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#函数式更新" data-astro-cid-v2nb7cev>函数式更新</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#惰性初始-state" data-astro-cid-v2nb7cev>惰性初始 state</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#跳过-state-更新" data-astro-cid-v2nb7cev>跳过 state 更新</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#使用-key-重置-state-状态" data-astro-cid-v2nb7cev>使用 key 重置 state 状态</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#存储前一次渲染的信息" data-astro-cid-v2nb7cev>存储前一次渲染的信息</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#存储一个函数" data-astro-cid-v2nb7cev>存储一个函数</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#注意事项" data-astro-cid-v2nb7cev>注意事项</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#usereducer" data-astro-cid-v2nb7cev>useReducer</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#基础用法-1" data-astro-cid-v2nb7cev>基础用法</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#惰性初始化" data-astro-cid-v2nb7cev>惰性初始化</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#跳过-dispatch" data-astro-cid-v2nb7cev>跳过 dispatch</a><a class="outline-item block px-4 py-1 text-sm break-all" href="#避免重新创建初始值" data-astro-cid-v2nb7cev>避免重新创建初始值</a></div></div><script type="module">function f(n,o){let r,t;return(...c)=>{t?(clearTimeout(r),r=setTimeout(()=>{Date.now()-t>=o&&(n(...c),t=Date.now())},o-(Date.now()-t))):(n(...c),t=Date.now())}}function u(n){const o=document.getElementById("menu-button"),r=document.getElementById("md-outline-content"),t=n===void 0?o.getAttribute("aria-expanded")==="true":!n;o.setAttribute("aria-expanded",`${!t}`),r.style.display=t?"none":"block"}function l(){window.innerWidth>=1536&&u(!0)}window.addEventListener("resize",l);document.addEventListener("DOMContentLoaded",()=>{l();const n=document.getElementById("md-outline-content");n.onclick=e=>{e.preventDefault();const i=document.querySelector(e.target.getAttribute("href"));i&&window.scrollTo({top:i.offsetTop-64,behavior:"smooth"})};const o=document.getElementById("menu-button");o.onclick=()=>u(),document.onclick=e=>{if(window.innerWidth>=1536)return;const i=document.getElementById("md-outline-content");e.target.id!=="menu-button"&&!i.contains(e.target)&&o.getAttribute("aria-expanded")==="true"&&u()};const r=document.querySelector(".content").querySelectorAll("h1, h2, h3"),t=document.querySelectorAll(".outline-item"),c={root:null,rootMargin:"0px",threshold:.6},a=f(e=>{e.forEach(i=>{if(i.isIntersecting){const b=i.target.getAttribute("id");t.forEach(s=>{const d=`#${b}`;s.classList.remove("outline-item-active"),s.getAttribute("href")===d&&(s.classList.add("outline-item-active"),history.replaceState(null,"",d))})}})},200),m=new IntersectionObserver(a,c);r.forEach(e=>{m.observe(e)})});</script><div class="content"> <h2 id="usestate">useState</h2>
<p>在函数组件中存储内部 state</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">state</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setState</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(initialState);</span></span></code></pre>
<p>参数:</p>
<ul>
<li><code>initialState</code>: state初始值, 如果传递函数作为 <code>initialState</code>，则它将被视为初始化函数。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。</li>
</ul>
<p>返回值:</p>
<ul>
<li><code>state</code>: 当前的 state</li>
<li><code>setState</code>: 更新 state 的方法, 它接收一个新的 state 值并将组件的一次重新渲染加入队列。如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过</li>
</ul>
<h3 id="基础用法">基础用法</h3>
<p>这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Counter</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">props</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">count</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setCount</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(props.initialCount);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> type</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">"button"</span><span style="color:#B392F0"> onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> setCount</span><span style="color:#E1E4E8">(count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">)}></span></span>
<span class="line"><span style="color:#E1E4E8">      count is:</span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      {count}</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">Counter.defaultProps </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  initialCount: </span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>值得注意的是，类似class 组件中的<code>setState</code>,在我们执行<code>setCount</code>时count的值不是立即更新的，而是在下一个重渲染时才会更新，后调用的 <code>setCount()</code> 将覆盖同一周期内先调用 setCount 的值。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#6A737D">// 所以如在同一周期内多次执行setCount</span></span>
<span class="line"><span style="color:#B392F0">setCount</span><span style="color:#E1E4E8">(count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">setCount</span><span style="color:#E1E4E8">(count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">setCount</span><span style="color:#E1E4E8">(count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">// 这相当于setCount(count + 1);</span></span></code></pre>
<p>因此count数仅增加一,解决办法可以参考<code>函数式更新</code></p>
<h3 id="更新状态中的对象和数组">更新状态中的对象和数组</h3>
<p>当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份）</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">position</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setPosition</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  x: </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  y: </span><span style="color:#79B8FF">0</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">setPosition</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  x: e.clientX,</span></span>
<span class="line"><span style="color:#E1E4E8">  y: e.clientY</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">setPosition</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#F97583">  ...</span><span style="color:#E1E4E8">position,</span></span>
<span class="line"><span style="color:#E1E4E8">  y: e.clientY</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre>
<h3 id="使用-immer-编写简洁的更新逻辑">使用 Immer 编写简洁的更新逻辑</h3>
<p>由 Immer 提供的 draft 是一种特殊类型的对象，被称为 Proxy，它会记录你用它所进行的操作。这就是你能够随心所欲地直接修改对象的原因所在！从原理上说，Immer 会弄清楚 draft 对象的哪些部分被改变了，并会依照你的修改创建出一个全新的对象。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { useImmer } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> 'use-immer'</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">person</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">updatePerson</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useImmer</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  name: </span><span style="color:#9ECBFF">'Niki de Saint Phalle'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  artwork: {</span></span>
<span class="line"><span style="color:#E1E4E8">    title: </span><span style="color:#9ECBFF">'Blue Nana'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    city: </span><span style="color:#9ECBFF">'Hamburg'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    image: </span><span style="color:#9ECBFF">'https://i.imgur.com/Sd1AgUOm.jpg'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">updatePerson</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">draft</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  draft.name </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> e.target.value;</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre>
<h3 id="函数式更新">函数式更新</h3>
<p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给State Hook 的更新函数，该回调函数将接收先前的 state，并返回一个更新后的值。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#B392F0">setCount</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">count</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">);</span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#B392F0">setCount</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">count</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">setCount</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">count</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">setCount</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">count</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">// 这相当于setCount(count + 4);</span></span></code></pre>
<p>与 class 组件中的 <code>setState</code> 方法不同，<code>setState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code> 结合展开运算符来达到合并更新对象的效果。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">people</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setPeople</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  age: </span><span style="color:#79B8FF">18</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  name: </span><span style="color:#9ECBFF">'小红'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">setPeople</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  age: people.age </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 不会自动合并更新对象</span></span>
<span class="line"><span style="color:#6A737D">// people {age: 18}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">setPeople</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">prevState</span><span style="color:#F97583"> =></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  ..prevState,</span></span>
<span class="line"><span style="color:#B392F0">  age</span><span style="color:#E1E4E8">: prevState.age </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// people {age: 19, name: '小红'}</span></span></code></pre>
<h3 id="惰性初始-state">惰性初始 state</h3>
<p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用（在严格模式中，React 将两次调用初始化函数）。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">state</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setState</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> initialState</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> someExpensiveComputation</span><span style="color:#E1E4E8">(props);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> initialState;</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre>
<h3 id="跳过-state-更新">跳过 state 更新</h3>
<p>如果您将 State Hook 更新为与当前状态相同的值，React 将跳过子组件的渲染及 effect 的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description">Object.is</a> 来比较 state）</p>
<p>如下面由于<code>Object.is</code>对比前后两次的state值未改变(引用内存中的同一个对象),所以未触发组件的更新。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> CountButton</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> countObj</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    value: </span><span style="color:#79B8FF">18</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">count</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setCount</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(countObj);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">button</span></span>
<span class="line"><span style="color:#B392F0">        type</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">"button"</span></span>
<span class="line"><span style="color:#B392F0">        onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">          countObj.value</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">          console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(countObj);</span></span>
<span class="line"><span style="color:#B392F0">          setCount</span><span style="color:#E1E4E8">(countObj);</span></span>
<span class="line"><span style="color:#6A737D">          // setCount({...countObj}); 如果想要触发更新可以这样做</span></span>
<span class="line"><span style="color:#E1E4E8">        }}</span></span>
<span class="line"><span style="color:#E1E4E8">      ></span></span>
<span class="line"><span style="color:#E1E4E8">        count is:</span></span>
<span class="line"><span style="color:#E1E4E8">        {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">        {count.value}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="使用-key-重置-state-状态">使用 key 重置 state 状态</h3>
<p>当在相同的位置渲染相同的组件时，React 会保留状态。通过 key 传递给 组件，每当 key 变化时，React 将重新创建 DOM，并 重置 组件和它的所有子组件的 state</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> ProfilePage</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">userId</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#79B8FF">Profile</span></span>
<span class="line"><span style="color:#B392F0">      userId</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{userId}</span></span>
<span class="line"><span style="color:#B392F0">      key</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{userId}</span></span>
<span class="line"><span style="color:#E1E4E8">    /></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Profile</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">userId</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#6A737D">  // ✅ 当 key 变化时，该组件内的 comment 或其他 state 会自动被重置</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">comment</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setComment</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">  // ...</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="存储前一次渲染的信息">存储前一次渲染的信息</h3>
<p>当你在渲染期间调用 set 函数时，React 将在你的组件使用 return 语句退出后立即重新渲染该组件，<strong>并在渲染子组件前进行</strong>。这样，子组件就不需要进行两次渲染。你的组件函数的其余部分仍会执行（然后结果将被丢弃）。如果你的条件判断在所有 Hook 调用的下方，可以提前添加一个 return; 以便更早地重新开始渲染。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> CountLabel</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">count</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">prevCount</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setPrevCount</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(count);</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">trend</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setTrend</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // 在渲染时调用 set 函数时，它必须位于条件语句中，例如 prevCount !== count，并且必须在该条件语句中调用 setPrevCount(count)。否则，你的组件将在循环中重新渲染</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (prevCount </span><span style="color:#F97583">!==</span><span style="color:#E1E4E8"> count) {</span></span>
<span class="line"><span style="color:#B392F0">    setPrevCount</span><span style="color:#E1E4E8">(count);</span></span>
<span class="line"><span style="color:#B392F0">    setTrend</span><span style="color:#E1E4E8">(count </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> prevCount </span><span style="color:#F97583">?</span><span style="color:#9ECBFF"> 'increasing'</span><span style="color:#F97583"> :</span><span style="color:#9ECBFF"> 'decreasing'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">h1</span><span style="color:#E1E4E8">>{count}&#x3C;/</span><span style="color:#85E89D">h1</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      {trend </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">        &#x3C;</span><span style="color:#85E89D">p</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">          The count is</span></span>
<span class="line"><span style="color:#E1E4E8">          {trend}</span></span>
<span class="line"><span style="color:#E1E4E8">        &#x3C;/</span><span style="color:#85E89D">p</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      )}</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="存储一个函数">存储一个函数</h3>
<p>你不能像这样把函数放入状态</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">fn</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setFn</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(someFunction);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> handleClick</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">  setFn</span><span style="color:#E1E4E8">(someOtherFunction);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>React 认为 someFunction 是一个 初始化函数，而 someOtherFunction 是一个 更新函数，于是它尝试调用它们并存储结果。要实际 存储 一个函数，你必须在两种情况下在它们之前加上 <code>() =></code>。然后 React 将存储你传递的函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">fn</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setFn</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> someFunction);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> handleClick</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">  setFn</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> someOtherFunction);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>set 函数 仅更新 下一次 渲染的状态变量。如果在调用 set 函数后读取状态变量，则 仍会得到在调用之前显示在屏幕上的旧值。</li>
<li>如果你提供的新值与当前 state 相同（由 Object.is 比较确定），React 将 跳过重新渲染该组件及其子组件。</li>
<li>React 会批量处理状态更新。它会在所有事件处理函数运行 并调用其 <code>set</code> 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。如果你需要强制 React 更早地更新屏幕，例如访问 DOM，你可以使用 <code>flushSync</code></li>
<li>在渲染期间，只允许在当前渲染组件内部调用 set 函数。React 将丢弃其输出并立即尝试使用新状态重新渲染。你可以使用它来存储 先前渲染中的信息</li>
<li>在严格模式中（开发环境），React 将 两次调用你的更新函数</li>
</ul>
<h2 id="usereducer">useReducer</h2>
<p>对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新逻辑整合到一个外部函数中, 这个函数叫作 reducer。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="tsx"><code><span class="line"><span style="color:#B392F0">useReducer</span><span style="color:#E1E4E8">(reducer, initialArg, init</span><span style="color:#F97583">?</span><span style="color:#E1E4E8">)</span></span></code></pre>
<p>参数</p>
<ul>
<li>reducer <code>(state, action) => state</code>：用于更新 state 的纯函数。参数为 <code>state</code> 和 <code>action</code>，返回值是更新后的 state。state 与 action 可以是任意合法值。</li>
<li>initialArg：用于初始化 state 的任意值。初始值的计算逻辑取决于接下来的 init 参数。</li>
<li>init：用于计算初始值的函数。如果存在，使用 <code>init(initialArg)</code> 的执行结果作为初始值，否则使用 <code>initialArg</code>。</li>
</ul>
<p>返回值</p>
<ul>
<li>当前的 state。初次渲染时，它是 init(initialArg) 或 initialArg （如果没有 init 函数）。</li>
<li>dispatch <code>(action) => void</code> 函数。用于更新 state 并触发组件的重新渲染</li>
</ul>
<p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p>
<blockquote>
<p><code>dispatch</code> 不会在重新渲染之间变化,所以可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code></p>
</blockquote>
<h3 id="基础用法-1">基础用法</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> initialState</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> { count: </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> reducer</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">state</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">action</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  switch</span><span style="color:#E1E4E8"> (action.type) {</span></span>
<span class="line"><span style="color:#F97583">    case</span><span style="color:#9ECBFF"> 'increment'</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> { count: state.count </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">    case</span><span style="color:#9ECBFF"> 'decrement'</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> { count: state.count </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">    default</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#F97583">      throw</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Counter</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">state</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">dispatch</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useReducer</span><span style="color:#E1E4E8">(reducer, initialState);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;></span></span>
<span class="line"><span style="color:#E1E4E8">      Count:</span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      {state.count}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> dispatch</span><span style="color:#E1E4E8">({ type: </span><span style="color:#9ECBFF">'decrement'</span><span style="color:#E1E4E8"> })}>-&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> dispatch</span><span style="color:#E1E4E8">({ type: </span><span style="color:#9ECBFF">'increment'</span><span style="color:#E1E4E8"> })}>+&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="惰性初始化">惰性初始化</h3>
<p>你可以选择惰性地创建初始 state。为此，需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 state 将被设置为 <code>init(initialArg)</code></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">state</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">dispatch</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useReducer</span><span style="color:#E1E4E8">(reducer, initialArg, init);</span></span>
<span class="line"><span style="color:#6A737D">// state = init(initialArg);</span></span></code></pre>
<h3 id="跳过-dispatch">跳过 dispatch</h3>
<p>与<code>useState</code>类似，如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> initialState</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> { count: </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> reducer</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">state</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">action</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  switch</span><span style="color:#E1E4E8"> (action.type) {</span></span>
<span class="line"><span style="color:#F97583">    case</span><span style="color:#9ECBFF"> 'increment'</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#6A737D">      // ❌ Object.is 判断返回state相同，所以将跳过子组件的渲染及副作用的执行</span></span>
<span class="line"><span style="color:#E1E4E8">      state.count</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> state;</span></span>
<span class="line"><span style="color:#F97583">    case</span><span style="color:#9ECBFF"> 'decrement'</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">      state.count</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> state;</span></span>
<span class="line"><span style="color:#F97583">    default</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#F97583">      throw</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Counter</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">state</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">dispatch</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useReducer</span><span style="color:#E1E4E8">(reducer, initialState);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;></span></span>
<span class="line"><span style="color:#E1E4E8">      Count:</span></span>
<span class="line"><span style="color:#E1E4E8">      {</span><span style="color:#9ECBFF">' '</span><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">      {state.count}</span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> dispatch</span><span style="color:#E1E4E8">({ type: </span><span style="color:#9ECBFF">'decrement'</span><span style="color:#E1E4E8"> })}>-&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">      &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> onClick</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{() </span><span style="color:#F97583">=></span><span style="color:#B392F0"> dispatch</span><span style="color:#E1E4E8">({ type: </span><span style="color:#9ECBFF">'increment'</span><span style="color:#E1E4E8"> })}>+&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/></span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="避免重新创建初始值">避免重新创建初始值</h3>
<p>与<code>useState</code>类似</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#6A737D">// 每一次渲染的时候都会被调用</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> createInitialState</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">username</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">  // ...</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> TodoList</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">username</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">state</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">dispatch</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useReducer</span><span style="color:#E1E4E8">(reducer, </span><span style="color:#B392F0">createInitialState</span><span style="color:#E1E4E8">(username));</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>你可以通过给  useReducer 的第三个参数传入 初始化函数 来解决这个问题：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="jsx"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> TodoList</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">username</span><span style="color:#E1E4E8"> }) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">state</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">dispatch</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useReducer</span><span style="color:#E1E4E8">(reducer, username, createInitialState);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre> </div> <a class="flex gap-1 my-4 text-blue-600 cursor-pointer select-none" href="https://github.com/ckvv/ckvv.github.io/tree/main/content/react/react-hooks-state.md"> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" class="w-4">
  <path d="M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
  <path d="M18.375 2.625a2.121 2.121 0 1 1 3 3L12 15l-4 1 1-4Z" />
</svg>
Edit this page on GitHub
</a> <script src="https://giscus.app/client.js" data-repo="ckvv/ckvv.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzODQzNjA2OTQ=" data-category="Announcements" data-category-id="DIC_kwDOFujg9s4CpN2G" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
</script>  </main> </body></html>