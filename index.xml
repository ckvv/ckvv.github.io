<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CK's Blog</title><link>https://blog.chenkai.life/</link><description>Recent content on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 23 Jul 2021 15:48:36 +0800</lastBuildDate><atom:link href="https://blog.chenkai.life/index.xml" rel="self" type="application/rss+xml"/><item><title>git</title><link>https://blog.chenkai.life/tools/git/</link><pubDate>Fri, 23 Jul 2021 15:48:36 +0800</pubDate><guid>https://blog.chenkai.life/tools/git/</guid><description>更新git yum
#安装源 yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm #安装git yum install git #更新git yum update git sourceTree修改大小写 sourceTree对文件名称的大小写不敏感，当你修改文件名称的大小写进行提交时，它并不能识别,
git mv work.js Work.js sourceTree回滚到历史节点 点击要回滚的历史节点，重置到历史节点，选择硬合并； 点击当前节点，重置到当前节点，选择软合并； 提交修改内容； git reset --hard e377f60e28c8b84158 git push -f origin develop git回滚 //产看git提交的id git log //查看当前分支 git status //本地重置到当前分支 git reset --hard 7c1eb09abaf873483359883175e31e979d216db0 //推送当前分支到远程 git push -f git提交规范 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：修改构建过程或辅助工具的变动，添加依赖库、工具等 perf: 代码重构。没有新功能或修复bug，优化相关，提升性能体验 revery 回滚上一个版本 &amp;mdash;写代码&amp;mdash;</description></item><item><title>关于我</title><link>https://blog.chenkai.life/about/</link><pubDate>Fri, 16 Jul 2021 13:16:11 +0800</pubDate><guid>https://blog.chenkai.life/about/</guid><description>如果你有什么问题，请联系我或在下方留言。
联系方式 WeChat: chenkai-180 Email: k_0520@qq.com GitHub: https://github.com/chenkai0520 仓库地址 Repository: chenkai0520.github.io</description></item><item><title>node调用系统命令</title><link>https://blog.chenkai.life/nodejs/node_run_command/</link><pubDate>Thu, 15 Jul 2021 11:28:21 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/node_run_command/</guid><description>const exec = require(&amp;#39;util&amp;#39;).promisify(require(&amp;#39;child_process&amp;#39;).exec); async function run(command) { const { stdout, stderr } = await exec(command); if (stderr) { return { code:1, data:stderr }; } if (stdout) { return { code:0, data:stdout }; } } (async ()=&amp;gt;{ let result = await run(&amp;#39;cd ../ &amp;amp;&amp;amp; ls&amp;#39;); let result2 = await run(&amp;#39;wc -l index.js&amp;#39;); console.log(result) console.log(result2) })()</description></item><item><title>Git 子模块</title><link>https://blog.chenkai.life/tools/git_submodule/</link><pubDate>Wed, 14 Jul 2021 18:10:58 +0800</pubDate><guid>https://blog.chenkai.life/tools/git_submodule/</guid><description>转载自https://www.atlassian.com/git/tutorials/git-submodule
Git子模块(git submodule)允许您将git存储库作为另一个git存储库的子目录。 Git子模块只是对特定时间快照中另一个存储库的引用。 Git子模块使Git存储库能够合并和跟踪外部代码的版本历史记录。
如果您需要对外部依赖项进行严格的版本管理，那么使用 git 子模块是有意义的。
什么是 Git子模块 通常，代码存储库将依赖于外部代码。可以通过几种不同的方式合并此外部代码。外部代码可以直接复制粘贴到主存储库中。这种方法的缺点是会丢失对外部存储库的任何上游更改。合并外部代码的另一种方法是使用语言的包管理系统，如 Ruby Gems 或 NPM。这种方法的缺点是需要在部署源代码的所有位置进行安装和版本管理。这两种建议的合并方法都不能跟踪对外部存储库的编辑和更改。
git 子模块是宿主 git 存储库中的一条记录，它指向另一个外部存储库中的特定提交。子模块非常静态，只跟踪特定的提交。子模块不跟踪 git refs 或分支，并且不会在主机存储库更新时自动更新。将子模块添加到存储库时，将创建一个新的 .gitmodules 文件。 .gitmodules 文件包含有关子模块项目的 URL 和本地目录之间映射的元数据。如果主机存储库有多个子模块，则 .gitmodules 文件将为每个子模块提供一个条目.
Add git submodule The git submodule add is used to add a new submodule to an existing repository. The following is an example that creates an empty repo and explores git submodules.</description></item><item><title>node http请求解析</title><link>https://blog.chenkai.life/nodejs/node-http_analys/</link><pubDate>Sat, 10 Jul 2021 11:03:22 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/node-http_analys/</guid><description>本指南的宗旨将让你对 HTTP 传输处理有一个清晰完整的了解。在不考虑特定编程语言及开发环境下，我们假设你已经知道在一般情况下 HTTP 是如何进行工作的。我们同样假定你熟悉 Node.js 的 EventEmitters 和 Streams。当然，如果你确实不了解它们，我们强烈建议你把以上列出的内容快速而完整地阅读一遍。
创建一个后台服务 任何网络服务应用程序总是要先创建一个服务对象。这在 Node.js 中通常通过 createServer 方法。
const http = require(&amp;#39;http&amp;#39;); const server = http.createServer((request, response) =&amp;gt; { // magic happens here! }); 每当有 HTTP 请求到达服务器时，createServer 中传入的函数就被自动执行。所以这个函数也被称为是请求处理函数。实际上，由 createServer 构造函数返回的 Server 对象是一个 EventEmitter，我们在这里仅是对创建 server 和对它添加监听事件进行了简化处理。
const server = http.createServer(); server.on(&amp;#39;request&amp;#39;, (request, response) =&amp;gt; { // the same kind of magic happens here! }); 当一个 HTTP 到达服务端，node 调用 request 处理程序，并产生一些唾手可得的对象用以处理传输，这些对象就是 request 和 response。我们马上会讲到。</description></item><item><title>centos安装常用的软件</title><link>https://blog.chenkai.life/posts/yum_install_-software/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://blog.chenkai.life/posts/yum_install_-software/</guid><description>安装pg 参考官网;
Install the repository RPM: yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm Install the client packages: yum install postgresql11 Optionally install the server packages: yum install postgresql11-server Optionally initialize the database and enable automatic start: /usr/pgsql-11/bin/postgresql-11-setup initdb systemctl enable postgresql-11 systemctl stop postgresql-11 systemctl start postgresql-11 systemctl restart postgresql-11 systemctl status postgresql-11 修改配置允许外部ip访问数据库 修改/var/lib/pgsql/11/data/postgresql.conf #listen_addresses = 'localhost' # what IP address(es) to listen on; 改为 listen_addresses = '*' 修改/var/lib/pgsql/11/data/pg_hba.</description></item><item><title>koa中间件源码解析</title><link>https://blog.chenkai.life/nodejs/koa_middleware_analys/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/koa_middleware_analys/</guid><description>中间件是koa的核心，koa的中间件机制是一个剥洋葱式的模型，多个中间件通过use放进一个数组队列然后从外层开始执行，遇到next后进入队列中的下一个中间件，所有中间件执行完后开始回帧，执行队列中之前中间件中未执行的代码部分。
源码 koa在koa-compose中实现了中间件部分，
function compose (middleware) { // compose首先会对middleware进行参数检验，middleware必须是一个函数数组， if (!Array.isArray(middleware)) throw new TypeError(&amp;#39;Middleware stack must be an array!&amp;#39;) for (const fn of middleware) { if (typeof fn !== &amp;#39;function&amp;#39;) throw new TypeError(&amp;#39;Middleware must be composed of functions!&amp;#39;) } /** * @param {Object} context * @return {Promise} * @api public */ return function (context, next) { // last called middleware # let index = -1 return dispatch(0) async function dispatch (i) { // 多次调用next函数会导致1 &amp;lt;= index if (i &amp;lt;= index) return Promise.</description></item><item><title>node中的多进程</title><link>https://blog.chenkai.life/nodejs/node_child_process/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/node_child_process/</guid><description>javascript是单线程的并且只在一个进程中跑，
child_process child_process 模块提供了衍生子进程的能力，此功能主要由 child_process.spawn() 函数提供：
const { spawn } = require(&amp;#39;child_process&amp;#39;); const ls = spawn(&amp;#39;ls&amp;#39;, [&amp;#39;-lh&amp;#39;, &amp;#39;/usr&amp;#39;]); ls.stdout.on(&amp;#39;data&amp;#39;, (data) =&amp;gt; { console.log(`stdout: ${data}`); }); ls.stderr.on(&amp;#39;data&amp;#39;, (data) =&amp;gt; { console.error(`stderr: ${data}`); }); ls.on(&amp;#39;close&amp;#39;, (code) =&amp;gt; { console.log(`子进程退出，使用退出码 ${code}`); }); child_process.spawn() 方法异步地衍生子进程，且不阻塞 Node.js 事件循环。 child_process.spawnSync() 函数则以同步的方式提供了等效的功能，但会阻塞事件循环直到衍生的进程退出或终止。为方便起见， child_process 模块提供了 child_process.spawn() 和 child_process.spawnSync() 的一些同步和异步的替代方法。 这些替代方法中的每一个都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。
[child_process.spawn()]: 方法使用给定的 command 衍生一个新进程，并带上 args 中的命令行参数。 如果省略 args，则其默认为一个空数组。 [child_process.exec()]: 衍生一个 shell 然后在该 shell 中执行 command，并缓冲任何产生的输出。 [child_process.</description></item><item><title>批量运行node程序</title><link>https://blog.chenkai.life/nodejs/run_multy_node_on_shell/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/run_multy_node_on_shell/</guid><description>每次开机都需要手动执行一遍所有node程序,很是麻烦，于是找了一个方法可以用脚本的形式批量打开终端tab页，并执行node程序
ttab ttab是一种macOS（OS X） CLI，用于以编程方式在标准终端应用程序中打开新的终端选项卡/窗口Terminal，具有执行命令和/或特定标题和特定显示设置。
npm install ttab ttab help ttab --help Opens a new terminal tab or window in OS X's Terminal application or iTerm2. ttab [-w] [-s &amp;lt;settings&amp;gt;] [-t &amp;lt;title&amp;gt;] [-q] [-g|-G] [-d &amp;lt;dir&amp;gt;] [&amp;lt;cmd&amp;gt; ...] -w open new tab in new terminal window -s &amp;lt;settings&amp;gt; assign a settings set (profile) -t &amp;lt;title&amp;gt; specify title for new tab -q clear the new tab's screen -g create tab in background (don't activate Terminal/iTerm) -G create tab in background and don't activate new tab -d &amp;lt;dir&amp;gt; specify working directory; -d '' disables inheriting the current dir.</description></item><item><title>检测node程序自动重启</title><link>https://blog.chenkai.life/nodejs/node_auto_reatart_when_change_nodemon/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/node_auto_reatart_when_change_nodemon/</guid><description>nodemon是一种工具，通过在检测到目录中的文件更改时自动重新启动节点应用程序来帮助开发基于node.js的应用程序
nodemon将全局安装到您的系统路径 npm install -g nodemon nodemon包装您的应用程序，因此您可以传递通常传递给应用程序的所有参数 nodemon [your node app] 查看帮助 nodemon -h 配置文件 nodemon支持本地和全局配置文件。这些通常是命名的nodemon.json,可以位于当前工作目录或主目录中。可以使用该&amp;ndash;config 选项指定备用本地配置文件。
{ &amp;quot;verbose&amp;quot;: true, &amp;quot;ignore&amp;quot;: [&amp;quot;*.test.js&amp;quot;, &amp;quot;fixtures/*&amp;quot;], &amp;quot;execMap&amp;quot;: { &amp;quot;rb&amp;quot;: &amp;quot;ruby&amp;quot;, &amp;quot;pde&amp;quot;: &amp;quot;processing --sketch={{pwd}} --run&amp;quot; } } nodemon支持使用package.json配置,以与配置文件相同的格式指定配置，但nodemonConfig在package.json文件中
{ &amp;quot;name&amp;quot;: &amp;quot;nodemon&amp;quot;, &amp;quot;homepage&amp;quot;: &amp;quot;http://nodemon.io&amp;quot;, &amp;quot;...&amp;quot;: &amp;quot;... other standard package.json values&amp;quot;, &amp;quot;nodemonConfig&amp;quot;: { &amp;quot;ignore&amp;quot;: [&amp;quot;test/*&amp;quot;, &amp;quot;docs/*&amp;quot;], &amp;quot;delay&amp;quot;: &amp;quot;2500&amp;quot; } } 忽略指定文件 在某些情况下，您将要忽略某些特定文件，目录或文件模式，以防止nodemon过早地重新启动您的应用程序。在默认情况下，nodemon会忽略.</description></item><item><title>纪录一些常用网站</title><link>https://blog.chenkai.life/hide/some_web/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://blog.chenkai.life/hide/some_web/</guid><description>百度技术团队1
百度技术团队2
美团技术团队
IBM
Stack Overflow
图像转ascii
vue风格指南
tc39:javascript规范
javaScript 教程</description></item><item><title>面试总结</title><link>https://blog.chenkai.life/hide/mian_shi_zhong_jie/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://blog.chenkai.life/hide/mian_shi_zhong_jie/</guid><description>自我介绍 https://www.zhipin.com/web/geek/resume
对公司有什么想要了解的 问答 做过最满意的项目是什么？ 上传、job任务
可以从以下几方面介绍
项目背景 为什么要做这件事情？ 最终达到什么效果？ 你处于什么样的角色，起到了什么方面的作用？ 在项目中遇到什么技术问题？具体是如何解决的？ 如果再做这个项目，你会在哪些方面进行改善？ 最近有了解哪些前沿知识 typescritp Vue3.0 WebAssembly worker_threads graphql pwa js 知识点 string array object funcion 原型 异步
js继承的各种实现以及优缺点 通过prototype指定 Object.setPrototypeOf 用 Object.create实现类继承 ES6的extends javascript 连等赋值问题 var a = {n:1}; var b = a; // 持有a，以回查 a.</description></item><item><title>axios核心源码解读</title><link>https://blog.chenkai.life/javascript/axios_analyse/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/axios_analyse/</guid><description>转载自axios 核心源码解读
介绍axios 一直在使用axios库，在享受它带来的便利的同时，总感觉不读读它的源码有点对不起它，刚好网上介绍axios源码的文章较少，所以写下这篇文章，权当抛砖引玉。
axios是同构的JavaScript的异步请求库，它可以在浏览器端和NodeJS环境里使用。
VueJS的作者尤大也推荐这个工具，它除了异步请求网络资源功能，还有如下功能：
提供代理功能 提供了拦截器（类似中间件），可以注册在请求发出去之前和收到响应之后的操作 可以获取上传进度和下载进度 提供的adapter选项可以模拟响应数据 自定义引起报错的响应码范围 提供了取消请求的功能 axios的GitHub地址。
那么，它是怎么办到的呢？ 首先说说为什么它可以在浏览器端和NodeJS环境中使用 在axios中，使用适配器设计模式来屏蔽平台的差异性，让使用者可以在浏览器端和NodeJS环境中使用同一套API发起http请求。
axios的默认配置里的adapter是通过getDefaultAdapter()方法来获取的，它的逻辑如下：
function getDefaultAdapter() { var adapter; // Only Node.JS has a process variable that is of [[Class]] process if (typeof process !== &amp;#39;undefined&amp;#39; &amp;amp;&amp;amp; Object.prototype.toString.call(process) === &amp;#39;[object process]&amp;#39;) { // For node use HTTP adapter adapter = require(&amp;#39;./adapters/http&amp;#39;); } else if (typeof XMLHttpRequest !</description></item><item><title>Base64原理及实现</title><link>https://blog.chenkai.life/posts/base64_yuanli_and_shijian/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/base64_yuanli_and_shijian/</guid><description>base64 Base64是用64个字符来表示数据的方法。Base64要求把每三个8Bit的字节转换为四个6Bit的字节，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。如果要转码数据字节不是3的倍数，最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。 转换后，我们每个字节范围为[00000000-00111111],所以我们可以用一个64码表来得到我们想要的字符串（也就是最终的Base64编码）标准的Base64用[A-Z,a-z,0-9,+,/]64个字符编码。
编码 深入了解base64前，我们需要先了解编码。编码是信息从一种形式或格式转换为另一种形式的过程。计算机中，所有的数据在存储和运算时都使用二进制示，n位二进制组合成2的n次方个不同的信息，给每个信息规定一个具体码组，这种过程叫编码。而具体用哪些二进制数字表示哪个符号，每个人都可以约定自己的一套编码。
如常用的ASCII是由美国国家标准学会制定的一种单字节字符编码，标准ASCII码使用7位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0到9、标点符号。在有的语言中128个符号是不够的，有些编码方案利用字节中闲置的最高位编入新的符号，有的利用两个（GBK等）或更多字节（utf-32等）表示一个符号（汉字）
Base64编码 base64编码过程：
ascii码s133对应的编码115 49 51 51 在内存2进制表示： 01110011 00110001 00110011 00110011 每三组分为6Bit四组 011100 110011 000100 110011 001100 110000 000000 000000 高位补0得到 00011100 00110011 00000100 00110011 00001100 00110000 00000000 00000000 对应十进制 28 51 4 51 12 48 0 0 查对照表 生成base64码czEzMw== base64解码过程：
base64编码过程逆向即为解码
javascript代码实现 Base64 = { _table: [ &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;F&amp;#39;, &amp;#39;G&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;K&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;N&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;P&amp;#39;, &amp;#39;Q&amp;#39;, &amp;#39;R&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;, &amp;#39;g&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;j&amp;#39;, &amp;#39;k&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;q&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;v&amp;#39;, &amp;#39;w&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;z&amp;#39;, &amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;+&amp;#39;, &amp;#39;/&amp;#39; ], _getReg: function () { return RegExp(`^[${this.</description></item><item><title>brew</title><link>https://blog.chenkai.life/tools/brew/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/brew/</guid><description>切换到国内源 ## 替换brew.git: cd &amp;quot;$(brew --repo)&amp;quot; ## 中国科大: git remote set-url origin https://mirrors.ustc.edu.cn/brew.git ## 清华大学: git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git ## 替换homebrew-core.git: cd &amp;quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;quot; ## 中国科大: git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git ## 清华大学: git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git ## 替换homebrew-bottles: ## 中国科大: echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &amp;gt;&amp;gt; ~/.bash_profile source ~/.bash_profile ## 清华大学: echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' &amp;gt;&amp;gt; ~/.bash_profile source ~/.bash_profile ## 应用生效: brew update 切换到官方源 ## 重置brew.</description></item><item><title>css元素选择器</title><link>https://blog.chenkai.life/web/css_select/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/css_select/</guid><description>CSS 选择器规定了 CSS 规则会应用到哪些元素上。
基本选择器 节点选择 CSS 类型选择器按节点名称匹配元素。换句话说，它选择文档中给定类型的所有元素。
/* All &amp;lt;a&amp;gt; elements. */ a { color: red; } 类选择 该CSS 类选择匹配根据他们的内容元素class属性。
/* All elements with class=&amp;#34;spacious&amp;#34; */ .spacious { margin: 2em; } /* All &amp;lt;li&amp;gt; elements with class=&amp;#34;spacious&amp;#34; */ li.spacious { margin: 2em; } /* All &amp;lt;li&amp;gt; elements with a class list that includes both &amp;#34;spacious&amp;#34; and &amp;#34;elegant&amp;#34; */ /* For example, class=&amp;#34;elegant retro spacious&amp;#34; */ li.</description></item><item><title>css关于浮动的知识</title><link>https://blog.chenkai.life/web/css_float/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/css_float/</guid><description>float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。 当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。
float原始用法 float本意是为了允许文本和内联元素环它如（文字环绕图片）,就像下面一样
.float { float: left; width: 200px; height: 200px; background-color: red; } &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;float&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; float本意是为了允许文本和内联元素环它; float本意是为了允许文本和内联元素环它; float本意是为了允许文本和内联元素环它; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 滥用float 带来的问题 我们使用float浮动做了很多其本职工作以外的事情，使用float进行分栏布局、列表排列，但是如果一个元素里只有浮动元素，那它的高度会是0。如果你想要它自适应即包含所有浮动元素，那你需要清除它的子元素。
清除浮动的几种办法 ::after伪元素 这种方式不会影响任何其他样式，通用性强，覆盖面广，推荐使用
#container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } 类似的可以在元素后面加一个&amp;lt;div style=&amp;quot;clear:both;&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;空元素
其他清除浮动方法 IE下清除浮动准则很简单，使元素haslayout就可以了。如宽度值，高度值，绝对定位，zoom，浮动本身都可以让元素haslayout。显然，首选zoom:1;不会干扰任何样式。非IE浏览器常用的是overflow属性
container也浮动,这种方式治标不治本总不能一直浮动到root
#container{ float:left; } 使用position: absolute</description></item><item><title>defineProperty</title><link>https://blog.chenkai.life/javascript/js_defineproperty/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_defineproperty/</guid><description>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
Object.defineProperty(obj, prop, descriptor) obj:要在其上定义属性的对象。 prop:要定义或修改的属性的名称。 descriptor:将被定义或修改的属性描述符。 描述符可以有以下属性：
configurable：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false enumerable： 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中，default：false value： 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined writable： 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 get： 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象 set： 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 @return:传递给函数的对象。
example // 数组拦截 /** * * @param {array} data */ function observe(data) { if (!Array.isArray(data)) { return; } // 取出所有数组遍历 data.forEach(function(val,index) { Object.defineProperty(data, index, { enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() { return val; }, set: function(newVal) { console.</description></item><item><title>docker</title><link>https://blog.chenkai.life/tools/docker/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/docker/</guid><description>安装/卸载docker 安装过程参考官网;
yum update ## 使用以下命令来设置的存储库 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io sudo systemctl start docker 卸载 sudo yum -y remove docker-ee ## 删除所有图像，容器和卷 sudo rm -rf /var/lib/docker ## 删除其他与Docker相关的资源 $ sudo rm -rf /run/docker $ sudo rm -rf /var/run/docker $ sudo rm -rf /etc/docker 安装过程中可能会遇到以下问题 doceker版本和系统内核版本不兼容 升级系统内核或者降低docker版本 yum安装失败 ## 解决依赖冲突 package-cleanup --cleandupes 找不到安装包 添加设置的存储库 容器生命周期管理 docker start :启动一个或多个已经被停止的容器 docker stop :停止一个运行中的容器 docker restart :重启容器 docker-compose 文件启动镜像 docker-compose up -d redis 创建一个新的容器但不启动，用法同docker run 使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob docker create --name myrunoob nginx:latest 创建一个新的容器并运行一个命令 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。 docker run --name mynginx -d nginx:latest 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。 docker run -P -d nginx:latest 使用镜像 nginx:latest，以后台模式启动一个容器,将主机的 80 端口映射到 容器的 80 端口,主机的目录 /data 映射到容器的 /data。 docker run -p 80:80 -v /data:/data -d nginx:latest 镜像容器管理 给image打标签 docker tag e9cb35287c01 geohey-nlpa-platform:gd 保存为本地文件 docker save -o geohey-nlpa-platform.</description></item><item><title>DOM中的event</title><link>https://blog.chenkai.life/web/dom_event/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/dom_event/</guid><description>event Event 接口表示在 DOM 中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由 API 生成（例如指示动画已经完成运行的事件，视频已被暂停等等。事件通常由外部源触发，同样也会以编程方式触发，例如执行一个 element 的一个 HTMLElement.click( ) 方法，或通过定义事件，然后使用 EventTarget.dispatchEvent() 将其派发到一个指定的目标。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。 事件处理函数可以附加在各种对象上，包括 DOM元素,window,document对象. 等
有三种方式可以为DOM元素注册事件处理函数
EventTarget.addEventListener // Assuming myButton is a button element myButton.addEventListener(&amp;#39;click&amp;#39;, function(){alert(&amp;#39;Hello world&amp;#39;);}, false); HTML 属性 &amp;lt;button onclick=&amp;#34;alert(&amp;#39;Hello world!&amp;#39;)&amp;#34;&amp;gt; DOM 元素属性 该函数在定义时，可以传入一个 event 形式的参数。 在HTML 规范中，其返回值会以一种特殊的方式被处理。
// Assuming myButton is a button element myButton.onclick = function(event){alert('Hello world');}; 创建自定义事件 可以使用事件构造函数创建事件
var event = new Event(&amp;#39;build&amp;#39;); let eventEle = document.</description></item><item><title>eggjs</title><link>https://blog.chenkai.life/nodejs/eggjs/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/eggjs/</guid><description>egg初始化设置 const dir = path.join(app.baseDir, '/app/model/'); app.loader.loadToContext(dir, 'model'); //只执行一次 app.once('server', async (server) =&amp;gt; { //设置一个空的上下文 const ctx = app.createAnonymousContext(); //获取设置 var settings = await ctx.model.setting.getAll(); });</description></item><item><title>Flex弹性布局</title><link>https://blog.chenkai.life/web/css_flex/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/css_flex/</guid><description>&lt;h2 id="弹性布局">
弹性布局
&lt;a class="heading-link" href="#%e5%bc%b9%e6%80%a7%e5%b8%83%e5%b1%80">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h3 id="一弹性布局是什么">
一.弹性布局是什么？
&lt;a class="heading-link" href="#%e4%b8%80%e5%bc%b9%e6%80%a7%e5%b8%83%e5%b1%80%e6%98%af%e4%bb%80%e4%b9%88">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h3>
&lt;p>任何一个容器都可以指定为 Flex 布局&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-css" data-lang="css">.&lt;span style="color:#a6e22e">box&lt;/span>{
&lt;span style="color:#66d9ef">display&lt;/span>: &lt;span style="color:#66d9ef">flex&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>行内元素也可以使用 Flex 布局。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-css" data-lang="css">.&lt;span style="color:#a6e22e">box&lt;/span>{
&lt;span style="color:#66d9ef">display&lt;/span>: &lt;span style="color:#66d9ef">inline&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#66d9ef">flex&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>gdal命令</title><link>https://blog.chenkai.life/tools/gdal/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/gdal/</guid><description>类型转换 格式ogr2ogr -f &amp;quot;fileType&amp;quot; fileName sourceFile
数据库&amp;gt;geojson
ogr2ogr -f &amp;quot;GeoJSON&amp;quot; cn_polygon.geojson PG:&amp;quot;host=localhost dbname=postgres user=postgres password=password&amp;quot; -sql &amp;quot;select * from planet_osm_polygon limit 30000&amp;quot; geojson&amp;gt;shp
ogr2ogr -f &amp;quot;ESRI Shapefile&amp;quot; test.shp china_diaoyudao.geojson.json 数据入库 geojson&amp;gt;postgre
/usr/local/Cellar/gdal2/2.3.2_1/bin/ogr2ogr -dim XY -gt 65536 -skipfailures -progress --config OGR_FORCE_ASCII NO --config PG_USE_COPY YES -overwrite -f PostgreSQL PG:&amp;quot;host=localhost port=5432 dbname=g-default user=projx password=sss&amp;quot; -lco FID=_id -lco GEOMETRY_NAME=the_geom -nln ${表名} &amp;quot;${文件名}&amp;quot; csv&amp;gt;postgre
/usr/local/Cellar/gdal2/2.3.2_1/bin/ogr2ogr -dim XY -gt 65536 -skipfailures --config PG_USE_COPY YES -overwrite -oo AUTODETECT_TYPE=YES -f PostgreSQL PG:&amp;quot;host=localhost port=5432 dbname=g-default user=projx password=sss&amp;quot; -lco FID=_id -nln ${start.</description></item><item><title>get和set</title><link>https://blog.chenkai.life/javascript/js_get_and_set/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_get_and_set/</guid><description>你可以在支持添加新属性的任何标准的内置对象或用户定义的对象内定义getter(访问方法)和setter(设置方法)。使用对象字面量语法定义getters和setters方法。
get get语法将对象属性绑定到查询该属性时将被调用的函数,有时需要允许访问返回动态计算值的属性，或者你可能需要反映内部变量的状态，而不需要使用显式方法调用。在JavaScript中，可以使用 getter 来实现。虽然可以使用 getter 和 setter 来创建一个伪属性类型，但是不可能同时将一个 getter 绑定到一个属性并且该属性实际上具有一个值
使用get语法时应注意以下问题：
可以使用数值或字符串作为标识； 必须不带参数； 它不能与另一个 get 或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 { get x() { }, get x() { } } 和 { x: &amp;hellip;, get x() { } }）。 可通过 delete 操作符删除 getter。 在新对象初始化时定义一个getter 这会为obj创建一个伪属性latest，它会返回log数组的最后一个元素,注意，尝试为latest分配一个值不会改变它。
var obj = { log: [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;], get latest() { if (this.log.length == 0) { return undefined; } return this.</description></item><item><title>glob表达式</title><link>https://blog.chenkai.life/posts/glob_expression/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/glob_expression/</guid><description>glob表达式是匹配文件路径的表达式。
glob表达式规则 Matches 0 or more characters in a single path portion ? Matches 1 character [&amp;hellip;] Matches a range of characters, similar to a RegExp range. If the first character of the range is ! or + ^ then it matches any character not in the range. !(pattern|pattern|pattern) Matches anything that does not match any of the patterns provided. ?(pattern|pattern|pattern) Matches zero or one occurrence of the patterns provided.</description></item><item><title>HTTP API 认证授权术</title><link>https://blog.chenkai.life/posts/http-api-renzhengshouquan/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/http-api-renzhengshouquan/</guid><description>转载自https://coolshell.cn/articles/19395.html#coolshell-2
我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公司内去到哪都用这个访客卡来开门，而不再校验你是哪一个人。在计算机的世界里，这个登录凭证的相关数据会放在两种地方，一个地方在用户端，以Cookie的方式（一般不会放在浏览器的Local Storage，因为这很容易出现登录凭证被XSS攻击），另一个地方是放在服务器端，又叫Session的方式（SessonID存于Cookie）。
但是，这个世界还是比较复杂的，除了用户访问，还有用户委托的第三方的应用，还有企业和企业间的调用，这里，我想把业内常用的一些 API认证技术相对系统地总结归纳一下，这样可以让大家更为全面的了解这些技术。注意，这是一篇长文！
本篇文章会覆盖如下技术：
HTTP Basic Digest Access App Secret Key + HMAC JWT – JSON Web Tokens OAuth 1.0 – 3 legged &amp;amp; 2 legged OAuth 2.0 – Authentication Code &amp;amp; Client Credential 目录
HTTP BasicDigest AccessApp Secret Key + HMACJWT – JSON Web TokensOAuth 1.0OAuth 2.0Authorization Code FlowClient Credential Flow小结两个概念和三个术语明白一些初衷相关的注意事项
HTTP Basic HTTP Basic 是一个非常传统的API认证技术，也是一个比较简单的技术。这个技术也就是使用 username和 password 来进行登录。整个过程被定义在了 RFC 2617 中，也被描述在了 Wikipedia: Basic Access Authentication 词条中，同时也可以参看 MDN HTTP Authentication</description></item><item><title>HTTP的前世今生</title><link>https://blog.chenkai.life/posts/http/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/http/</guid><description>转载自https://coolshell.cn/articles/19840.html
HTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会CERN的英国工程师 Tim Berners-Lee v发明的，同时，他也是WWW的发明人，最初的主要是用于传递通过HTML封装过的数据。在1991年发布了HTTP 0.9版，在1996年发布1.0版，1997年是1.1版，1.1版也是到今天为止传输最广泛的版本（初始RFC 2068 在1997年发布， 然后在1999年被 RFC 2616 取代，再在2014年被 RFC 7230 /7231/7232/7233/7234/7235取代），2015年发布了2.0版，其极大的优化了HTTP/1.1的性能和安全性，而2018年发布的3.0版，继续优化HTTP/2，激进地使用UDP取代TCP协议，目前，HTTP/3 在2019年9月26日 被 Chrome，Firefox，和Cloudflare支持，所以我想写下这篇文章，简单地说一下HTTP的前世今生，让大家学到一些知识，并希望可以在推动一下HTTP标准协议的发展。
HTTP 0.9 / 1.0 0.9和1.0这两个版本，就是最传统的 request – response的模式了，HTTP 0.9版本的协议简单到极点，请求时，不支持请求头，只支持 GET 方法，没了。HTTP 1.0 扩展了0.9版，其中主要增加了几个变化：
在请求中加入了HTTP版本号，如：GET /coolshell/index.html HTTP/1.0 HTTP 开始有 header了，不管是request还是response 都有header了。 增加了HTTP Status Code 标识相关的状态码。 还有 Content-Type 可以传输其它的文件了。 我们可以看到，HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：
一个协议有没有版本管理，是一个工程化的象征。 header是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。 Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。 （注：国内很多公司HTTP无论对错只返回200，这种把HTTP Status Code 全部抹掉完全是一种工程界的倒退）</description></item><item><title>JavaScript脚手架</title><link>https://blog.chenkai.life/javascript/js_cli_jiaoshoujia/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_cli_jiaoshoujia/</guid><description>什么是脚手架 脚手架是为了保证各施工过程顺利进行而搭设的工作平台。在项目开发中我们把创建项目结构模版的工具也称之为脚手架。如vue-cli，create-react-app等。这些脚手架等原理都一样，即用Node.js命令行程序生成项目模版。
第一个Node.js命令行脚本 编写脚手架其实就是Node.js命令行开发,和写shell脚本类似，使用JavaScript语言，写一个可执行脚本 hello wold过程如下： 新建一个hello文件，其中#!/usr/bin/env node不可少，其作用是它告诉系统这个脚本需要用node解释器来执行，语法与node一样。
#!/usr/bin/env node console.log('hello world'); 然后,修改的权限
chmod 755 hello 执行脚本
./hello 如果想把 hello 前面的路径去除，可以将 hello 的路径加入环境变量 PATH。但是，另一种更好的做法，是在当前目录下新建 package.json ，写入下面的内容。
{ &amp;#34;name&amp;#34;: &amp;#34;hello&amp;#34;, &amp;#34;bin&amp;#34;: { &amp;#34;hello&amp;#34;: &amp;#34;hello&amp;#34; } } 然后执行 npm link 命令。
npm link 执行脚本
hello 写一个脚手架 脚手架开发与上面过程类似，有一些npm库可以帮助我们开发命令行工具如shelljs、commander，它们封装了node命令行命令可以更方便命令行开发。 文件目录结构
. ├── bin │ └── ckoa.js ├── package-lock.json ├── package.json └── utils └── download.js ckoa.js Node.</description></item><item><title>Jenkins</title><link>https://blog.chenkai.life/tools/jenkins/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/jenkins/</guid><description>默认用户名：admin,查看密码：sudo vi /Users/Shared/Jenkins/Home/secrets/initialAdminPassword
安装包安装的Jenkins 修改默认端口的方法：
先关闭jenkins ; 命令行下修改端口：sudo defaults write /Library/Preferences/org.jenkins-ci httpPort 7071 启动jenkins 附：
启动jenkins： sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist 停止jenkins：sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist
用brew安装的的Jenkins 修改默认端口的方法：
打开文件 vi /usr/local/opt/jenkins/homebrew.mxcl.jenkins.plist 修改默认端口号 启动jenkins： brew services start jenkins 停止jenkins：brew services stop jenkins 重启Jenkins：brew services restart jenkins 更新：切换到目录cd ~/.jenkins，然后用最新下载的war包替换文件夹中的war</description></item><item><title>jsonwebtoken</title><link>https://blog.chenkai.life/nodejs/jsonwebtoken/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/jsonwebtoken/</guid><description>什么是JSON Web Token？ JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑且独立的方式，用于在各方之间用SON对象安全地传输信息。此信息可以通过数字签名进行验证和信任。 JWT可以使用加密算法（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名。
什么时候应该使用JSON Web令牌 以下是JSON Web令牌有用的一些场景：
授权：这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，允许用户访问该令牌允许的路由，服务和资源。 Single Sign On是一种现在广泛使用JWT的功能，因为它的开销很小，并且能够在不同的域中轻松使用。
信息交换：JSON Web令牌是在各方之间安全传输信息的好方法。因为JWT可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。
JSON Web令牌结构 JSON Web Tokens由.分隔的三个部分组成，它们是：
头 有效载荷 签名 因此，JWT通常如xxxxx.yyyyy.zzzzz所示. 头 标头通常由两部分组成：令牌的类型，即JWT，以及正在使用的签名算法，例如HMAC SHA256或RSA。
{ &amp;quot;alg&amp;quot;: &amp;quot;HS256&amp;quot;, &amp;quot;typ&amp;quot;: &amp;quot;JWT&amp;quot; } 然后，这个JSON被编码为Base64Url，形成JWT的第一部分。
有效载荷 令牌的第二部分是有效负载，其中包含声明。声明是关于实体（通常是用户）和其他数据的声明。有三种类型:registered、public、private claims.
registered：这些是一组预定义声明，不是强制性的，但建议使用，以提供一组有用的，可互操作的声明。其中一些是： iss（发行人）， exp（到期时间），sub（主题）， aud（观众）等。 public：这些可以由使用JWT的人随意定义。但为避免冲突，应在 IANA JSON Web令牌注册表中定义它们，或者将 其定义为包含防冲突命名空间的URI。 private claims： 这是创建共享使用它们同意并既不是当事人之间的信息自定义声明注册或公众的权利要求 然后，有效负载经过Base64Url编码，形成JSON Web令牌的第二部分。</description></item><item><title>js中的this</title><link>https://blog.chenkai.life/javascript/js_this/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_this/</guid><description>js中this指当前执行代码的环境对象，this不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了this的值
全局环境 浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &amp;#34;MDN&amp;#34;; console.log(window.b) // &amp;#34;MDN&amp;#34; console.log(b) // &amp;#34;MDN&amp;#34; node环境中this是一个空对象
console.log(this) // {} 函数（运行内）环境 在函数内部，this的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1(){ return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined
&amp;#34;use strict&amp;#34;; // 这里是严格模式 function f2(){ return this; } f2() === undefined; // true window.</description></item><item><title>js的Class的继承</title><link>https://blog.chenkai.life/javascript/js_class/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_class/</guid><description>转载自https://es6.ruanyifeng.com/#docs/class-extends
简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
class Point { } class ColorPoint extends Point { } 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。
class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + &amp;#39; &amp;#39; + super.toString(); // 调用父类的toString() } } 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
class Point { /* ... */ } class ColorPoint extends Point { constructor() { } } let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</description></item><item><title>js的prototype</title><link>https://blog.chenkai.life/javascript/js_prototype/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_prototype/</guid><description>什么是原型链 首先我们需要知道什么是原型，在javascript中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型（prototype）,我们可以添加一些属性到原型上面,然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个的实例。每个实例对象都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）. 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。
如何利用原型链实现继承 假设这里有两个类
// 交通工具 function Transportation(name){ this.name = name; // 该属性没有定义到原型链上,可以通过Object.keys获取 this.say = function(){ console.log(`Transportation： ${this.name}是交通工具`); } } Object.assign(Transportation.prototype,{ move : function (){ console.log(`Transportation: ${this.name}会移动`); }, }); // 汽车 function Car(name){ // 调用Transportation构造函数，绑定this变量 我们也可以 // this.name = name; Transportation.call(this, name); } 此时Car的原型是
new Car() ----&amp;gt; Car.prototype ----&amp;gt; Object.prototype ----&amp;gt; null 要实现继承我们需要将该对象的原型指向要继承对象的原型，如
new Car() ----&amp;gt; Car.</description></item><item><title>js的迭代器</title><link>https://blog.chenkai.life/javascript/js_iterator/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_iterator/</guid><description>什么是迭代器 ECMAScript 2015的几个补充，并不是新的内置实现或语法，而是协议。这些协议可以被任何遵循某些约定的对象来实现。有两个协议：可迭代协议和迭代器协议。 JavaScript 提供了许多迭代集合的方法，从简单的 for 循环到 map() 和 filter()，迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for&amp;hellip;of 循环的行为
var myIterator = { next: function() { // ... }, [Symbol.iterator]: function() { return this } } 可迭代协议 为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性:
[Symbol.iterator] 返回一个对象的无参函数，被返回对象符合迭代器协议。
当一个对象需要被迭代的时候（比如开始用于一个for..of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。
class people{ constructor(index){ this.index = index; } next(){ this.index++; return{ done: this.index &amp;gt; 10, value: this.index } } [Symbol.</description></item><item><title>js聊聊JS的二进制家族：Blob、ArrayBuffer和Buffer</title><link>https://blog.chenkai.life/javascript/js_binary_blob_arraybuffer_buffer/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_binary_blob_arraybuffer_buffer/</guid><description>转载自知乎-外婆的彭湖湾
前端较少涉及对二进制数据的处理，但即便如此，我们偶尔总能在角落里看见它们的身影，今天我们就来聊一聊JS的二进制家族：Blob、ArrayBuffer和Buffer（Buffer由Node.js提供）
概述 Blob: 前端的一个专门用于支持文件操作的二进制对象 ArrayBuffer：前端的一个通用的二进制缓冲区，类似数组，但在API和特性上却有诸多不同 Buffer：Node.js提供的一个二进制缓冲区，常用来处理I/O操作 这篇文章的内容主要就聊一聊这一家子的人际关系展开。
复杂的人际关系网.jpg
下面就来一一介绍
Blob 我们首先来介绍Blob，Blob是用来支持文件操作的。简单的说：在JS中，有两个构造函数 File 和 Blob, 而File继承了所有Blob的属性。
所以在我们看来，File对象可以看作一种特殊的Blob对象。
在前端工程中，我们在哪些操作中可以获得File对象呢？ 请看：
（备注：目前 File API规范的状态为Working Draft）
我们上面说了，File对象是一种特殊的Blob对象，那么它自然就可以直接调用Blob对象的方法。让我们看一看Blob具体有哪些方法，以及能够用它们实现哪些功能
Blob实战 通过window.URL.createObjectURL方法可以把一个blob转化为一个Blob URL，并且用做文件下载或者图片显示的链接。
Blob URL所实现的下载或者显示等功能，仅仅可以在单个浏览器内部进行。而不能在服务器上进行存储，亦或者说它没有在服务器端存储的意义。
下面是一个Blob的例子，可以看到它很短
blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 和冗长的Base64格式的Data URL相比，Blob URL的长度显然不能够存储足够的信息，这也就意味着它只是类似于一个浏览器内部的“引用“。从这个角度看，Blob URL是一个浏览器自行制定的一个伪协议
Blob实现下载文件
我们可以通过window.URL.createObjectURL，接收一个Blob（File）对象，将其转化为Blob URL,然后赋给 a.download属性，然后在页面上点击这个链接就可以实现下载了
&amp;lt;!-- html部分 --&amp;gt; &amp;lt;a id=&amp;#34;h&amp;#34;&amp;gt;点此进行下载&amp;lt;/a&amp;gt; &amp;lt;!-- js部分 --&amp;gt; &amp;lt;script&amp;gt; var blob = new Blob([&amp;#34;Hello World&amp;#34;]); var url = window.</description></item><item><title>kubectl命令</title><link>https://blog.chenkai.life/tools/kubectl/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/kubectl/</guid><description>This page is an overview of the kubectl command.
Kubectl Autocomplete Kubectl Context and Configuration Apply Creating Objects Viewing, Finding Resources Updating Resources Patching Resources Editing Resources Scaling Resources Deleting Resources Interacting with running Pods Interacting with Nodes and Cluster What&amp;rsquo;s next kubectl - Cheat Sheet Kubectl Autocomplete BASH source &amp;lt;(kubectl completion bash) # setup autocomplete in bash into the current shell, bash-completion package should be installed first.</description></item><item><title>madlib</title><link>https://blog.chenkai.life/tools/madlib/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/madlib/</guid><description>Apache MADlib是一个在PostgreSQL、Greenplum中使用的,用于可扩展的数据库内分析的开源库。它为结构化和非结构化数据提供数学，统计，图形和机器学习方法的数据并行实现。
我们可以用madlib做什么？ 分类 当期望的输出本质上是分类时，我们使用分类方法来构建模型，该模型预测新结果将落入哪个不同类别。分类的目标是能够使用正确的记录类正确标记传入记录。
示例：如果我们的数据描述了各种人口统计数据和申请贷款的个人的其他特征，并且我们有历史数据，其中包括过去贷款违约的情况，那么我们可以建立一个模型来描述一组新的人口统计数据的可能性 会导致贷款违约。 在这种情况下，类别是“将默认”或“不会默认”，这是两个不连续的输出类别。
回归 当期望的输出本质上是连续的时，我们使用回归方法来构建预测输出值的模型。
示例：如果我们有描述房地产列表属性的数据，那么我们可以建立一个模型来根据房屋的已知特征预测房屋的销售价值。 这是一个回归问题，因为输出响应本质上是连续的，而不是分类的。
深度学习 深度学习是一种机器学习，受大脑生物学的启发，使用一类称为人工神经网络的算法。 这些网络有效地解决了各种各样的问题，主要是在监督学习领域。 GPU加速被广泛用于加速深度神经网络的训练。
示例：如果我们想要将进入办公室大厅的员工的视频与她的图片进行匹配，我们可以使用卷积神经网络来完成此操作。 这将使她不必拿出她的员工徽章并将其刷入机器。 它还可以帮助减少早上赶时间的大厅排队。
聚类 在这里，我们尝试识别数据组，使得一个群集中的项目彼此更相似，而不是任何其他群集中的项目。
示例：在客户细分分析中，目标是识别以类似方式行事的特定客户群，以便可以设计各种营销活动以进入这些市场。 当预先知道客户群时，这将是监督的分类任务。 当我们让数据本身识别段时，这就成了一个聚类任务。
主题建模 主题建模类似于聚类，因为它尝试识别彼此相似的文档集群，但它更具体到文本域，它也在尝试识别这些文档的主要主题。
关联规则挖掘 也称为市场购物篮分析或频繁项目集挖掘，这是试图识别哪些项目往往比随机机会指示的更频繁地发生，表明项目之间的潜在关系。
示例：在在线Web商店中，关联规则挖掘可用于识别倾向于一起购买的产品。 然后，这可以用作产品推荐引擎的输入，以建议客户可能感兴趣的项目并提供加售机会。
描述性统计 描述性统计不提供模型，因此不被视为学习方法。 但是，它们可以帮助分析师提供信息以理解基础数据，并且可以为可能影响数据模型选择的数据提供有价值的见解。
示例：计算数据集的每个变量中的数据分布可以帮助分析人员了解哪些变量应该被视为分类变量，哪些变量应该被视为连续变量，包括值所属的分布类型。
验证 在不了解该模型的准确性的情况下使用模型可能导致不良结果。 因此，了解模型的错误并评估模型的测试数据准确性非常重要。 经常在数据分析中，训练数据和测试数据之间的分离仅仅是为了提供模型有效性的统计有效分析，并且评估模型不过度拟合训练数据。 还经常使用N倍交叉验证。
安装madlib 安装 src/bin/madpack -p postgres -c postgres/postgres@localhost:5432/postgres install</description></item><item><title>nginx</title><link>https://blog.chenkai.life/tools/nginx/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/nginx/</guid><description>命令 Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /usr/local/Cellar/nginx/1.17.3_1/) -c filename : set configuration file (default: /usr/local/etc/nginx/nginx.</description></item><item><title>node Promise 转换</title><link>https://blog.chenkai.life/nodejs/node_promise/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/node_promise/</guid><description>如果你曾经使用Javascript，你必须有经验的回调。Javascript以其内置的异步哲学而闻名。从标准内置模块到其他框架和库，回调无处不在。这就是在Javascript中完成异步编程。但是回调有一个黑暗的一面。这叫Callback Hells。
回调地狱的解决方案是Promises。而不是通过回调同步返回值或传递结果，我们可以返回一个Promise，我们将来会返回一些值或错误。 有许多像好的库如Bluebird和Q可以用来处理Promise。但是内置的模块和很多其他库不能使用Promises。这些库能够将传统的回调方法转换为Promise，在Node v8中我们现在可以使用util.promisify来处理回调方法。根据Node.js的文档： util.promisify(original)
original Returns: const util = require(&amp;#39;util&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); const stat = util.promisify(fs.stat); stat(&amp;#39;.&amp;#39;).then((stats) =&amp;gt; { // Do something with `stats` }).catch((error) =&amp;gt; { // Handle the error. }); 或者 const util = require(&amp;#39;util&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); const stat = util.promisify(fs.stat); async function callStat() { const stats = await stat(&amp;#39;.&amp;#39;); console.log(`This directory is owned by ${stats.uid}`); } 看传统的例子：</description></item><item><title>node事件循环</title><link>https://blog.chenkai.life/nodejs/node_event_loop/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/node_event_loop/</guid><description>事件循环 事件循环是 Node.js 处理非阻塞 I/O 操作的机制，事件循环使Node.js可以通过将操作转移到系统内核中来执行非阻塞I/O操作，由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会告诉Node.js，将适当的回调添加到轮询队列中以最终执行。
事件轮询机制解析 面的图表展示了事件循环操作顺序的简化概览,每个框被称为事件循环机制的一个阶段。每个阶段都有一个FIFO队列来执行回调。当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。
┌───────────────────────────┐ ┌─&amp;gt;│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │&amp;lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ 阶段概述</description></item><item><title>node程序放入docker</title><link>https://blog.chenkai.life/nodejs/node_docker/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/node_docker/</guid><description>准备demo程序 index.js &amp;#39;use strict&amp;#39;; const express = require(&amp;#39;express&amp;#39;); // Constants const PORT = 6677; const HOST = &amp;#39;0.0.0.0&amp;#39;; // App const app = express(); app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; { res.send(&amp;#39;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&amp;#39;); }); app.listen(PORT, HOST); console.log(`Running on http://${HOST}:${PORT}`); 根目录新建Dockerfile文件 ## 定义我们需要从哪个镜像进行构建 FROM node:8 ## 在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ &amp;quot;node&amp;quot;, &amp;quot;index.js&amp;quot; ] .</description></item><item><title>npm</title><link>https://blog.chenkai.life/tools/npm/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/npm/</guid><description>npm 配置 修改配置文件 npm配置文件地址~/.npmrc，npm config ls -l,npm config edit命令;
npm的全局node包在哪里？ 就是那些通过npm install xxx -g或者cnpm install xxx -g或者yarn global add xxx安装的xxx文件，到底安装在什么地方？这个其实也挺好找的。默认情况下，可以通过下面的命令查看其基础路径。
npm config get prefix npm root -g 默认的全局安装包位置： win系统下路径是：%APPDATA%/npm/node_modules/ mac系统下路径是：/usr/local/lib/node_modules/
npm 清空缓存 npm cache clean -
设置npm源
npm config set registry http://registry.npmjs.org/ npm config set registry https://registry.npm.taobao.org/ //临时使用 npm i -g express --registry https://registry.npm.taobao.org npm 发布包 # 登陆 npm login --registry http://registry.</description></item><item><title>pg 分词</title><link>https://blog.chenkai.life/database/pg_to_tsvector/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_to_tsvector/</guid><description>分词例子 to_tsvector()生成的分词带有位置信息，tsvector没有位置信息
select to_tsvector(&amp;#39;陈 锴 A S F a a a 1 2 3 4&amp;#39;); select to_tsvector(&amp;#39;simple&amp;#39;, &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39;); select to_tsvector(&amp;#39;english&amp;#39;, &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39;); `&amp;#39;1&amp;#39;:8 &amp;#39;12&amp;#39;:3 &amp;#39;2&amp;#39;:9 &amp;#39;3&amp;#39;:10 &amp;#39;4&amp;#39;:11 &amp;#39;a&amp;#39;:1,5,6,7 &amp;#39;apple&amp;#39;:2 &amp;#39;f&amp;#39;:4` select &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39; :: tsvector; `&amp;#39;,&amp;#39; &amp;#39;1&amp;#39; &amp;#39;12&amp;#39; &amp;#39;2&amp;#39; &amp;#39;3&amp;#39; &amp;#39;4&amp;#39; &amp;#39;A&amp;#39; &amp;#39;F&amp;#39; &amp;#39;a&amp;#39; &amp;#39;apple&amp;#39; &amp;#39;一个&amp;#39; &amp;#39;锴&amp;#39; &amp;#39;陈&amp;#39;`</description></item><item><title>pgpool</title><link>https://blog.chenkai.life/database/pgpool/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pgpool/</guid><description>什么是pgpool pgpool-II 是一个位于 PostgreSQL 服务器和 PostgreSQL 数据库客户端之间的中间件，它提供以下功能：
连接池 pgpool-II 保持已经连接到 PostgreSQL 服务器的连接，并在使用相同参数（例如：用户名，数据库，协议版本）连接进来时重用它们。它减少了连接开销，并增加了系统的总体吞吐量。 复制 pgpool-II 可以管理多个 PostgreSQL 服务器。激活复制功能并使在2台或者更多 PostgreSQL 节点中建立一个实时备份成为可能，这样，如果其中一台节点失效，服务可以不被中断继续运行。 负载均衡 如果数据库进行了复制，则在任何一台服务器中执行一个 SELECT 查询将返回相同的结果。pgpool-II 利用了复制的功能以降低每台 PostgreSQL 服务器的负载。它通过分发 SELECT 查询到所有可用的服务器中，增强了系统的整体吞吐量。在理想的情况下，读性能应该和 PostgreSQL 服务器的数量成正比。负载均衡功能在有大量用户同时执行很多只读查询的场景中工作的效果最好。 并行查询 使用并行查询时，数据可以被分割到多台服务器上，所以一个查询可以在多台服务器上同时执行，以减少总体执行时间。并行查询在查询大规模数据的时候非常有效。 现有的数据库应用程序基本上可以不需要修改就可以使用 pgpool-II start ## 安装pgpool-ii brew install pgpool-ii ## 安装扩展 create extension pgpool_recovery; ## If you are using PostgreSQL 9.4 or later, you can skip this section. create extension pgpool_regclass; ## 修改配置文件 常用命令 &amp;lt;!</description></item><item><title>pg中为存储过程添加进度</title><link>https://blog.chenkai.life/database/pg_how_to_add_process_in_function/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_how_to_add_process_in_function/</guid><description>有时我们可能需要知道长时间调用存储过程的进度。
通过外部表 首先我想到通过修改一张外部表更新存储过程的进度，后来发现这样是不行的。存储过程执行中对数据库的改变在外部是获取不到的，它只有在执行完毕提交后，我们才能获取结果，所以这种方式我们获取到的进度可能全都是100%。
raise RAISE语句可以在sql运行过程中向程序抛出消息或错误，文档
用法如下所示： sql
RAISE INFO &amp;#39;model_progress:%&amp;#39;,json_build_object(&amp;#39;job_uid&amp;#39;,job_uid,&amp;#39;job_progress&amp;#39;,progress); 程序中我们还可以获取到存储过程抛出的消息：如node实现所示
const pool = new Pg.Pool(Config.db); pool.on(&amp;#39;connect&amp;#39;, (cl) =&amp;gt; { cl.on(&amp;#39;notice&amp;#39;, (msg)=&amp;gt; { //获取sql抛出的信息 DbNoticeHandler.handle(msg); }); });</description></item><item><title>pg中如何取消正在执行的存储过程</title><link>https://blog.chenkai.life/database/cancel_runing_function/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/cancel_runing_function/</guid><description>如果存储过程执行过程，需要添加可以取消的功能，这里我们需要用到两个函数。
pg_backend_pid: 查询当前会话的服务器进程的进程ID， pg_cancel_backend(pid int): 取消后端的当前查询。如果调用角色是其后端被取消或已授予调用角色的角色的成员，则也允许这样做pg_signal_backend，但是只有超级用户可以取消超级用户后端。 demo 在函数中查询当前的pid create or replace function pg_cancel_backend() returns void as $$ declare backend_pid bigint; begin --查询当前pid backend_pid = pg_backend_pid(); loop raise notice &amp;#39;%&amp;#39;, format(&amp;#39;%1$s : backend_pid: %2$s&amp;#39;, now(),backend_pid); perform pg_sleep(2); end loop; end; $$ language plpgsql; -- 2019-07-25 03:47:30.783608+00 : backend_pid: 13677 根据pid取消当前进程 select pg_cancel_backend(13677);</description></item><item><title>pg中如何查询Geometry类型字段的坐标系</title><link>https://blog.chenkai.life/database/pg_get_geometry_type/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_get_geometry_type/</guid><description>查询坐标系的方式 如没有显示指定 geometry(${geometryType},3857)
-- 查询到的坐标系是正确 select ST_SRID(the_geom_webmercator) from data.t_caa6d99c6eb14495b2238b4c0d56f051 -- 查询到的坐标系是0 select Find_SRID(&amp;#39;data&amp;#39;,&amp;#39;t_bcccd400c5bc8025aa0eed5fd5816de5&amp;#39;,&amp;#39;the_geom_webmercator&amp;#39;); select * from geometry_columns where f_table_name = &amp;#39;t_bcccd400c5bc8025aa0eed5fd5816de5e&amp;#39;</description></item><item><title>pg中对中文字段的排序</title><link>https://blog.chenkai.life/database/pg_chinese_order/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_chinese_order/</guid><description>PostgreSQL中对字段排序时中文并不会按照拼音排序，在不同的字符集中，汉字的编码可能不一样，比如UTF8和GBK，其中GBK大致是按拼音的顺序进行编码的，而UTF8则不是。所以如果你的数据库使用了UTF8编码，对中文字段进行排序时，得到的并不是按拼音排序的结果。 PostgreSQL中，中文按拼音排序的编码包括GB18030, EUC_CN, GBK, BIG5, EUC_TW 等。为了得到拼音排序，可以使用编码转换后的值来排序，如convert_to(name,'GBK')。
对于多音字、生僻字排序结果不太准确：如根据汉字内码扩展规范(GBK) 在GBK编码10进制濮编码为58791，总编码为55260,</description></item><item><title>pg中的数据库时区</title><link>https://blog.chenkai.life/database/pg_timezone/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_timezone/</guid><description>原因 系统主机与数据库时间不一致； 数据库配置文件中timezone与镜像系统里面设置的时区不一致
解决办法 修改数据库/var/lib/postgresql/data/postgresql.conf中的timezone或者镜像时区保持一致后重启数据库
timestamp with time zone，内部存储的值始终为UTC（通用协调时间，传统上称为格林威治标准时间）。具有指定显式时区的输入值将使用该时区的适当偏移量转换为UTC。如果输入字符串中未指定时区，则假定它位于系统的timezone参数指示的时区中，并使用区域的偏移量转换为UTC 。当一个timestamp with time zone值被输出，它总是从UTC转换成当前timezone区域，并作为在该区域中的本地时间显示。
步骤 查看数据库时区
show time zone; 查看系统时间与时区
date Thu Nov 19 09:39:58 CST 2015 date -R Thu, 19 Nov 2015 09:40:33 +0800 视图pg_timezone_names保存了所有可供选择的时区
select * from pg_timezone_names; 查看配置文件中时区设置，要想永久生效，此时需要修改配置文件
[grep timezone postgresql.conf log_timezone = 'US/Pacific' timezone = 'US/Pacific' 修改完配置时重新加载
[postgres@rudy_01 ~]$ pg_ctl reload server signaled [postgres@rudy_01 ~]$ psql postgres=# show time zone; TimeZone</description></item><item><title>pg的数据库配置</title><link>https://blog.chenkai.life/database/pg_config/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_config/</guid><description>config一般文件在数据data目录下面如:/usr/local/var/postgres，如果你忘记了目录地址可以SHOW data_directory;查询出来,或者
select setting from pg_settings where name = &amp;#39;config_file&amp;#39;; -- 查询配置 table pg_hba_file_rules -- 使配置生效 SELECT pg_reload_conf(); pg_hba.conf文件介绍
pg_hba.conf文件 客户端认证是由一个配置文件(通常名为pg_hba.conf)控制的， 它存放在数据库集群的数据目录里。HBA的意思是&amp;quot;host-based authentication&amp;rdquo;， 也就是基于主机的认证。在initdb初始化数据目录的时候， 它会安装一个缺省的pg_hba.conf文件。不过我们也可以把认证配置文件放在其它地方； 参阅hba_file配置参数。 g_hba.conf文件的常用格式是一组记录，每行一条。空白行将被忽略， 井号#开头的注释也被忽略。记录不能跨行存在。 一条记录是由若干用空格和/或制表符分隔的字段组成。如果字段用引号包围，那么它可以包含空白。 在数据库、用户或地址文件中引用一个关键词（如，all 或 replication） 使这个词失去它的特殊含义，只是用这个名字匹配一个数据库、用户或主机。
每条记录声明一种连接类型、一个客户端 IP 地址范围(如果和连接类型相关的话)、 一个数据库名、一个用户名字、对匹配这些参数的连接使用的认证方法。第一条匹配连接类型、 客户端地址、连接请求的数据库名和用户名的记录将用于执行认证。这个处理过程没有 &amp;ldquo;跨越&amp;quot;或者&amp;quot;回头&amp;quot;的说法：如果选择了一条记录而且认证失败， 那么将不再考虑后面的记录。如果没有匹配的记录，那么访问将被拒绝。
每条记录可以是下面七种格式之一
local database user auth-method [auth-options] host database user address auth-method [auth-options] hostssl database user address auth-method [auth-options] hostnossl database user address auth-method [auth-options] host database user IP-address IP-mask auth-method [auth-options] hostssl database user IP-address IP-mask auth-method [auth-options] hostnossl database user IP-address IP-mask auth-method [auth-options] `` ## demo 允许在本机上的任何用户使用 Unix 域套接字(本地连接的缺省) 以任何数据库用户身份连接任何数据库 TYPE DATABASE USER ADDRESS METHOD local all all trust</description></item><item><title>pg触发器</title><link>https://blog.chenkai.life/database/pg_trigger/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_trigger/</guid><description>触发器 一个触发器声明了当执行一种特定类型的操作时数据库应该自动执行一个特殊的函数。触发器可以被附加到表（分区的或者不分区的）、视图和外部表。 在表和外部表上，触发器可以被定义为在 INSERT、UPDATE或 DELETE操作之前或之后被执行， 可以为每个SQL语句被执行一次或者为每个修改的行 被执行一次。UPDATE 触发器可以进一步地设置为只针对UPDATE 语句的SET子句的特定列出发。触发器也可以被 TRUNCATE语句触发。如果一个触发器事件发生， 触发器函数会在适当的事件被调用来处理该事件。
触发器函数必须在触发器本身被创建之前被定义好。触发器函数必须被定义成一个没有参数的函数，并且返回类型为trigger（触发器函数通过一个特殊传递的TriggerData结构作为其输入，而不是以普通函数参数的形式）。 一旦一个合适的触发器函数被创建，就可以使用CREATE TRIGGER建立触发器。同一个触发器函数可以被用于多个触发器。
触发器函数规则 当一个PL/pgSQL函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：
NEW 数据类型是RECORD；该变量为行级触发器中的INSERT/UPDATE操作保持新数据行。在语句级别的触发器以及DELETE操作，这个变量是null。 OLD 数据类型是RECORD；该变量为行级触发器中的UPDATE/DELETE操作保持新数据行。在语句级别的触发器以及INSERT操作，这个变量是null。 TG_NAME 数据类型是name；该变量包含实际触发的触发器名。 TG_WHEN 数据类型是text；是值为BEFORE、AFTER或INSTEAD OF的一个字符串，取决于触发器的定义。 TG_LEVEL 数据类型是text；是值为ROW或STATEMENT的一个字符串，取决于触发器的定义。 TG_OP 数据类型是text；是值为INSERT、UPDATE、DELETE或TRUNCATE的一个字符串，它说明触发器是为哪个操作引发。 TG_RELID 数据类型是oid；是导致触发器调用的表的对象 ID。 TG_RELNAME 数据类型是name；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用TG_TABLE_NAME替代。 TG_TABLE_NAME 数据类型是name；是导致触发器调用的表的名称。 TG_TABLE_SCHEMA 数据类型是name；是导致触发器调用的表所在的模式名。 TG_NARGS 数据类型是integer；在CREATE TRIGGER语句中给触发器函数的参数数量。 TG_ARGV[] 数据类型是text数组；来自CREATE TRIGGER语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于tg_nargs）会导致返回一个空值。 一个触发器函数必须返回NULL或者是一个与触发器为之引发的表结构完全相同的记录/行值。 一个 PL/pgSQL 触发器函数 触发器函数说明文档
这个例子触发器保证：任何时候一个行在表中被插入或更新时，当前用户名和时间也会被标记在该行中。并且它会检查给出了一个雇员的姓名以及薪水是一个正值。
CREATE TABLE emp ( empname text, salary integer, last_date timestamp, last_user text ); CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$ BEGIN -- 检查给出了 empname 以及 salary IF NEW.</description></item><item><title>postgres 有用的sql</title><link>https://blog.chenkai.life/database/pg_useful_sql/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_useful_sql/</guid><description>数据库迁移备份 备份：pg_dump -U postgres -d myDBname -f dump.sql 还原：
pg_dump -U postgres -d g-default -f g-default.sql
忽略某些schema psql -N data -N public_data -d g-default -U postgres -f g-default.sql
将mydb数据库转储到一个 SQL 脚本文件：pg_dump mydb &amp;gt; db.sql 将上述脚本导入一个(新建的)数据库newdb：psql -d newdb -f db.sql
将数据库转储为自定义格式的归档文件pg_dump -Fc mydb &amp;gt; db.dump 将数据库转储为目录格式归档：pg_dump -Fd mydb -f dumpdir 将数据库转储为目录格式归档，并行5个worker工作：pg_dump -Fd mydb -j 5 -f dumpdir 将归档文件导入一个(新建的)数据库newdb：pg_restore -d newdb db.dump
转储一个名为mytab的表：pg_dump -t mytab mydb &amp;gt; db.sql 转储detroit模式中所有以emp开头的表， 但是不包括employee_log表：pg_dump -t 'detroit.</description></item><item><title>postgresql中的sequence</title><link>https://blog.chenkai.life/database/pg_sequence/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_sequence/</guid><description>sequence号是数据库系统按照一定规则自增的数字序列 sequence操作函数
Function Return Type Description currval(regclass) bigint Return value most recently obtained with nextval for specified sequence lastval() bigint Return value most recently obtained with nextval for any sequence nextval(regclass) bigint Advance sequence and return new value setval(regclass, bigint) bigint Set sequence&amp;#39;s current value setval(regclass, bigint, boolean) bigint Set sequence&amp;#39;s current value and is_called flag 创建sequence postgre文档
sequence操作函数定义
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] name [ AS data_type ] [ INCREMENT [ BY ] increment ] [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ] [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ] [ OWNED BY { table_name.</description></item><item><title>postgre中的复合类型</title><link>https://blog.chenkai.life/database/pg_composite_type/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_composite_type/</guid><description>声明复合类型 Composite Types:复合类型Composite Types表示行或记录的结构; 它本质上只是一个字段名称及其数据类型。 PostgreSQL允许复合类型像用简单类型相同的方式使用。 例如，表的列可以声明为复合类型。 语法与CREATE TABLE相当，只是可以指定字段名称和类型; 目前不能包含任何约束（例如NOT NULL）。 请注意，AS关键字是必不可少的; 没有它，系统会认为有一种不同的CREATE TYPE命令，你会得到奇怪的语法错误。 以下是定义复合类型的两个简单示例：
CREATE TYPE complex AS ( r double precision, i double precision ); CREATE TYPE inventory_item AS ( name text, supplier_id integer, price numeric ); 定义了类型后，我们可以使用它们：
CREATE TABLE on_hand ( item inventory_item, count integer ); INSERT INTO on_hand VALUES (ROW(&amp;#39;fuzzy dice&amp;#39;, 42, 1.99), 1000); CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric AS &amp;#39;SELECT $1.price * $2&amp;#39; LANGUAGE SQL; SELECT price_extension(item, 10) FROM on_hand; 每当您创建表时，也会自动创建一个复合类型，其名称与表的名称相同，以表示表的行类型。</description></item><item><title>redis的五种数据结构及其使用场景</title><link>https://blog.chenkai.life/posts/redis_use_scene/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/redis_use_scene/</guid><description>from https://www.cnblogs.com/ottll/p/9470480.html
String 常用命令：
get、set、incr、decr、mget等
应用场景：
String是最常用的数据类型，普通的key/value都可以归为此类，value其实不仅是String，也可以是数字。
比如想知道什么时候封锁一个IP地址(访问超过几次)。INCRBY命令让这些变得很容易，通过原子递增保持计数。
实现方式：
m,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。
2.Hash
常用命令：
hget、hset、hgetall等
应用场景：
比如我们要存储一个用户的信息，包含以下信息：
用户ID，为查找的key
存储的value用户对象包含姓名name，年龄age，生日birthday 等信息
如果以普通的key/value结构存储，主要有以下两种存储方式：
第一种方式将用户id作为key，其他信息封装成对象以序列化的方式存储，如
set u001 &amp;ldquo;李三,18,20010101&amp;rdquo;
这种方式的缺点，增加了序列化/反序列化的开销；需要修改其中一项信息时，需要把整个对象取回，修改操作需要对并发进行保护，引入CAS等复杂问题。
第二种方式是这个用户信息有多少成员就存成多少个key-value对，用用户id+对应属性名称作为唯一的标识来取得对应属性的值，如：
mset user:001:name &amp;ldquo;李三 &amp;ldquo;user:001:age18 user:001:birthday &amp;ldquo;20010101&amp;rdquo;
虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费较大。
redis提供的hash很好的解决了这个问题，redis的hash实际是内部存储的value为一个HashMap，并且提供了直接存取这个map的成员接口。如
hmset user:001 name &amp;ldquo;李三&amp;rdquo; age 18 birthday &amp;ldquo;20010101&amp;rdquo;
也就是说，key仍然是用户id，value是一个map，这个map的key是成员的属性名，value是属性值。
这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。
实现方式：
Redis的Hash对应的Value内部实际就是一个HashMap，实际有两种不同的实现，如果成员较少时，Redis为了节省内存会采用类似一维数组方式存储，对应的value RedisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap，此时encoding为ht。
3.List
常用命令：
lpush,rpush,lpop,rpop,lrange,BLPOP(阻塞版)等。
应用场景：
最新消息排行。
消息队列。利用Lists的push的操作，将任务存储在list中，然后工作线程再用pop操作将任务取出进行执行。
实现方式：
redis list的实现是一个双向链表，可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，redis内部的很多实现，包括发送缓冲队列等也都用的是这个数据结构。
Set 常用命令：
sadd,srem,spop,sdiff ,smembers,sunion 等。
应用场景：
set类似list，特殊之处是set可以自动排重。
set还提供了某个成员是否在一个set内的接口，这个也是list没有的。
比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。
Redis还为集合提供了求交集、并集、差集等操作。
实现方式：
set内部实现是一个value永远为null的HashMap，实际就是通过hash的方式快速排重的。</description></item><item><title>Reflect和Proxy</title><link>https://blog.chenkai.life/javascript/js_reflect_and_proxy/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_reflect_and_proxy/</guid><description>Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，
new Proxy()表示生成一个Proxy实例， target参数表示所要拦截的目标对象， handler参数也是一个对象，用来定制拦截行为。 var proxy = new Proxy({}, { get: function(target, property) { return 35; } }); proxy.time // 35 proxy.name // 35 proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。
如果handler没有设置任何拦截，那就等同于直接通向原对象。
let peo = {}; let proxyP = new Proxy(peo,{}); proxyP.name = &amp;#39;ck&amp;#39;; peo.name //&amp;#39;ck&amp;#39; 下面是 Proxy 支持的拦截操作一览，一共 13 种。</description></item><item><title>rewire库</title><link>https://blog.chenkai.life/posts/package_rewire/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/package_rewire/</guid><description>如果模块未导出一些函数，则模块外部的测试代码无法调用该功能。那是由于JavaScript的工作方式，有时我们希望测试局部函数。 rewire库在模块中添加了一个特殊的setter和getter，因此您可以修改它们的行为以进行更好的单元测试 rewire库功能：
为其他模块或全局变量（如进程）注入模拟 测试私有变量 覆盖模块中的变量 rewire接口 rewire(filename: String): rewiredModule Returns a rewired version of the module found at filename. Use rewire() exactly like require().
rewiredModule.__set__(name: String, value: *): Function Sets the internal variable name to the given value. Returns a function which can be called to revert the change.
rewiredModule.__set__(obj: Object): Function Takes all enumerable keys of obj as variable names and sets the values respectively.</description></item><item><title>sequelize建立表关系</title><link>https://blog.chenkai.life/nodejs/sequelize_associations/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/sequelize_associations/</guid><description>Associations Sequelize supports the standard associations: One-To-One, One-To-Many and Many-To-Many.
To do this, Sequelize provides four types of associations that should be combined to create them:
The HasOne association The BelongsTo association The HasMany association The BelongsToMany association The guide will start explaining how to define these four types of associations, and then will follow up to explain how to combine those to define the three standard association types (One-To-One, One-To-Many and Many-To-Many).</description></item><item><title>shell 命令</title><link>https://blog.chenkai.life/tools/shell/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/shell/</guid><description>查看可用的shellcat /etc/shells 切换shell工具chsh -s /bin/bash 使环境变量生效source ~/.zshrc
mac开机自动运行shell脚本 chmod +x ./test.sh #使脚本具有执行权限 系统偏好设置 》 用户与群组 》登录项 》 添加shell脚本 执行shell脚本 作为可执行程序 chmod +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 作为解释器参数 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： /bin/sh test.sh /bin/php test.php shell find 示例 - 查找命令 find /dir/to/search -name &amp;quot;file-to-search&amp;quot; find /dir/to/search -name &amp;quot;file-to-search&amp;quot; -print find /dir/to/search -name &amp;quot;file-to-search&amp;quot; -ls find /dir/to/search -name &amp;quot;regex&amp;quot; -print 要查找当前目录下的所有的Perl（特等）文件： $ find .</description></item><item><title>ubuntu添加pgrouting扩展</title><link>https://blog.chenkai.life/database/pg_ubuntu_add_pgrouting/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/pg_ubuntu_add_pgrouting/</guid><description>sudo apt-add-repository -y ppa:ubuntugis/ppa sudo apt-add-repository -y ppa:georepublic/pgrouting sudo apt-get update ubuntu apt 官方存储库没有pgrouting。所以需要添加存储库 在Ubuntu或Debian上安装软件的众多方法之一是使用PPA（个人包存档），如果要添加新的PPA存储库，则必须以下列方式使用add-apt-repository命令
add-apt-repository ppa:some/ppa 在Debian中，基本操作系统和 有时 在Ubuntu上，您将看到缺少add-apt-repository命令的错误。
但是如果你尝试使用sudo apt-get install add-apt-repository，它将无法正常工作。 这是因为，你需要安装这个软件包才能安装add-apt-repository。修复add-apt-repository-command-not-found错误
apt-get update apt-get install software-properties-common 一旦安装了software-properties-common，您现在可以轻松地使用add-apt-repository或apt-add-repository命令来添加PPA
查询pgrouting版本
apt search pgrouting 安装对应版本的pgrouting
apt-get install postgresql-10-pgrouting 数据库中添加pgrouting扩展
CREATE EXTENSION pgrouting;</description></item><item><title>vue_nextTick的原理</title><link>https://blog.chenkai.life/web/vue_nexttick/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/vue_nexttick/</guid><description>nextTick是vue的一个全局API， 作用是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
const callbacks = [] let pending = false function flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &amp;lt; copies.length; i++) { copies[i]() } } // Here we have async deferring wrappers using microtasks. // In 2.</description></item><item><title>vue实践</title><link>https://blog.chenkai.life/web/vue_guide/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/vue_guide/</guid><description>参考vue风格指南 参考vue编程指南
Vue Router 路由懒加载 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载
规范 vue文件内css样式尽量使用局部样式。全局样式可以统一放入静态库由app.vue文件导入
注意事项 vue data中的对象状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新
最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, 'newProp', 123), 或者 以新对象替换老对象。例如，利用对象展开运算符我们可以这样写： state.obj = { ...state.obj, newProp: 123 }</description></item><item><title>vue样式dev和build下不一致</title><link>https://blog.chenkai.life/web/vue_page_style_dev_build_different/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/vue_page_style_dev_build_different/</guid><description>一次更新镜像后发现vue项目页面混乱，在开发模式模式下，写的样式有效，打包后无效
一、多个相同样式文件同时存在项目中 现象：修改组件时，在项目中复制了一个组件重命名后进行修改，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：在本地试图修改总是不见效果，在控制台查看样式仍是之前的样式，把其中一处样式在所有相关组件中修改，打包上传后样式生效，这说明是旧的样式在打包时覆盖了新的样式。将旧组件删除后解决上述问题。 原因猜测：因为相同组件包含不同样式时，无法判断哪份样式时在后面渲染，如果旧样式刚好打包后在后面渲染，则会覆盖掉新写的样式。在本地执行时，因为样式没有打包，访问页面时渲染的都是组件自身样式，所以不会出现上述问题。
二、全局(main.js)引用样式 现象：在全局引入了Element UI 样式，在header组件中修改部分样式，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：因为在项目中段发现该问题，以为是后续的样式造成的影响(虽然我也认为可能性极小)，删除新写的组件，没有效果。运行一段时间之前的代码，项目正常运行，这迫使我回想中间这段时间对项目做了什么？除了新写了一些组件，还将一些配置信息从index.js中转移到了main.js中，测试发现果然是这里出现了问题。配置中同时出现了Element UI 样式文件引用，还有router的引用，将yang样式引用放在router引用后解决问题。 原因猜测：不正常的样式显示的还是组件原始的样式，由此猜测router加载时会加载组件样式，将样式文件在router后引用会将router加载时渲染的样式覆盖掉，所以建议将router的引用放在最后面。在每个组件的样式中记得添加 ‘scoped’.
import &amp;#39;element-ui/lib/theme-chalk/index.css&amp;#39; //element样式文件 import App from &amp;#39;./App&amp;#39; 如果相反，那么element-ui的样式会覆盖自定义的样式，所以会出现你修改的样式不生效问题！！</description></item><item><title>vue项目添加单元测试</title><link>https://blog.chenkai.life/web/vue_test/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/vue_test/</guid><description>创建vue的单元测试项目
vue-cli 创建项目 vue create vue-test Vue CLI 3可以向项目组中直接添加unit-jest vue add @vue/unit-jest 可以发现项目中多了很多文件，并且已经创建了一个测试文件demo，
进行测试 vue在添加单元测试框架时会在package.jsonscripts添加一个test:unit，我们可以允许此命令打开测试
在vue版本过低的项目中添加单元测试 我们可以选择以下两种方式
升级vue版本及其依赖 vue版本如果太旧的不支持此种方式直接添加单元测试,可以选择更新vue版本2.5以上，并更新其依赖库。 此种方法可能会出现浏览器报exportes错误，把.babelrc文件transform-runtime删除即可。
采用旧版本方式 Note: This example is outdated. It&amp;rsquo;s now recommended to scaffold your project with Vue CLI 3 which provides out-of-the-box configurations for unit testing.
vue-test-utils-jest-example Example project using Jest + vue-test-utils together</description></item><item><title>WebAssembly上手</title><link>https://blog.chenkai.life/posts/webassembly/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/webassembly/</guid><description>WebAssembly是什么 WebAssembly是为高效执行和紧凑表示而设计的运行在现代处理器（包括浏览器）中的一种快速、安全、可移植的底层代码格式，具有紧凑的二进制格式，可以以接近本机的性能运行。2019年12月5日W3C宣布WebAssembly核心规范成为正式标准。名字上可以知道是给Web使用的汇编语言。但是WebAssembly并不是直接用汇编语言，而提供了转换机制（LLVM IR），把高级别的语言（AssemblyScript、go、C、C++、Rust等）编译为WebAssembly，以便有机会通过Web浏览器执行低级二进制语法 。
WebAssembl的特点 WebAssembly是一门不同于JavaScript的语言，它不是用来取代JavaScript的。相反，它被设计为和JavaScript一起协同工作，从而使得网络开发者能够利用两种语言的优势，通过使用WebAssembly的JavaScriptAPI，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。
快速：大幅度提高 Javascript 的性能，以接近本机的代码性能执行。 安全：代码经过验证并在内存安全沙盒环境中执行，可防止数据损坏或安全漏洞。 与语言无关：允许任何语言编译到WebAssembly， 可以用其他高级语言写网页。 与硬件无关：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。 与平台无关：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。 紧凑：具有比典型的文本或本机代码格式小的传输速度快的二进制格式。 模块化：程序可以分成较小的部分，可以分别传输，缓存和使用。 高效：可以通过快速一次通过来解码，验证和编译，等同于实时（JIT）或提前（AOT）编译。 Streamable：允许在看到所有数据之前尽快开始解码，验证和编译。 为什么WebAssembly比JavaScript 执行效率更高 WebAssembly最吸引人的特点便是它的执行效率，比JavaScript执行效率更高主要有以下原因：
文件获取阶段：WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段：WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段：WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段：WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码&amp;lt;-&amp;gt;重优化”现象。 执行阶段：WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。 如何使用WebAssembly 高级语言编译到 .wasm 文件 WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。 想要编译成WebAssembly，你首先需要先编译 LLVM，参考webassembly.</description></item><item><title>webpack总结</title><link>https://blog.chenkai.life/posts/webpack/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/webpack/</guid><description>loader webpack 可以使用 loader 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。你可以使用 Node.js 来很简单地编写自己的 loader。loader 通过在 require() 语句中使用 loadername! 前缀来激活，或者通过 webpack 配置中的正则表达式来自动应用;
import Worker from &amp;#39;worker-loader!./Worker.js&amp;#39;; // 或者 { module: { rules: [ { test: /\.worker\.js$/, use: { loader: &amp;#39;worker-loader&amp;#39; } } ] } } 懒加载 代码分离 shimming 一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 $）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 shimming 发挥作用的地方。 使用 ProvidePlugin 后，能够在通过 webpack 编译的每个模块中，通过访问一个变量来获取到 package 包。如果 webpack 知道这个变量在某个模块中被使用了，那么 webpack 将在最终 bundle 中引入我们给定的 package。 本质上，我们所做的，就是告诉 webpack……</description></item><item><title>WebWorker</title><link>https://blog.chenkai.life/web/web-worker/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/web-worker/</guid><description>一、概述 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。
Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。
Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。
Web Worker 有以下几个使用注意点。
（1）同源限制
分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。
（2）DOM 限制
Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。
（3）通信联系
Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
（4）脚本限制
Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。
（5）文件限制
Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。
二、基本用法 2.1 主线程 主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。
var worker = new Worker(&amp;#39;work.js&amp;#39;); Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</description></item><item><title>Web面试问题</title><link>https://blog.chenkai.life/hide/web_mian_shi_qs2/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/hide/web_mian_shi_qs2/</guid><description>&lt;h2 id="前端工作面试问题">
前端工作面试问题
&lt;a class="heading-link" href="#%e5%89%8d%e7%ab%af%e5%b7%a5%e4%bd%9c%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;p>本文包含了一些用于考查候选者的前端面试问题。不建议对单个候选者问及每个问题 (那需要好几个小时)。只要从列表里挑选一些，就能帮助你考查候选者是否具备所需要的技能。&lt;/p>
&lt;p>&lt;strong>备注：&lt;/strong> 这些问题中很多都是开放性的，可以引发有趣的讨论。这比直接的答案更能体现此人的能力。&lt;/p>
&lt;h2 id="a-nametoc目录a">
&lt;!-- raw HTML omitted -->目录&lt;!-- raw HTML omitted -->
&lt;a class="heading-link" href="#a-nametoc%e7%9b%ae%e5%bd%95a">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#general-questions">常见问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#html-questions">HTML 相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#css-questions">CSS 相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#js-questions">JS 相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#testing-questions">测试相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#performance-questions">效能相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#network-questions">网络相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#coding-questions">代码相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#fun-questions">趣味问题&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>yum</title><link>https://blog.chenkai.life/tools/yum/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/tools/yum/</guid><description>yum是种软件包管理器，yum 主要功能是更方便的添加/删除/更新RPM 包，自动解决包的倚赖性问题，便于管理大量系统的更新问题。yum 可以同时配置多个资源库(Repository)，简洁的配置文件（/etc/yum.conf），自动解决增加或删除rpm 包时遇到的依赖性问题，保持与RPM 数据库的一致性。
配置# yum 的配置文件分为两部分：main 和repository
main 部分定义了全局配置选项，整个yum 配置文件应该只有一个main。常位于/etc/yum.conf 中。 repository 部分定义了每个源/服务器的具体配置，可以有一到多个。常位于/etc/yum.repo.d 目录下的各文件中。 yum.conf 文件一般位于/etc目录下，一般其中只包含main部分的配置选项。
# cat /etc/yum.conf
yum.conf
除了上述之外，还有一些可以添加的选项，如：
　exclude=selinux*　// 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安装了诸如美化包，中文补丁的朋友特别有用。 gpgcheck=1　// 有1和0两个选择，分别代表是否是否进行gpg(GNU Private Guard) 校验，以确定rpm 包的来源是有效和安全的。这个选项如果设置在[main]部分，则对每个repository 都有效。默认值为0。
1. 配置本地yum源
(1) 挂载光盘
mount /dev/cdrom /mnt/ (2)配置本地yum源
查看/etc/yum.repo.d/下有四个文件
CentOS-Base.repo 是yum 网络源的配置文件
CentOS-Media.repo 是yum 本地源的配置文件
修改CentOS-Media.repo文件
#cat /etc/yum.repo.d/CentOS-Media.repo
CentOS-Media.repo
在baseurl 中修改第2个路径为 /mnt/（即为光盘挂载点）
将enabled=0改为1
(3)禁用网络yum源
将CentOS-Base.repo 重命名为CentOS-Base.repo.bak,否则会先在网络源中寻找适合的包，改名之后直接从本地源读取。 (4) 执行yum命令测试
yum install bind 关于repo的格式# 所有repository 服务器设置都应该遵循如下格式：</description></item><item><title>一个关于Promise的问题</title><link>https://blog.chenkai.life/posts/one_question_about_promise/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/one_question_about_promise/</guid><description>一道题带来的疑问 掘金上的一道题： JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个，一个解法如下：
const timeout = (time) =&amp;gt; new Promise(resolve =&amp;gt; { setTimeout(resolve, time) }); class Scheduler { constructor() { this.awaitArr = []; this.count = 0; } async add(promiseCreator) { if (this.count &amp;gt;= 2) { await new Promise(resolve =&amp;gt; { this.awaitArr.push(resolve); }); } this.count++; const res = await promiseCreator(); this.count--; if (this.awaitArr.length) { this.awaitArr.shift()(); } return res; } } const scheduler = new Scheduler() const addTask = (time, order) =&amp;gt; { scheduler.</description></item><item><title>了解什么是polyfill</title><link>https://blog.chenkai.life/javascript/polyfill/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/polyfill/</guid><description>什么是polyfill 初次了解polyfill这个词,是在一次面试中，题目是使用数组的reduse方式实现map方法，全世界使用着许多不同的浏览器和版本的浏览器，每个浏览器都具有与其他浏览器完全不同的功能集。这会使浏览器开发成为一项艰巨的任务。流行浏览器的最新版本可以完成许多旧浏览器无法完成的任务-但您可能仍必须支持旧浏览器。通过尝试使用polyfills重新创建缺少的功能，Polyfill.io使支持不同的浏览器变得更简单：您可以在支持或不支持的浏览器中利用最新和最强大的功能。
如vue中对bind的polyfill代码如下
function polyfillBind (fn, ctx) { function boundFn (a) { var l = arguments.length; return l ? l &amp;gt; 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx) } boundFn._length = fn.length; return boundFn } function nativeBind (fn, ctx) { return fn.bind(ctx) } var bind = Function.prototype.bind ? nativeBind : polyfillBind; 常用对polyfill方法 babel-polyfill 提供完整的ES2015+环境
polyfill.io polyfill.io它是一个接口，它接受一组浏览器功能的请求，并仅返回请求浏览器所需的polyfill</description></item><item><title>介绍几个表达式和运算符</title><link>https://blog.chenkai.life/javascript/js_operator/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_operator/</guid><description>空值合并运算符 ??是一个逻辑操作符，当左侧的表达式结果为 null或者 undefined时，其返回右侧表达式的结果，否则返回左侧表达式的结果。
以前，如果想为一个变量赋默认值，通常的做法是使用逻辑或操作符|| 然而，由于 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， ''， NaN， null， undefined）都不会被返回。这导致如果你使用0，''或NaN作为有效值，就会出现不可预料的后果。空值合并操作符可以避免这种陷阱，其只在第一个操作数为null 或 undefined 时（而不是其它假值）返回第二个操作数
let myText = &amp;#39;&amp;#39;; // An empty string (which is also a falsy value) let notFalsyText = myText || &amp;#39;Hello world&amp;#39;; console.log(notFalsyText); // Hello world let preservingFalsy = myText ?? &amp;#39;Hi neighborhood&amp;#39;; console.log(preservingFalsy); // &amp;#39;&amp;#39; (as myText is neither undefined nor null) //因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的 null || undefined ?? &amp;#34;foo&amp;#34;; // 抛出 SyntaxError (null || undefined ) ?</description></item><item><title>前后端通过切片上传文件</title><link>https://blog.chenkai.life/posts/web_upload_file/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/web_upload_file/</guid><description>最近在做前端上传文件，主要包括选择单个｜多个文件、单个｜多个文件夹、拖拽文件｜文件夹方式上传文件，上传时通过分片计算文件hash值实现断点续传、秒传功能，简要介绍下具体实行思路
获取用户选择文件 注意这种方式用到的部分特性是非标准的
拖拽上传 从可拖拽区域中获取过滤获取拖拽的文件的FileSystemEntry
async drop(e) { e.stopPropagation(); e.preventDefault(); let items = e.dataTransfer.items; let dropFilesEntrys = []; for (let item of items) { if (!item || !item.webkitGetAsEntry) continue; item = item.webkitGetAsEntry(); if (!item) continue; let filesEntrys = await this.getFilesEntrys(item); dropFilesEntrys.push(...filesEntrys); } let files = await this.transformFilesEntrys(dropFilesEntrys); this.handerFiles(files); }, 获取FileSystemEntry包含的FilesEntrys，FileSystemEntry可能代表文件系统中的文件或者目录
/** * 获取drop区域的文件 * @returns FilesEntrys */ async getFilesEntrys(item) { let filesEntrys = []; let scanFiles = async (item) =&amp;gt; { return new Promise((resolve) =&amp;gt; { if (item.</description></item><item><title>前端下载文本</title><link>https://blog.chenkai.life/javascript/brower_download_text/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/brower_download_text/</guid><description>前端保存文本 function download( text, filename) { var element = document.createElement(&amp;#39;a&amp;#39;); element.setAttribute(&amp;#39;href&amp;#39;, &amp;#39;data:text/plain;charset=utf-8,&amp;#39; + encodeURIComponent(text)); element.setAttribute(&amp;#39;download&amp;#39;, filename); element.style.display = &amp;#39;none&amp;#39;; document.body.appendChild(element); element.click(); document.body.removeChild(element); } download(&amp;#34;data.txt&amp;#34;, &amp;#34;hello word!&amp;#34;);　// 调用</description></item><item><title>前端开发面试题</title><link>https://blog.chenkai.life/hide/web_mian_shi_qs1/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/hide/web_mian_shi_qs1/</guid><description>前端开发面试题 （题目列表页） 目录 前言 HTML部分 CSS部分 JavaScript部分 其他问题 前端学习网站推荐 前言 前言
HTML Doctype作用？严格模式与混杂模式如何区分？它们有何意义?
HTML5 为什么只需要写 ？
行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？
页面导入样式时，使用link和@import有什么区别？
介绍一下你对浏览器内核的理解？
常见的浏览器内核有哪些？
html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
简述一下你对HTML语义化的理解？
HTML5的离线储存怎么使用，工作原理能不能解释一下？
浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？
请描述一下 cookies，sessionStorage 和 localStorage 的区别？
iframe有那些缺点？
Label的作用是什么？是怎么用的？（加 for 或 包裹）</description></item><item><title>前端开发面试题及答案</title><link>https://blog.chenkai.life/hide/web_min_shi_qsan/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/hide/web_min_shi_qsan/</guid><description>&lt;h2 id="前端开发面试题">
前端开发面试题
&lt;a class="heading-link" href="#%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91%e9%9d%a2%e8%af%95%e9%a2%98">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;h2 id="a-namepreface前言a-">
&lt;!-- raw HTML omitted -->前言&lt;!-- raw HTML omitted -->
&lt;a class="heading-link" href="#a-namepreface%e5%89%8d%e8%a8%80a-">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="http://markyun.github.io/2015/Front-end-Developer-Questions/" title="Questions">只看问题点这里 &lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" title="Questions-and-Answers">看全部问题和答案点这里&lt;/a>&lt;/p>
&lt;p>本文由我收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！&lt;/p></description></item><item><title>展开语法和剩余参数</title><link>https://blog.chenkai.life/javascript/js_spread_and_rest/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/javascript/js_spread_and_rest/</guid><description>展开语法 展开语法(Spread syntax),只能用于可迭代对象, 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开
a={name: &amp;#34;mdn&amp;#34;} b=[1,2,3] console.log({...a}) console.log([...b]) //函数参数 function sum(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); console.log(sum.apply(null, numbers)); //构造 var parts = [&amp;#39;shoulders&amp;#39;, &amp;#39;knees&amp;#39;]; var lyrics = [&amp;#39;head&amp;#39;, ...parts, &amp;#39;and&amp;#39;, &amp;#39;toes&amp;#39;]; // [&amp;#34;head&amp;#34;, &amp;#34;shoulders&amp;#34;, &amp;#34;knees&amp;#34;, &amp;#34;and&amp;#34;, &amp;#34;toes&amp;#34;] var obj1 = { foo: &amp;#39;bar&amp;#39;, x: 42 }; var obj2 = { foo: &amp;#39;baz&amp;#39;, y: 13 }; var clonedObj = { .</description></item><item><title>常用的一些css样式</title><link>https://blog.chenkai.life/web/css_useful_style/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/css_useful_style/</guid><description>文字超出后省略 white-space: nowrap; overflow: hidden; text-overflow: ellipsis;</description></item><item><title>手机web端调试</title><link>https://blog.chenkai.life/web/web_phone_debug_/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/web_phone_debug_/</guid><description>最近使用vue开发的一个应用，在部分手机页面中会出现时而正常时而异常的问题，由手机中调试不如桌面那么方便，想着在网上找找有没有现成的解决方案，大体分三种,下面大概介绍下
捕获错误日志将日志发送到服务器查看 前端应用通过window.onerror事件捕获错误或者重写console方法，将日志通过请求发送到后端应用
捕获错误日志把日志在前端应用查看 如腾讯的vConsole，该插件会在页面右下角插入一个按钮，点击可以打开一个类似调试页面的窗口。
主要包括以下功能:
查看 console 日志 查看网络请求 查看页面 element 结构 查看 Cookies、localStorage 和 SessionStorage 手动执行 JS 命令行 自定义插件 使用方法如下：
import VConsole from &amp;#34;vconsole&amp;#34;; new VConsole(); 通过某些特殊应用调试 如使用谷歌浏览器的开发者工具远程调试Android和iOS页面，手机和电脑使用usb连接，手机要开启usb调试模式，在电脑端浏览器输入chrome://inspect会打开设备监视页面，这里可以监视到iOS和Android设备</description></item><item><title>拷贝数据到剪贴板</title><link>https://blog.chenkai.life/web/brower_copy_to_clipboard/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/brower_copy_to_clipboard/</guid><description>介绍几种在浏览器中拷贝数据到剪贴板的方法
document.execCommand(&amp;ldquo;copy&amp;rdquo;); 拷贝当前选中内容到剪贴板, 该api已经废弃不推荐使用，
function fallbackCopyTextToClipboard(text) { const textArea = document.createElement(&amp;#34;textarea&amp;#34;); textArea.value = text; textArea.style.top = &amp;#34;0&amp;#34;; textArea.style.left = &amp;#34;0&amp;#34;; textArea.style.position = &amp;#34;fixed&amp;#34;; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { let msg = document.execCommand(&amp;#34;copy&amp;#34;); if (!msg) { throw new Error(&amp;#34;Copy filed&amp;#34;); } } finally { document.body.removeChild(textArea); } } navigator.clipboard 剪贴板 Clipboard API 提供了响应剪贴板命令（剪切、复制和粘贴）与异步读写系统剪贴板的能力。从权限 Permissions API 获取权限之后，才能访问剪贴板内容；如果用户没有授予权限，则不允许读取或更改剪贴板内容。该 API 被设计用来取代使用 document.execCommand() 的剪贴板访问方式。(基于 HTTP 的网站中包含的脚本则不能获得剪贴板对象)
await navigator.clipboard.writeText(data); npm package clipboard, 内部使用的 document.</description></item><item><title>数据库关系类型</title><link>https://blog.chenkai.life/database/db_relational/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/database/db_relational/</guid><description>关联映射：一对一 一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。 数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。
一对一外键关联，图示如下：
一对一主键关联：要求两个表的主键必须完全一致，通过两个表的主键建立关联关系。图示如下： 关联映射：一对多/多对一 存在最普遍的映射关系，简单来讲就如球员与球队的关系； 一对多：从球队角度来说一个球队拥有多个球员 即为一对多 多对一：从球员角度来说多个球员属于一个球队 即为多对一数据表间一对多关系如下图：
关联映射：多对多 多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。 数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多。 数据表间多对多关系如下图： 对于Postgresql也有通过数组表示多对多关系，参考下面文章 https://medium.com/@leshchuk/mtm-on-arrays-in-postgresql-a97f3c50b8c6</description></item><item><title>流读取json</title><link>https://blog.chenkai.life/nodejs/stream_read_geojson/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/nodejs/stream_read_geojson/</guid><description>流读取json需要用到两个库JSONStream和es
JSONStream 流JSON.parse
JSONStream.parse(&amp;quot;JSONPath表达式&amp;quot;) JSONPath表达式 JSONPath表达式始终引用JSON结构，其方式与XPath表达式与XML文档结合使用的方式相同。由于JSON结构通常是匿名的，并且不一定具有“根成员对象”，因此JSONPath假定$分配给外部对象的抽象名称 例子：
$.store.book[0].title $['store']['book'][0]['title'] XPath和JSONPath语法
XPath JSONPath Description / $ the root object/element . @ the current object/element / . or [] child operator .. n/a parent operator // .. recursive descent. JSONPath borrows this syntax from E4X. * * wildcard. All objects/elements regardless their names.</description></item><item><title>浏览器处理cookie</title><link>https://blog.chenkai.life/web/cookie/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/cookie/</guid><description>设置cookie function setCookie(options) { const { name, data } = options; const age = options.age || 24 * 3600000; const domain = options.domain || window.location.hostname; document.cookie = `${name}=${data}; path=/; max-age=${age}; domain=${domain}`; } 获取cookie function getCookie(cookie_name) { let value = null; let allcookies = document.cookie; let cookie_pos = allcookies.indexOf(cookie_name); if (cookie_pos != -1) { cookie_pos = cookie_pos + cookie_name.length + 1; let cookie_end = allcookies.indexOf(&amp;#34;;&amp;#34;, cookie_pos); if (cookie_end == -1) { cookie_end = allcookies.</description></item><item><title>浏览器如何渲染页面</title><link>https://blog.chenkai.life/web/how_brower_render_page/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/web/how_brower_render_page/</guid><description>参考https://coolshell.cn/articles/9666.html
文章是为了说明浏览器如何将HTML，CSS和JavaScript转换为网站。
首先 浏览器是一个可以从远程服务器或者本地磁盘将文件加载、显示、交互的软件。
浏览器有两个重要部分：
渲染引擎（Rendering Engine）：一般习惯称为“浏览器内核”，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同如Gecko（火狐）、Blink（Chrome）、Webkit（Safari）、Trident（IE）等，因此同一网页在不同的内核的浏览器里的渲染效果也可能不同。
JavaScript引擎：JavaScript由ECMAScript，DOM和BOM三者组成，不同浏览器针对JavaScript语法和语义标准有多种实现如：
Chrome使用V8引擎， Safari使用JavaScriptCore， Firefox使用SpiderMonkey 浏览器接收数据 数据是通过Internet以数据包（Packet）为单位按字节形式发送到浏览器。浏览器将从硬盘（或网络）中读取HTML的原始数据字节转换为字符。
从原始字节到DOM 当浏览器接受到扩展名为.html时，会将该文件解释为html对其进行解析，文件中的每个开始和结束html标签会转换为节点如
&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; 创建这些节点后，然后将这些节点链接到称为DOM的树数据结构中。DOM建立父子关系，相邻的兄弟关系等。每个节点之间的关系都在此DOM对象中建立。浏览器必须先将html数据的原始字节转换为DOM，然后才能进行任何操作。
当浏览器接收数据的原始字节并启动DOM构造过程时，它还将发出请求以获取链接的样式表。 一旦浏览器开始解析html，一旦找到文件的link标签，浏览器css就会同时发出获取请求的请求。
从原始字节到CSSOM 当浏览器收到CSS的原始字节时，也会启动HTML原始字节的类似过程。将数据的原始字节转换为字符，然后标记化节点，最后还形成CSS树结构，称为CSS对象模型，简称CSSOM。 CSS有一个叫做Cascade的东西。级联是浏览器如何确定将哪些样式应用于元素的方式。
由于影响元素的样式可能来自父元素（即通过继承），或者已设置在元素本身上，因此CSSOM树结构变得很重要。浏览器必须递归地遍历CSS树结构并确定影响特定元素的样式。
渲染树 DOM和CSSOM树结构是两个独立的结构。DOM包含有关页面HTML元素的关系的所有信息，而CSSOM包含有关元素样式的信息。浏览器现在将DOM和CSSOM树合并为一个称为渲染树(render tree)的东西。渲染树包含有关页面上所有可见DOM内容的信息，以及不同节点所需的所有CSSOM信息。
如果一个元素被CSS隐藏，display; none例如使用，则该节点将不会在渲染树中表示。隐藏的元素将出现在DOM中，但不会出现在渲染树中。原因是渲染树结合了来自DOM和CSSOM的信息，因此它知道在树中不包括隐藏元素。
构建了渲染树后，浏览器将继续进行下一步，即 布局！
现在，我们在屏幕上拥有所有可见内容的内容和样式信息，但实际上并没有在屏幕上呈现任何内容,浏览器必须计算页面上每个对象的确切大小和位置。此布局步骤对从DOM和CSSOM接收到的内容和样式，进行了必要的布局计算，并绘制到屏幕上。DOM和CSSOM必须在成功绘制之前构建，所以优化网站的第一条规则是尽快将最重要的HTML和CSS交付给客户端。
JavaScript JavaScript可以更改DOM和CSSOM。
###Javascript执行前将停止整个DOM构造过程
由于浏览器不确定此特定Javascript会做什么，因此通过停止整个DOM结构来采取预防措施。每当浏览器遇到script标签时，在脚本完成执行之前，将停止整个DOM构造过程。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Medium Article Demo&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;style.</description></item><item><title>记录一些npm库</title><link>https://blog.chenkai.life/posts/npm_packages/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/posts/npm_packages/</guid><description>记录一些常用端库
npm工具库 nodeppt: markdown 生成web ppt artillery: 负载接口测试 jsdoc,esdoc,documentation:构建js帮助文档 standard-version:使用semver和常规提交消息自动进行版本控制和CHANGELOG生成 Marked:markdown解析成html markdown-it: markdown解析成html dockerode: Docker远程API模块 nodemon: 文件更改时重新启动node服务 cypress: 端到端测试框架 eslint:eslint是一个javascript代码检测工具 ngrok: 内网穿透工具
axios:基于Promise的HTTP客户端，用于浏览器和node.js ws:简单易用，为Node.js开辟了快速且经过全面测试的Websocket客户端和服务器 nuxtjs: 一个基于 Vue.js 的服务端渲染应用框架 fake-progress: 一个生成假进度的库 diff.js: 一个JavaScript文本diff实现 GraphQL.js:GraphQL的JavaScript参考实现，GraphQL是Facebook创建的API的查询语言。 JSONStream：流读取josn解析 http-proxy-middleware:node.js代理中间件，用于连接，表达和浏览器同步 iconv-lite: 文件编码转换 workerpool: workerpool提供了一种简单的方法来创建工作池，以动态卸载计算并管理专用工作池,runs on node.js, Chrome, Firefox, Opera, Safari, and IE10+. graphql: api查询数据语言 apollo-server: 封装的graphql @koa/router: 由koa-router修改而来 js-yaml: js解析yaml Knex &amp;amp; objection &amp;amp; Sequelize node 的orm框架
c++ tippecanoe:Build vector tilesets from large collections of GeoJSON features mapnic:mapnic提供用于空间数据访问和可视化的算法和模式。</description></item><item><title>面试题</title><link>https://blog.chenkai.life/hide/mian_shi/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://blog.chenkai.life/hide/mian_shi/</guid><description>晚上面试时发挥的十分差劲，会的题也答的马马虎虎，反思自己存在以下问题
相关方法还是掌握的不够熟练，不借助编辑器提示难以下手 遇到相关算法题脑子有些混乱，冷静下来想想还是能写出来 一些至少概念了解但并不十分清楚 缺乏面试经验，脑子有些转不过来 平常没有做相关面试题，面试题还是要刷的 还记起来的面试题大概有以下题目:
array reduse 实现map方法 做不出来的原因， 对this还是不够熟悉
不用reduse实现：
Array.prototype.map = function (fun) { let mapArr = []; for (let val of this) { mapArr.push(fun.call(null, val)); } return mapArr; } [1, 2, 3].map((val) =&amp;gt; val); 使用reduse实现：
Array.prototype.map = function (fun) { let mapArr = []; this.reduce((accumulator, currentValue, index) =&amp;gt; { mapArr.push(fun.call(null, this[index])); },null); return mapArr; } koa中间件传参数，允许输入参数限制请求 function name(methods) { return async function(ctx, next){ let startDate = new Date(); if (methods.</description></item><item><title>koa跨域</title><link>https://blog.chenkai.life/nodejs/koa%E8%B7%A8%E5%9F%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.chenkai.life/nodejs/koa%E8%B7%A8%E5%9F%9F/</guid><description>跨域 为什么会有跨域问题？ 这是浏览器的同源策略所造成的，同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
一定要注意跨域是浏览器的限制，其实你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。
如何解决跨域? jsonp: 带有src属性的标签都可以用来， 但是只能处理GET请求 document.domain + iframe跨域 location.hash + iframe window.name + iframe postMessage跨域 Nginx配置反向代理 CORS（跨域资源共享）：支持所有类型的HTTP请求 相信大家对于以上的解决方法都很熟悉，这里不再对每一种方法展开讲解，接下来主要讲一下CORS； 简单请求和非简单请求 浏览器将CORS跨域请求分为简单请求和非简单请求；
如果你使用nginx反向代理解决的跨域问题，则不会有跨域请求这个说法了，因为nginx反向代理就使得前后端是同一个域了，就不存在跨域问题了。
只要同时满足一下两个条件，就属于简单请求 (1)使用下列方法之一：
head get post (2)请求的Heder是
Accept Accept-Language Content-Language Content-Type: 只限于三个值： application/x-www-form-urlencoded multipart/form-data text/plain 不同时满足上面的两个条件，就属于非简单请求。 浏览器对这两种的处理，是不一样的。
简单请求 例子 对于简单请求，浏览器直接发出CORS请求。具体来说，就是头信息之中，增加一个Origin字段。</description></item><item><title>node服务端渲染</title><link>https://blog.chenkai.life/nodejs/node%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.chenkai.life/nodejs/node%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</guid><description>服务端渲染是指，浏览器向服务器发出请求页面，服务端将准备好的模板和数据组装成完整的HTML返回给浏览器展示。 前后的分离后，浏览器加载完页面后还需要再次向服务器发起请求数据，如果我们事先将需要请求到数据放入到页面就无需加载页面后再次向服务器发起请求，减少初始初始页面加载时间 node的服务端渲染库有很多。handlebars, ejs, ejs, hbs, pug, velocityjs, Nunjucks, twig, dot,templayed
直接使用Nunjucks Nunjucks文档
// render.js const Router = require(&amp;#39;koa-router&amp;#39;) const router = new Router() const nunjucks = require(&amp;#39;nunjucks&amp;#39;); const path = require(&amp;#39;path&amp;#39;) let env = nunjucks.configure(path.join(__dirname, &amp;#39;../public&amp;#39;),{ // noCache: true, }); router.get(&amp;#39;/&amp;#39;, async (ctx, next) =&amp;gt; { ctx.body = env.render(&amp;#39;index.html&amp;#39;, { title: &amp;#39;title&amp;#39;, user: { name: &amp;#39;test&amp;#39;, age: 18 } }); }); module.exports = router app.use(render.routes(), render.allowedMethods()); 使用koa-views + Nunjucks 等 const views = require(&amp;#39;koa-views&amp;#39;) const path = require(&amp;#39;path&amp;#39;) // Must be used before any router is used app.</description></item></channel></rss>