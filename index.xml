<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CK's Blog</title><link>https://chenkai.life/</link><description>Recent content on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 25 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://chenkai.life/index.xml" rel="self" type="application/rss+xml"/><item><title>关于</title><link>https://chenkai.life/about/</link><pubDate>Thu, 25 Aug 2022 19:31:20 +0800</pubDate><guid>https://chenkai.life/about/</guid><description>这是我的博客。
其他 我的GitHub 博客存储库 联系方式 如果你有什么问题，可以在下方留言或通过下面的方式联系我。
Email: k_0520@qq.com</description></item><item><title>记录收藏的一些网站、资源等</title><link>https://chenkai.life/marks/</link><pubDate>Thu, 25 Aug 2022 19:31:20 +0800</pubDate><guid>https://chenkai.life/marks/</guid><description>网站 工具类网站 https://editor.method.ac/制作svg caniuse查询浏览器对Web标准的支持性 typora markdown编辑器，可以复制html转成markdown Unsplash 通过api获取随机图片 Weekly Visitor Report 获取访问您网站的公司的每周报告 responsively 更快的进行响应式Web开发 figma Web端的UI设计工具。 httpbin 一个简单的 HTTP 请求和响应服务 pixabay 令人惊叹的免费图片和免版税库存 技术网站 百度技术团队1 百度技术团队2 美团技术团队 文档网站 tc39:javascript规范 javascript-info教程 JavaScript 教程学习网站 You-Dont-Know-JS深入研究 JavaScript 语言核心机制的书籍 the-way-to-goGo入门指南 awesome-interview 剑指前端 Offer tackling-ts 在线代码编辑器网站 codesandbox https://codepen.io/ jsfiddle 需要VPN访问 stackblitz NPM 工具库 有趣 wired-elements: 手绘外观的基本 UI 元素 功能 iconv-lite: 文件编码转换 JSONStream：流式处理 JSON.parse 和 stringify fake-progress: 一个生成假进度的库 diff.js: 一个JavaScript文本diff实现 workerpool: workerpool提供了一种简单的方法来创建工作池，以动态卸载计算并管理专用工作池,runs on node.js, Chrome, Firefox, Opera, Safari, and IE10+.</description></item><item><title>HTTP请求传参详解</title><link>https://chenkai.life/web/http%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E8%AF%A6%E8%A7%A3/</link><pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/http%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E8%AF%A6%E8%A7%A3/</guid><description>本篇文章主要介绍了HTTP的数据结构, 以及application/x-www-form-urlencoded,multipart/form-data, application/json类型请求的编码方式。
什么是HTTP HTTP(超文本传输协议) 是服务器和客户端之间交换数据的方式。是为Web浏览器与Web服务器之间的通信而设计的有两种类型的消息︰
请求（requests）&amp;ndash; 由客户端发送用来触发一个服务器上的动作； 响应（responses）&amp;ndash; 来自服务器的应答。 HTTP请求和响应具有相似的结构，由以下部分组成︰
一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。 一个可选的 HTTP 头集合指明请求或描述消息正文。 一个空行指示所有关于请求的元数据已经发送完毕。 一个可选的包含请求相关数据的正文 (比如 HTML 表单内容), 或者响应相关的文档。 正文的大小有起始行的 HTTP 头来指定。 起始行和 HTTP 消息中的 HTTP 头统称为请求头，而其有效负载被称为消息正文。 HTTP规范 HTTP 定义了一组请求方法，以表明要对给定资源执行的操作。包括
GET: 请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据。 HEAD: 请求一个与 GET 请求的响应相同的响应，但没有响应体。 POST: 用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。 PUT: 用请求有效载荷替换目标资源的所有当前表示。 DELETE: 删除指定的资源。 CONNECTCONNECT: 建立一个到由目标资源标识的服务器的隧道。 OPTIONS: 用于描述目标资源的通信选项。 TRACE: 沿着到目标资源的路径执行一个消息环回测试。 PATCH: 用于对资源应用部分修改。 请求传参的几种方式 URL传参(Query String ) Query String是URL的一部分，采用百分比编码的方式，我们可以通过?开头并用&amp;amp;符号分隔的键-值对，同时以=分隔键和值, 如http://test.com?key1=value1&amp;amp;key2=value2来提供额外参数。为了方便构造查询字符串，我们可以使用URLSearchParams构造
// 传入字符串 new URLSearchParams(`key1=value1&amp;amp;key2=value2`).toString() // key1=value1&amp;amp;key2=value2 // 传入数组 new URLSearchParams([[&amp;#34;key1&amp;#34;, &amp;#34;value1&amp;#34;],[&amp;#34;key2&amp;#34;, &amp;#34;value2&amp;#34;]]); // key1=value1&amp;amp;key2=value2 // 传入对象 new URLSearchParams({&amp;#34;key1&amp;#34; : &amp;#34;value1&amp;#34;, &amp;#34;key2&amp;#34; : &amp;#34;value2&amp;#34;}); // 通过URL传入的参数都会被隐式地转译为百分比编码的`字符串`, 如果保护有特殊字符将被转译,非字母或数字的字符会被 percent-encoding&amp;lt;https://developer.</description></item><item><title>与滚动条相关的属性</title><link>https://chenkai.life/css/scrollbars/</link><pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/scrollbars/</guid><description>滚动条设置（overflow） 设置当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。 可选值: visible, hidden, scroll, auto, overlay
特别的: overlay: 行为与auto相同，但滚动条绘制在内容之上而不是占用空间。仅在基于 WebKit（例如，Safari）和基于 Blink 的（例如，Chrome 或 Opera）浏览器中受支持。
滚动行为（scroll-behavior） 为一个滚动框指定滚动行为
auto: 立即滚动 smoot: 平滑滚动 滚动条样式（伪类选择器） 通过下面几个伪类选择器可以设置滚动条样式
::-webkit-scrollbar——整个滚动条。 ::-webkit-scrollbar-thumb——滚动条上的滚动滑块。 ::-webkit-scrollbar-track——滚动条轨道。 ::-webkit-scrollbar-track-piece——滚动条没有滑块的轨道部分。 ::-webkit-scrollbar-corner——当同时有垂直滚动条和水平滚动条时交汇的部分。通常是浏览器窗口的右下角。 ::-webkit-scrollbar-button——滚动条上两端的按钮（上下箭头）。 ::-webkit-resizer——出现在某些元素底角的可拖动调整大小的滑块。 可用的属性
width: 滚动条宽度 height: 滚动条高度 background-color: 滚动条背景色 border: 滚动条边框 border-radius: 滚动条圆角 例子 &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; div::-webkit-scrollbar { width: 17px; height: 17px; } div::-webkit-scrollbar-button { display: block; width: 17px; height: 17px; } div::-webkit-scrollbar-button:decrement:start { background-color: lightblue; border: 2px solid black; } div::-webkit-scrollbar-button:increment:start { background-color: lightgreen; border: 2px solid black; } div::-webkit-scrollbar-button:decrement:end { background-color: orange; border: 2px solid black; } div::-webkit-scrollbar-button:increment:end { background-color: brown; border: 2px solid black; } div::-webkit-scrollbar-thumb { max-width: 10px; max-height: 10px; background-color: red; border: 2px solid #cccccc; } div::-webkit-scrollbar-track-piece:decrement { background-color: olive; } div::-webkit-scrollbar-track-piece:increment { background-color: pink; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;width:200px; height:200px; overflow-y:scroll; overflow-x:hidden&amp;#34;&amp;gt; Hello&amp;lt;br&amp;gt; Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt; Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt; Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt;Hello&amp;lt;br&amp;gt; &amp;lt;span style=&amp;#34;white-space:nowrap&amp;#34;&amp;gt;Hello world this is a long string and will not wrap.</description></item><item><title>Vue 3 UI 组件库评测</title><link>https://chenkai.life/vue/ui_framework/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/ui_framework/</guid><description> Vue 3 UI TS/JS SFC/JSX Options/Composition Desktop/Mobile/MP Style 特点 缺点 推荐 Element Plus TS SFC Composition Desktop scss setup 🌟🌟🌟🌟🌟 Ant Design Vue TS JSX Composition Desktop less React 🌟🌟🌟🌟🌟 TDesign TS JSX Composition Desktop/Mobile/MP less React/腾讯 🌟🌟🌟🌟🌟 Arco Design Vue TS SFC Composition Desktop less React/字节 🌟🌟🌟🌟🌟 Naive UI TS JSX Composition Desktop css in js 图森 🌟🌟🌟🌟🌟 NutUI TS SFC Composition Mobile scss React/京东 🌟🌟🌟🌟🌟 Vant TS JSX Composition Mobile less 有赞 🌟🌟🌟🌟🌟 Vuetify TS JSX Composition Desktop sass 🌟🌟🌟🌟🌟 Vuestic UI TS SFC Composition Desktop scss 🌟🌟🌟🌟🌟 BalmUI JS SFC Composition Desktop scss Material 不流行/缺乏维护 🌟🌟🌟🌟 Vue Material JS SFC Options Desktop scss Material 🌟🌟🌟🌟 Quimax TS SFC Composition Desktop scss 拟物风格 不流行 🌟🌟🌟🌟 Quasar JS JSX Composition Desktop sass Material 🌟🌟🌟🌟 Agnostic UI TS SFC Composition Desktop css module React/setup 不流行/缺乏维护 🌟🌟🌟🌟 mand-mobile-nest TS JSX Composition Mobile stylus 滴滴 不流行/缺乏维护 🌟🌟🌟🌟 Codex TS JSX Composition Desktop less 维基 不流行 🌟🌟🌟🌟 iDux TS JSX Composition Desktop less 不流行 🌟🌟🌟🌟 Oruga TS SFC Options Desktop scss 🌟🌟🌟🌟 Vexip UI TS JSX Composition Desktop scss 缺乏维护 🌟🌟🌟🌟 Unge UI TS JSX Composition Desktop stylus 不流行 🌟🌟🌟🌟 Core UI TS JSX Composition Desktop scss React 缺乏维护 🌟🌟🌟🌟 MDBootstrap JS SFC Composition Desktop scss React/Material 不流行/缺乏维护 🌟🌟🌟 Prime Vue TS SFC Options Desktop css React 🌟🌟🌟 Buefy JS SFC Options Desktop scss 🌟🌟🌟 Cube UI JS SFC Options Mobile stylus 滴滴 缺乏维护 🌟🌟 Bootstrap Vue JS JSX Options Desktop scss 缺乏维护 🌟🌟 HeyUI JS SFC Options Desktop less 缺乏维护 🌟🌟 Mijin JS SFC Options Desktop Tailwind CSS 不流行/缺乏维护 🌟🌟 View Design JS SFC Options Desktop less 缺乏维护 🌟🌟 vue-material-adapter JS SFC Options Desktop scss Material 缺乏维护 🌟🌟 Wave UI JS SFC Options Desktop scss Material 缺乏维护 🌟🌟</description></item><item><title>关于Vue组件二次封装的技巧总结</title><link>https://chenkai.life/vue/guanyu-vue-zujian-fengzhuang/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/guanyu-vue-zujian-fengzhuang/</guid><description>在开发Vue项目我们一般使用第三方UI组件库进行开发，如element-plus, @arco-design/web-Vue, naive-ui等, 但是这些组件提供的接口并不一定满足我们的需求，这时我们可以通过对组件库组件的二次封装，来满足我们特殊的需求。 对于封装组件有一个大原则就是我们应该尽量保持原有组件的接口，除了我们需要封装的功能外，我们不应该改变原有组件的接口，即保持原有组件提供的接口如props,events,slots等不变。 为了实现这一原则我们就需要将新组件的接口与旧组件的接口一一对应, 当然我们可以通过在新组件中一一声明对应的接口来实现（或者只实现我们目前需要用到的接口）但这种办法虽然简单但看起来却极其很繁琐, 有没有一种方法可以实现props,events,slots的自动透传呢？
透传 Attribute 我们可以使用一个没有参数的 v-bind来实现props,events的透传， 它会将一个对象的所有属性都作为 attribute 应用到目标元素或组件上, 这在官方文档中有着详细介绍。
&amp;lt;BaseButton v-bind=&amp;#34;$attrs&amp;#34;/&amp;gt; 其中$attrs包含组件可以透传属性的对象, 透传属性包括props,events, class,style,id等。(不包含接收组件显式声明的 props、emits以及slots )
如下,是一个封装el-input的默认可清空的的组件，由于我们已经在defineProps声明过clearable, 所以此时我们需要显性传递clearable属性
&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;my-input&amp;#34;&amp;gt; {{ label }} &amp;lt;el-input v-bind=&amp;#34;$attrs&amp;#34; :clearable=&amp;#34;clearable&amp;#34;&amp;gt;&amp;lt;/el-input&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script setup&amp;gt; defineProps({ label: String, clearable: { type: Boolean, default: true, }, }); &amp;lt;/script&amp;gt; 如果我们不希望透传某些属性比如class, 我们可以通过useAttrs来实现
&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;my-input&amp;#34;&amp;gt; {{ label }} &amp;lt;el-input v-bind=&amp;#34;filteredAttrs&amp;#34; :clearable=&amp;#34;clearable&amp;#34;&amp;gt;&amp;lt;/el-input&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script setup&amp;gt; import { computed, useAttrs } from &amp;#39;Vue&amp;#39;; defineProps({ label: String, clearable: { type: Boolean, default: true, }, }); const attrs = useAttrs(); const filteredAttrs = computed(() =&amp;gt; { return { .</description></item><item><title>CSS实现字体阴影效果</title><link>https://chenkai.life/css/font-shadow/</link><pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/font-shadow/</guid><description>shadow 对于阴影我们一般可以设置以下几种效果
水平偏移：正值向右偏移阴影，而负值向左偏移。 垂直偏移：正值向上偏移阴影，而负值向下偏移。 模糊半径：阴影的长度。长度越长，阴影就越大越轻。没有负值。 传播半径：这是另一个长度值，较大的值会导致更大、更长的阴影。 颜色：这定义了阴影的颜色，就像我们为 CSS 颜色属性所做的那样。 inset：默认值（初始）会产生阴影。使用 inset 值移动元素框架内的阴影，从而产生内部阴影（只有box-shadow支持） box-shadow 一般来说，提到实现阴影效果，我们首先想到的是box-shadow，但是这个属性只能用在盒模型上，为了显示立体感如弹框、按钮等。
&amp;lt;p style=&amp;#34;box-shadow: 0 0 10px red;&amp;#34;&amp;gt;HelloWorld&amp;lt;/p&amp;gt; HelloWorld
text-shadow 与box-shadow不同的是，text-shadow只能用在文本上
&amp;lt;p style=&amp;#34;font-size: 2em;text-shadow: 0 0 0.4em red;&amp;#34;&amp;gt;HelloWorld&amp;lt;/p&amp;gt; HelloWorld
阴影越大越淡，我们可以通过叠加多个shadow加深阴影颜色
&amp;lt;p style=&amp;#34;font-size: 2em;text-shadow: 0 0 0.4em red, 0 0 0.4em red, 0 0 0.4em red&amp;#34;&amp;gt;HelloWorld&amp;lt;/p&amp;gt; HelloWorld
drop-shadow 与box-shadow类似
&amp;lt;p style=&amp;#34;font-size: 2em;filter:drop-shadow(0 0 0.4em red);&amp;#34;&amp;gt;HelloWorld&amp;lt;/p&amp;gt; HelloWorld
阴影越大越淡，与box-shadow不同的是,随着叠加drop-shadow它的范围会逐渐变大
&amp;lt;p style=&amp;#34;font-size: 2em;filter:drop-shadow(0 0 0.4em red) drop-shadow(0 0 0.4em red) drop-shadow(0 0 0.</description></item><item><title>React Hooks 入门</title><link>https://chenkai.life/react/react-hooks/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks/</guid><description>在React中，如果在编写函数组件并需要向其添加一些 state，以前的做法是必须将其它转化为 class。通过一个实例化的class，保存组件的state等状态，对于每一次更新只需要调用render方法就可以。但是 Class组件在变得复杂之后会变得难以维护。
在function组件中，没有一个状态去保存这些信息，每一次函数上下文执行，所有变量，常量都重新声明，执行完毕，再被垃圾机制回收。为了保存一些状态,执行一些副作用钩子,React 16.8新增了React Hooks，去帮助记录组件的状态，处理一些额外的副作用。通过React Hook 可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。你可以在现有的函数组件中使用 Hook，所以通常来说hook使得在组件之间复用状态逻辑变得方便、更容易实现代码的关注点分离。
Hooks API useState 在函数组件中存储内部 state
const [state, setState] = useState(initialState); 参数:
initialState: state初始值 返回值:
state: 当前的 state setState: 更新 state 的方法, 它接收一个新的 state 值并将组件的一次重新渲染加入队列。如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过 基础用法 这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加
function Counter(props) { const [count, setCount] = useState(props.initialCount) return ( &amp;lt;button type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; setCount(count + 1)}&amp;gt; count is: {count} &amp;lt;/button&amp;gt; ); } Counter.</description></item><item><title>css元素选择器</title><link>https://chenkai.life/css/css-select/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-select/</guid><description>CSS 选择器规定了 CSS 规则会应用到哪些元素上。
基本选择器 节点选择 CSS 类型选择器按节点名称匹配元素。换句话说，它选择文档中给定类型的所有元素。
/* All &amp;lt;a&amp;gt; elements. */ a { color: red; } 类选择 该 CSS 类选择匹配根据他们的内容元素 class 属性。
/* All elements with class=&amp;#34;spacious&amp;#34; */ .spacious { margin: 2em; } /* All &amp;lt;li&amp;gt; elements with class=&amp;#34;spacious&amp;#34; */ li.spacious { margin: 2em; } /* All &amp;lt;li&amp;gt; elements with a class list that includes both &amp;#34;spacious&amp;#34; and &amp;#34;elegant&amp;#34; */ /* For example, class=&amp;#34;elegant retro spacious&amp;#34; */ li.spacious.elegant { margin: 2em; } ID 选择 CSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素</description></item><item><title>css关于浮动的知识</title><link>https://chenkai.life/css/css-float/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-float/</guid><description>float CSS 属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。 当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。
float 原始用法 float 本意是为了允许文本和内联元素环它如（文字环绕图片）,就像下面一样
.float { float: left; width: 200px; height: 200px; background-color: red; } &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;float&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; float本意是为了允许文本和内联元素环它; float本意是为了允许文本和内联元素环它; float本意是为了允许文本和内联元素环它; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 滥用 float 带来的问题 我们使用 float 浮动做了很多其本职工作以外的事情，使用 float 进行分栏布局、列表排列，但是如果一个元素里只有浮动元素，那它的高度会是 0。如果你想要它自适应即包含所有浮动元素，那你需要清除它的子元素。
清除浮动的几种办法 ::after 伪元素 这种方式不会影响任何其他样式，通用性强，覆盖面广，推荐使用
#container::after { content: &amp;#34;&amp;#34;; display: block; clear: both; } 类似的可以在元素后面加一个&amp;lt;div style=&amp;quot;clear:both;&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;空元素
其他清除浮动方法 IE 下清除浮动准则很简单，使元素 haslayout 就可以了。如宽度值，高度值，绝对定位，zoom，浮动本身都可以让元素 haslayout。显然，首选 zoom:1;不会干扰任何样式。非 IE 浏览器常用的是 overflow 属性
container 也浮动,这种方式治标不治本总不能一直浮动到 root
#container { float: left; } 使用 position: absolute</description></item><item><title>DOM中的event</title><link>https://chenkai.life/web/dom-event/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/dom-event/</guid><description>event Event 接口表示在 DOM 中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由 API 生成（例如指示动画已经完成运行的事件，视频已被暂停等等。事件通常由外部源触发，同样也会以编程方式触发，例如执行一个 element 的一个 HTMLElement.click( ) 方法，或通过定义事件，然后使用 EventTarget.dispatchEvent() 将其派发到一个指定的目标。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。 事件处理函数可以附加在各种对象上，包括 DOM 元素,window,document 对象. 等
有三种方式可以为 DOM 元素注册事件处理函数
EventTarget.addEventListener // Assuming myButton is a button element myButton.addEventListener( &amp;#34;click&amp;#34;, function () { alert(&amp;#34;Hello world&amp;#34;); }, false ); HTML 属性 &amp;lt;button onclick=&amp;#34;alert(&amp;#39;Hello world!&amp;#39;)&amp;#34;&amp;gt;&amp;lt;/button&amp;gt; DOM 元素属性 该函数在定义时，可以传入一个 event 形式的参数。 在 HTML 规范中，其返回值会以一种特殊的方式被处理。
// Assuming myButton is a button element myButton.onclick = function(event){alert(&amp;#39;Hello world&amp;#39;);}; 创建自定义事件 可以使用事件构造函数创建事件
var event = new Event(&amp;#34;build&amp;#34;); let eventEle = document.</description></item><item><title>vue nextTick的原理</title><link>https://chenkai.life/vue/vue-nex-tick/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue-nex-tick/</guid><description>nextTick是 vue 的一个全局 API， 作用是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
const callbacks = []; let pending = false; function flushCallbacks() { pending = false; const copies = callbacks.slice(0); callbacks.length = 0; for (let i = 0; i &amp;lt; copies.length; i++) { copies[i](); } } // Here we have async deferring wrappers using microtasks. // In 2.</description></item><item><title>Vue样式dev和build下不一致</title><link>https://chenkai.life/vue/vue-page-style-dev-build-different/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue-page-style-dev-build-different/</guid><description>一次更新镜像后发现 vue 项目页面混乱，在开发模式模式下，写的样式有效，打包后无效
一、多个相同样式文件同时存在项目中 现象：修改组件时，在项目中复制了一个组件重命名后进行修改，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：在本地试图修改总是不见效果，在控制台查看样式仍是之前的样式，把其中一处样式在所有相关组件中修改，打包上传后样式生效，这说明是旧的样式在打包时覆盖了新的样式。将旧组件删除后解决上述问题。 原因猜测：因为相同组件包含不同样式时，无法判断哪份样式时在后面渲染，如果旧样式刚好打包后在后面渲染，则会覆盖掉新写的样式。在本地执行时，因为样式没有打包，访问页面时渲染的都是组件自身样式，所以不会出现上述问题。
二、全局(main.js)引用样式 现象：在全局引入了 Element UI 样式，在 header 组件中修改部分样式，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：因为在项目中段发现该问题，以为是后续的样式造成的影响(虽然我也认为可能性极小)，删除新写的组件，没有效果。运行一段时间之前的代码，项目正常运行，这迫使我回想中间这段时间对项目做了什么？除了新写了一些组件，还将一些配置信息从 index.js 中转移到了 main.js 中，测试发现果然是这里出现了问题。配置中同时出现了 Element UI 样式文件引用，还有 router 的引用，将 yang 样式引用放在 router 引用后解决问题。 原因猜测：不正常的样式显示的还是组件原始的样式，由此猜测 router 加载时会加载组件样式，将样式文件在 router 后引用会将 router 加载时渲染的样式覆盖掉，所以建议将 router 的引用放在最后面。在每个组件的样式中记得添加 ‘scoped’.
import &amp;#34;element-ui/lib/theme-chalk/index.css&amp;#34;; //element样式文件 import App from &amp;#34;./App&amp;#34;; 如果相反，那么 element-ui 的样式会覆盖自定义的样式，所以会出现你修改的样式不生效问题！！</description></item><item><title>处理浏览器中的字体常见问题</title><link>https://chenkai.life/web/handling-fonts-in-the-web/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/handling-fonts-in-the-web/</guid><description>当页面中的标题字数是不定的，并且需要适应各种机型屏幕宽度，可能会遇到下面的需求,
字体末尾如何显示省略号 如果显示区域很小，我们可以只设置为单行显示，对于单行文本末尾显示省略号很简单
.wrapper { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } 但是如果是显示区域很大,我们需要设置多行的最后一行显示省略号，对于多行文本，常用的方法如下
移动端兼容较好，适用于 webkit 内核浏览器, 另外对于超出部分的字体仍会显示出来，如下图所示
hello hello hello hello hello hello hello hello 所以我们一般需要搭配固定高度及overflow: hidden;, line-height或者font-size使用
hello hello hello hello hello hello hello hello .wrapper { display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; } 解决多行文字时最后一排文字可能超出边框显示不全问题 对于多行文字，最后一排文字可能超出边框显示不全的情况，对于这种情况我们需要设置外部容器高度为字体高度的整数倍如对于一个高6em的容器,我们可以设置他的line-height为3em, 或者我们设置他的font-size为 2.5em,并且把line-height设置为1.2,
如何文字大小自适应容器 动态修改字体大小 根据不同的字体长度, 设置不同的字体大小； 或者逐渐修改初始字体大小，直到字体容器宽度和高度小于外层包裹的容器宽, 但是由于字体大小有最小值，这种办法对太对的文本也无能为力
zoom,transform 缩放字体容器 我们可以通过外层容器宽高和字体容器宽高计算出需要缩放的比例，通过设置 zoom、scale 来自适应容器宽高,如:
&amp;lt;div class=&amp;#34;auto-size&amp;#34; contenteditable=&amp;#34;true&amp;#34; style=&amp;#34;border: 1px solid gray; width: 120px; height: 120px;resize: both; overflow: scroll;&amp;#34; &amp;gt; &amp;lt;span&amp;gt; 通过拖动右下角,或者增加删除文字查看字体缩放。 &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; function autoFit(ele) { const wrapperSty = ele.</description></item><item><title>常用的一些css样式</title><link>https://chenkai.life/css/css-useful-style/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-useful-style/</guid><description> 字体 文字超出后省略
white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 中文简&amp;gt;繁转换
font-variant-east-asian: traditional;</description></item><item><title>浅谈CSS动画</title><link>https://chenkai.life/css/css-animation/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-animation/</guid><description>本文简单介绍如何定义 css 动画
transition transitions 可以决定哪些属性发生动画效果transition-property (明确地列出这些属性,如果省略则包含所有属性)，何时开始transition-delay (设置 delay），持续多久transition-duration (设置 duration) 以及如何动画transition-timing-function (定义timing function，比如匀速地或先快后慢)
如下面指定字体大小颜色和字体发生动画效果
.transition-box{ font-size: 1rem; color: red; transition: color 2s, font-size 2s; } transition 的发生需要属性被修改时才会触发，比如 hover 时我们修改字体大小和颜色，如果没有定义 transition 这些属性会立即修改，
.transition-box:hover { font-size: 2rem; color: green; } 把鼠标放上查看效果 CSS 过渡 由简写属性transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间。
也可以用下面子属性来控制过渡的各部分
transition-property: color, font-size; transition-duration: 4s; transition-timing-function: ease; transition-delay: 0s; transition 的特点 只能在 css 属性变化时被动触发
transition 是一次性的，不能重复发生，除非一再触发
transition 只能定义开始状态和结束状态，不能定义中间状态
animation animation 属性用来指定一组或多组动画，每组之间用逗号相隔,是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。</description></item><item><title>浏览器中获取宽、高相关的属性</title><link>https://chenkai.life/web/get-width-and-height-attributes-in-the-browser/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/get-width-and-height-attributes-in-the-browser/</guid><description>我们可能需要针对宽屏和高屏编写不同代码，下面我总结一下从浏览器中获取宽、高相关的属性
css 如果宽高屏不设计具体逻辑代码，我们可以采用 css 的@media媒体查询的方式判断;
orientation 宽度和高度相等时会被判断为纵向
/* viewport 处于纵向，即高度大于等于宽度 */ @media (orientation: portrait) { } /* viewport 处于横向，即宽度大于高度。 */ @media (orientation: landscape) { } aspect-ratio 利用宽高比我们也可以判断宽高屏，当如果同时满足后面的样式会覆盖前面，所以下面当宽高相等时生效的是@media (aspect-ratio: 1/1) {}
/* 最大宽高比 */ @media (max-aspect-ratio: 1/1) { } /* 最小宽高比 */ @media (min-aspect-ratio: 1/1) { } /* 指定宽高比 */ @media (aspect-ratio: 1/1) { } js window innerHeight innerWidth outerHeight outerWidth 获取浏览器窗口的视口（viewport）高度、宽度（以像素为单位）
screen height: 以像素为单位返回屏幕的高度
width: 以像素为单位返回屏幕的宽度.
orientation: 返回当前屏幕的转向.
availHeight: 指定屏幕的高度（以像素为单位）减去操作系统显示的永久或半永久用户界面功能，例如 Windows 上的任务栏.</description></item><item><title>浏览器如何渲染页面</title><link>https://chenkai.life/web/how-brower-render-page/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/how-brower-render-page/</guid><description>参考https://coolshell.cn/articles/9666.html
文章是为了说明浏览器如何将 HTML，CSS 和 JavaScript 转换为网站。
首先 浏览器是一个可以从远程服务器或者本地磁盘将文件加载、显示、交互的软件。
浏览器有两个重要部分：
渲染引擎（Rendering Engine）：一般习惯称为“浏览器内核”，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同如 Gecko（火狐）、Blink（Chrome）、Webkit（Safari）、Trident（IE）等，因此同一网页在不同的内核的浏览器里的渲染效果也可能不同。
JavaScript 引擎：JavaScript 由 ECMAScript，DOM 和 BOM 三者组成，不同浏览器针对 JavaScript 语法和语义标准有多种实现如：
Chrome 使用 V8 引擎， Safari 使用 JavaScriptCore， Firefox 使用 SpiderMonkey 浏览器接收数据 数据是通过 Internet 以数据包（Packet）为单位按字节形式发送到浏览器。浏览器将从硬盘（或网络）中读取 HTML 的原始数据字节转换为字符。
从原始字节到 DOM 当浏览器接受到扩展名为.html 时，会将该文件解释为 html 对其进行解析，文件中的每个开始和结束 html 标签会转换为节点如
&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; 创建这些节点后，然后将这些节点链接到称为 DOM 的树数据结构中。DOM 建立父子关系，相邻的兄弟关系等。每个节点之间的关系都在此 DOM 对象中建立。浏览器必须先将 html 数据的原始字节转换为 DOM，然后才能进行任何操作。
当浏览器接收数据的原始字节并启动 DOM 构造过程时，它还将发出请求以获取链接的样式表。 一旦浏览器开始解析 html，一旦找到文件的 link 标签，浏览器 css 就会同时发出获取请求的请求。
从原始字节到 CSSOM 当浏览器收到 CSS 的原始字节时，也会启动 HTML 原始字节的类似过程。将数据的原始字节转换为字符，然后标记化节点，最后还形成 CSS 树结构，称为 CSS 对象模型，简称 CSSOM。 CSS 有一个叫做Cascade的东西。级联是浏览器如何确定将哪些样式应用于元素的方式。</description></item><item><title>组件间样式隔离的几种方案</title><link>https://chenkai.life/css/css-web-compoent-isolation/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/css/css-web-compoent-isolation/</guid><description>CSS 即层叠样式表(Cascading Style Sheets）是一种样式表语言，它没有作用域的概念，引入即全局生效的，但一个样式是否起作用由多个因素共同决定，比如：
重要程度 优先级 样式加载顺序 所以当我们在页面中使用时可能会遇到组件间的样式互相影响的情况，特别是引入了多个组件库或者类名命名不规范时，我们就需要对样式进行隔离，这样就可以避免样式冲突。下面我介绍几种方案： 类名添加特定的前缀 一般来说，我们会在组件内部使用一个特定的前缀，避免组件之间的样式冲突。比如 antd 的组件内部的样式，都会使用ant-前缀，element-ui 的组件内部的样式，都会使用el-前缀。 由于原生 css 的功能太弱鸡了, 我们在实际开发中一般使用 css 预处理框架如 less, sass 等，对于这种我们也可以使用一个类似的功能。
对于 less // button.less @name: v-; .@{name}button { background-color: green; } // 编译为 // .v-button { // background-color: green; // } 重写前缀
@import &amp;#34;button.less&amp;#34;; @name: k-; // 编译为 // .k-button { // background-color: green; // } 对于 sass sass 目前版本支持与 less 类似的写法，但是 Sass 团队不鼓励继续使用@import规则。 并计划在未来几年逐步淘汰它，作为替代方案，他们推荐使用@use规则。详细原因请参考https://sass-lang.com/documentation/at-rules/import。
/* button.scss */ $name: v-; @mixin configure($name: $name) { @if $name { $name: $name !</description></item><item><title>谈谈Web项目中图标的方式</title><link>https://chenkai.life/web/use-icon-in-web/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/use-icon-in-web/</guid><description>谈谈 Web 项目中图标的方式
单个图标 我们可以选择单独引用图标文件如 png、svg 等等，这种方式缺点显而易见，图标多了之后不方便维护
字体文件 通过font-face,我们可以指定一个用于显示文本的自定义字体，字体文件内部类似一个svg我们可以在字体文件里面随便定义这些字符的形状，
通过对应字体文件的字体编码我们就可以使用这些图标了,如下面是一个close图标
&amp;lt;i class=&amp;#34;iconfont&amp;#34;&amp;gt;&amp;amp;#xe64f;&amp;lt;/i&amp;gt; 这样有个明显的缺点就是图标不直观，我们很难根据&amp;amp;#x33;知道它是什么图标，我们可以通过提前定义好对应图标 css 的::before的 content，将其改造成自定义 class 引用的方式
.icon-close:before { content: &amp;#34;\e64f&amp;#34;; } 然后我们在页面中可以这样使用
&amp;lt;span class=&amp;#34;iconfont icon-close&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 因为是字体格式所以这种方式使用图标有以下特点
兼容性最好，支持 ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 不支持多色。 symbol 引用 symbol 元素用来定义一个图形模板对象，它可以用一个use元素实例化。一个symbol元素本身是不呈现的。只有symbol元素的实例（亦即，一个引用了symbol的 use元素）才能呈现，如
&amp;lt;svg&amp;gt; &amp;lt;!-- symbol definition NEVER draw --&amp;gt; &amp;lt;symbol id=&amp;#34;sym01&amp;#34; viewBox=&amp;#34;0 0 150 110&amp;#34;&amp;gt; &amp;lt;circle cx=&amp;#34;50&amp;#34; cy=&amp;#34;50&amp;#34; r=&amp;#34;40&amp;#34; stroke-width=&amp;#34;8&amp;#34; stroke=&amp;#34;red&amp;#34; fill=&amp;#34;red&amp;#34; /&amp;gt; &amp;lt;circle cx=&amp;#34;90&amp;#34; cy=&amp;#34;60&amp;#34; r=&amp;#34;40&amp;#34; stroke-width=&amp;#34;8&amp;#34; stroke=&amp;#34;green&amp;#34; fill=&amp;#34;white&amp;#34; /&amp;gt; &amp;lt;/symbol&amp;gt; &amp;lt;!-- actual drawing by &amp;#34;use&amp;#34; element --&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;0&amp;#34; width=&amp;#34;100&amp;#34; height=&amp;#34;50&amp;#34; /&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;50&amp;#34; width=&amp;#34;75&amp;#34; height=&amp;#34;38&amp;#34; /&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;100&amp;#34; width=&amp;#34;50&amp;#34; height=&amp;#34;25&amp;#34; /&amp;gt; &amp;lt;/svg&amp;gt; symbol的作用域是全局的我们也可以在 svg 中单独使用如</description></item><item><title>跨域资源共享 (CORS)</title><link>https://chenkai.life/web/cross-origin-resource-sharing/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/cross-origin-resource-sharing/</guid><description>转载自 web.dev
浏览器的同源策略阻止了浏览器读取不同源的资源。这种机制能够阻止恶意网站读取另一个网站的数据，但也会阻碍合法使用。如果您希望获取其他国家的天气数据该怎么办？
在现代网络应用程序中，应用程序通常希望从不同源获取资源。例如，您想要从不同的域读取 JSON 数据或者将另一个网站的图像加载到&amp;lt;canvas&amp;gt;元素中。
换句话说，部分公共资源应该可以供任何人读取，但同源策略会阻碍这一点。开发者使用过诸如 JSONP 之类的变通方法，但跨域资源共享 (CORS) 能够通过标准方式修复此问题。
启用 CORS 可以让服务器告知浏览器自己已获许使用其他源。
资源请求在网络上是如何运作的？ # 图：客户端请求和服务器响应图示
浏览器和服务器可以使用超文本传输协议 (HTTP) 来通过网络交换数据。HTTP 定义了请求者和响应者之间的通信规则，其中包括获取资源所需的信息。
HTTP 标头用于协商客户端和服务器之间的消息交换类型，并用于确定访问权限。浏览器的请求和服务器的响应消息都分为两部分：标头和主体：
标头 # 包含消息的相关信息，例如消息类型或消息编码。标头可以包括各种信息，这些信息通过键值对表示。请求头和响应头包含不同的信息。
请务必注意，标头不能包含评论。
请求头示例
Accept: text/html Cookie: Version=1 以上内容相当于表示“我希望收到 HTML 的响应。这是我的一个 cookie。”
响应头示例
Content-Encoding: gzip Cache-Control: no-store 以上内容相当于表示“数据是用 gzip 编码的。请不要将其缓存。”
主体 # 消息本身。主体可以是纯文本、二进制图像、JSON、HTML 等。
CORS 是如何运作的？ # 请记住，同源策略会让浏览器阻止跨域请求。当您想从不同的源获取公共资源时，提供资源的服务器需要告知浏览器“发出该请求的这个源可以访问我的资源”。浏览器会记住这一点，并允许跨域资源共享。
第一步：客户端（浏览器）请求 # 当浏览器发出跨域请求时，该浏览器会添加一个包含当前源（协议、主机和端口）的Origin标头。
第二步：服务器响应 # 在服务器端，当服务器看到该标头并想要允许访问时，就需要在响应中加入一个Access-Control-Allow-Origin标头来指定请求源（或加入*来允许任何源。）
第三步：浏览器接收响应 # 当浏览器看到带有相应Access-Control-Allow-Origin标头的响应时，即允许与客户端网站共享响应数据。
查看 CORS 的实际应用 # 这是一个使用 Express 的小型网络服务器。
第一个端点（第 8 行）没有设置任何响应头，该端点只会在响应中发送一个文件。</description></item><item><title>WebWorker</title><link>https://chenkai.life/web/web-worker/</link><pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/web-worker/</guid><description>一、概述 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。
Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。
Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。
Web Worker 有以下几个使用注意点。
（1）同源限制
分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。
（2）DOM 限制
Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。
（3）通信联系
Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
（4）脚本限制
Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。
（5）文件限制
Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。
二、基本用法 2.1 主线程 主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。
var worker = new Worker(&amp;#34;work.js&amp;#34;); Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如 404 错误），Worker 就会默默地失败。</description></item><item><title>在浏览器中本地运行 Node.js - WebContainers</title><link>https://chenkai.life/web/web-containers/</link><pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/web-containers/</guid><description>起因 在nodejs.dev网站看到了一个在线编辑的程序https://nodejs.dev/learn/introduction-to-nodejs#an-example-nodejs-application ,起初我以为这是一个类似codepen的在线编辑器，通过关键词webcontainer, 我发现这是一个在浏览器中本地运行 Node.js 程序， 并找到了下面这篇文章https://blog.stackblitz.com/posts/introducing-webcontainers/，
以下内容为文章翻译：
WebContainers 简介：在浏览器中本地运行 Node.js ERIC SIMONS可能 2021 年 2 月 20 日新闻和公告
你好呀！我们是 StackBlitz，一个专门为 Web 开发量身定制的在线 IDE。在本周的 Google I/O 主题演讲中，您可能已经看到了我们的先睹为快。
今天，我们很高兴地宣布，我们一直在与 Next.js 和 Google 的团队合作开发一项新技术。
几年前，我们意识到网络正走向一个关键的转折点。 WebAssembly 的出现和新的 功能 API 使编写一个基于 WebAssembly 的操作系统变得可能，它的功能足以运行 Node.js，完全在你的浏览器中。我们设想了一个比本地环境更快、更安全和一致的卓越开发环境，以实现无缝代码协作，而无需设置本地环境。
这听起来有些牵强。但是，如果网络现在为 平面设计师、视频编辑器 /web.dev/clipchamp/) 和 丰富的文档编辑，我们想知道：开发人员最终有可能*使用*网络来*构建*网络吗？
我们决定试一试。我们抱有最好的希望，也期待最坏的结果。两年后（时间过得真快 😅），结果出乎意料地惊人。
今天我们很高兴地宣布WebContainers WebContainers 允许您创建全栈 Node.js 环境，这些环境在几毫秒内启动并立即在线和链接共享 - 只需单击一下。该环境加载了 VS Code 强大的编辑体验、完整的终端、npm 等。它还完全在您的浏览器内运行，这会产生一些关键优势：
比您的本地环境更快。构建完成速度最多可提高 20%，软件包安装完成速度比 yarn/npm 快 &amp;gt;= 5 倍。 Node.js 在浏览器中调试。与 Chrome DevTools 的无缝集成支持原生后端调试，无需安装或扩展。 默认安全。所有代码执行都发生在内部浏览器的安全沙箱中，而不是在远程虚拟机或本地二进制文件上。 没错：Node.</description></item><item><title>算法-array</title><link>https://chenkai.life/algorithm/leetcode-array/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/algorithm/leetcode-array/</guid><description>删除排序数组中的重复项 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
let removeDuplicates = function(nums) { for(let i = 0; i&amp;lt;nums.length; i++){ while (nums[i] === nums[i+1]) { nums.splice(i+1,1); } } }; 买卖股票的最佳时机 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）
var maxProfit = function(prices) { let ans = 0; for(let i = 1, len = prices.length; i &amp;lt; len; i++){ ans += Math.max(0, prices[i] - prices[i - 1]); } return ans; }; 旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</description></item><item><title>❤️ 宝贝</title><link>https://chenkai.life/life/my-girlfriend.md/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/life/my-girlfriend.md/</guid><description>感谢我的憨憨,在我感冒的时候细心地照顾我。
一个人走的快，两个人走的远, ❤️我想和你走一辈子❤️
┏╗·☆°∴． ╭∞╮┏┓╔┓灬☆ I ║┃╔━╦╦┳═愛╱ ║╚┛┣═╦┳╗ ┃╚┫║┃┃┃╩┫伱 ┗╗┏╣┃┃║┃ ╚━╩═┻━╩━╝　┗╝┗═┻═┛ 。° ☆．．·°∴°．☆°-∴°★．</description></item><item><title>Brew</title><link>https://chenkai.life/libs/brew/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/brew/</guid><description>切换到国内源 ## 替换brew.git: cd &amp;#34;$(brew --repo)&amp;#34; ## 中国科大: git remote set-url origin https://mirrors.ustc.edu.cn/brew.git ## 清华大学: git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git ## 替换homebrew-core.git: cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; ## 中国科大: git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git ## 清华大学: git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git ## 替换homebrew-bottles: ## 中国科大: echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile source ~/.bash_profile ## 清华大学: echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile source ~/.bash_profile ## 应用生效: brew update 切换到官方源 ## 重置brew.git: cd &amp;#34;$(brew --repo)&amp;#34; git remote set-url origin https://github.</description></item><item><title>CentOS安装常用的软件</title><link>https://chenkai.life/posts/yum-install-software/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/yum-install-software/</guid><description>安装 pg 参考官网;
Install the repository RPM: yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm Install the client packages: yum install postgresql11 Optionally install the server packages: yum install postgresql11-server Optionally initialize the Database and enable automatic start: /usr/pgsql-11/bin/postgresql-11-setup initdb systemctl enable postgresql-11 systemctl stop postgresql-11 systemctl start postgresql-11 systemctl restart postgresql-11 systemctl status postgresql-11 修改配置允许外部 ip 访问数据库 修改/var/lib/pgsql/11/data/postgresql.conf #listen_addresses = &amp;#39;localhost&amp;#39; # what IP address(es) to listen on; 改为 listen_addresses = &amp;#39;*&amp;#39; 修改/var/lib/pgsql/11/data/pg_hba.conf</description></item><item><title>defineProperty</title><link>https://chenkai.life/javascript/js-defin-property/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-defin-property/</guid><description>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
Object.defineProperty(obj, prop, descriptor) obj:要在其上定义属性的对象。 prop:要定义或修改的属性的名称。 descriptor:将被定义或修改的属性描述符。 描述符可以有以下属性：
configurable：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false enumerable： 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中，default：false value： 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined writable： 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 get： 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象 set： 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 @return:传递给函数的对象。
example // 数组拦截 /** * * @param {array} data */ function observe(data) { if (!Array.isArray(data)) { return; } // 取出所有数组遍历 data.forEach(function(val,index) { Object.defineProperty(data, index, { enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() { return val; }, set: function(newVal) { console.</description></item><item><title>Docker</title><link>https://chenkai.life/libs/docker/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/docker/</guid><description>安装/卸载docker 安装过程参考官网;
yum update ## 使用以下命令来设置的存储库 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io sudo systemctl start docker 卸载 sudo yum -y remove docker-ee ## 删除所有图像，容器和卷 sudo rm -rf /var/lib/docker ## 删除其他与Docker相关的资源 $ sudo rm -rf /run/docker $ sudo rm -rf /var/run/docker $ sudo rm -rf /etc/docker 安装过程中可能会遇到以下问题 doceker版本和系统内核版本不兼容 升级系统内核或者降低docker版本 yum安装失败 ## 解决依赖冲突 package-cleanup --cleandupes 找不到安装包 添加设置的存储库 容器生命周期管理 docker start :启动一个或多个已经被停止的容器 docker stop :停止一个运行中的容器 docker restart :重启容器 docker-compose 文件启动镜像 docker-compose up -d redis 创建一个新的容器但不启动，用法同docker run 使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob docker create --name myrunoob nginx:latest 创建一个新的容器并运行一个命令 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。 docker run --name mynginx -d nginx:latest 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。 docker run -P -d nginx:latest 使用镜像 nginx:latest，以后台模式启动一个容器,将主机的 80 端口映射到 容器的 80 端口,主机的目录 /data 映射到容器的 /data。 docker run -p 80:80 -v /data:/data -d nginx:latest 镜像容器管理 给image打标签 docker tag e9cb35287c01 geohey-nlpa-platform:gd 保存为本地文件 docker save -o geohey-nlpa-platform.</description></item><item><title>GDAL</title><link>https://chenkai.life/libs/gdal/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/gdal/</guid><description>类型转换 格式ogr2ogr -f &amp;quot;fileType&amp;quot; fileName sourceFile
数据库&amp;gt;geojson
ogr2ogr -f &amp;#34;GeoJSON&amp;#34; cn_polygon.geojson PG:&amp;#34;host=localhost dbname=postgres user=postgres password=password&amp;#34; -sql &amp;#34;select * from planet_osm_polygon limit 30000&amp;#34; geojson&amp;gt;shp
ogr2ogr -f &amp;#34;ESRI Shapefile&amp;#34; test.shp china_diaoyudao.geojson.json 数据入库 geojson&amp;gt;postgre
/usr/local/Cellar/gdal2/2.3.2_1/bin/ogr2ogr -dim XY -gt 65536 -skipfailures -progress --config OGR_FORCE_ASCII NO --config PG_USE_COPY YES -overwrite -f PostgreSQL PG:&amp;#34;host=localhost port=5432 dbname=g-default user=projx password=sss&amp;#34; -lco FID=_id -lco GEOMETRY_NAME=the_geom -nln ${表名} &amp;#34;${文件名}&amp;#34; csv&amp;gt;postgre
/usr/local/Cellar/gdal2/2.3.2_1/bin/ogr2ogr -dim XY -gt 65536 -skipfailures --config PG_USE_COPY YES -overwrite -oo AUTODETECT_TYPE=YES -f PostgreSQL PG:&amp;#34;host=localhost port=5432 dbname=g-default user=projx password=sss&amp;#34; -lco FID=_id -nln ${start.</description></item><item><title>get和set</title><link>https://chenkai.life/javascript/js-get-and-set/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-get-and-set/</guid><description>你可以在支持添加新属性的任何标准的内置对象或用户定义的对象内定义getter(访问方法)和setter(设置方法)。使用对象字面量语法定义getters和setters方法。
get get语法将对象属性绑定到查询该属性时将被调用的函数,有时需要允许访问返回动态计算值的属性，或者你可能需要反映内部变量的状态，而不需要使用显式方法调用。在JavaScript中，可以使用 getter 来实现。虽然可以使用 getter 和 setter 来创建一个伪属性类型，但是不可能同时将一个 getter 绑定到一个属性并且该属性实际上具有一个值
使用get语法时应注意以下问题：
可以使用数值或字符串作为标识； 必须不带参数； 它不能与另一个 get 或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 { get x() { }, get x() { } } 和 { x: &amp;hellip;, get x() { } }）。 可通过 delete 操作符删除 getter。 在新对象初始化时定义一个getter 这会为obj创建一个伪属性latest，它会返回log数组的最后一个元素,注意，尝试为latest分配一个值不会改变它。
var obj = { log: [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;], get latest() { if (this.log.length == 0) { return undefined; } return this.log[this.log.length - 1]; } } obj.latest = &amp;#39;test&amp;#39;; console.</description></item><item><title>Git</title><link>https://chenkai.life/libs/git/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/git/</guid><description>更新git yum
#安装源 yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm #安装git yum install git #更新git yum update git sourceTree修改大小写 sourceTree对文件名称的大小写不敏感，当你修改文件名称的大小写进行提交时，它并不能识别,
git mv work.js Work.js sourceTree回滚到历史节点 点击要回滚的历史节点，重置到历史节点，选择硬合并； 点击当前节点，重置到当前节点，选择软合并； 提交修改内容； git reset --hard e377f60e28c8b84158 git push -f origin develop git回滚 //产看git提交的id git log //查看当前分支 git status //本地重置到当前分支 git reset --hard 7c1eb09abaf873483359883175e31e979d216db0 //推送当前分支到远程 git push -f git提交规范 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：修改构建过程或辅助工具的变动，添加依赖库、工具等 perf: 代码重构。没有新功能或修复bug，优化相关，提升性能体验 revery 回滚上一个版本 &amp;mdash;写代码&amp;mdash;
git status （查看文件改变记录） git diff (查看代码级改变)</description></item><item><title>JavaScript中的prototype</title><link>https://chenkai.life/javascript/js-prototype/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-prototype/</guid><description>什么是原型链 首先我们需要知道什么是原型，在 javascript 中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型（prototype）,我们可以添加一些属性到原型上面,然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个的实例。每个实例对象都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）. 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。
如何利用原型链实现继承 假设这里有两个类
// 交通工具 function Transportation(name) { this.name = name; // 该属性没有定义到原型链上,可以通过Object.keys获取 this.say = function () { console.log(`Transportation： ${this.name}是交通工具`); }; } Object.assign(Transportation.prototype, { move: function () { console.log(`Transportation: ${this.name} 会移动`); }, }); // 汽车 function Car(name) { // 调用Transportation构造函数，绑定this变量 我们也可以 // this.name = name; Transportation.call(this, name); } 此时 Car 的原型是
new Car() ----&amp;gt; Car.prototype ----&amp;gt; Object.prototype ----&amp;gt; null 要实现继承我们需要将该对象的原型指向要继承对象的原型，如</description></item><item><title>JavaScript可选链操作符</title><link>https://chenkai.life/javascript/operators-optional-chaining/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/operators-optional-chaining/</guid><description>可选链操作符 可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。
当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。
语法 obj?.prop; obj?.[expr]; arr?.[index]; func?.(args); 描述 通过连接的对象的引用或函数可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。
比如，思考一个存在嵌套结构的对象 obj。不使用可选链的话，查找一个深度嵌套的子属性时，需要验证之间的引用，例如：
let nestedProp = obj.first &amp;amp;&amp;amp; obj.first.second; 为了避免报错，在访问obj.first.second之前，要保证 obj.first 的值既不是 null，也不是 undefined。如果只是直接访问 obj.first.second，而不对 obj.first 进行校验，则有可能抛出错误。
有了可选链操作符（?.），在访问 obj.first.second 之前，不再需要明确地校验 obj.first 的状态，再并用短路计算获取最终结果：
let nestedProp = obj.first?.second; 通过使用 ?. 操作符取代 . 操作符，JavaScript 会在尝试访问 obj.first.second 之前，先隐式地检查并确定 obj.first 既不是 null 也不是 undefined。如果obj.first是 null 或者 undefined，表达式将会短路计算直接返回 undefined。
这等价于以下表达式，但实际上没有创建临时变量：</description></item><item><title>JavaScript脚手架</title><link>https://chenkai.life/posts/js-cli-jiaoshoujia/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/js-cli-jiaoshoujia/</guid><description>什么是脚手架 脚手架是为了保证各施工过程顺利进行而搭设的工作平台。在项目开发中我们把创建项目结构模版的工具也称之为脚手架。如vue-cli，create-react-app等。这些脚手架等原理都一样，即用Node.js命令行程序生成项目模版。
第一个Node.js命令行脚本 编写脚手架其实就是Node.js命令行开发,和写shell脚本类似，使用JavaScript语言，写一个可执行脚本 hello wold过程如下： 新建一个hello文件，其中#!/usr/bin/env node不可少，其作用是它告诉系统这个脚本需要用node解释器来执行，语法与node一样。
#!/usr/bin/env node console.log(&amp;#39;hello world&amp;#39;); 然后,修改的权限
chmod 755 hello 执行脚本
./hello 如果想把 hello 前面的路径去除，可以将 hello 的路径加入环境变量 PATH。但是，另一种更好的做法，是在当前目录下新建 package.json ，写入下面的内容。
{ &amp;#34;name&amp;#34;: &amp;#34;hello&amp;#34;, &amp;#34;bin&amp;#34;: { &amp;#34;hello&amp;#34;: &amp;#34;hello&amp;#34; } } 然后执行 npm link 命令。
npm link 执行脚本
hello 写一个脚手架 脚手架开发与上面过程类似，有一些npm库可以帮助我们开发命令行工具如shelljs、commander，它们封装了node命令行命令可以更方便命令行开发。 文件目录结构
. ├── bin │ └── ckoa.js ├── package-lock.json ├── package.json └── utils └── download.js ckoa.js Node.js命令行
#!/usr/bin/env node const program = require(&amp;#39;commander&amp;#39;) const chalk = require(&amp;#39;chalk&amp;#39;) const downLoad = require(&amp;#39;.</description></item><item><title>JsonWebToken</title><link>https://chenkai.life/nodejs/jsonwebtoken/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/jsonwebtoken/</guid><description>什么是 JSON Web Token？ JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑且独立的方式，用于在各方之间用 SON 对象安全地传输信息。此信息可以通过数字签名进行验证和信任。 JWT 可以使用加密算法（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。
什么时候应该使用 JSON Web 令牌 以下是 JSON Web 令牌有用的一些场景：
授权：这是使用 JWT 的最常见方案。一旦用户登录，每个后续请求将包括 JWT，允许用户访问该令牌允许的路由，服务和资源。 Single Sign On 是一种现在广泛使用 JWT 的功能，因为它的开销很小，并且能够在不同的域中轻松使用。
信息交换：JSON Web 令牌是在各方之间安全传输信息的好方法。因为 JWT 可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。
JSON Web 令牌结构 JSON Web Tokens 由.分隔的三个部分组成，它们是：
头 有效载荷 签名 因此，JWT 通常如xxxxx.yyyyy.zzzzz所示. 头 标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。
{ &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 然后，这个 JSON 被编码为 Base64Url，形成 JWT 的第一部分。</description></item><item><title>js中的this</title><link>https://chenkai.life/javascript/js-this/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-this/</guid><description>js 中 this 指当前执行代码的环境对象，this 不能在执行期间被赋值如this = null，在绝大多数情况下，函数的调用方式决定了 this 的值
全局环境 浏览器中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。
// 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &amp;#34;MDN&amp;#34;; console.log(window.b); // &amp;#34;MDN&amp;#34; console.log(b); // &amp;#34;MDN&amp;#34; node 环境中 this 是一个空对象
console.log(this); // {} 函数（运行内）环境 在函数内部，this 的值取决于函数被调用的方式
因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象
function f1() { return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window //在Node中： f1() === global; 严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined</description></item><item><title>js的迭代器</title><link>https://chenkai.life/javascript/js-iterator/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-iterator/</guid><description>什么是迭代器 ECMAScript 2015的几个补充，并不是新的内置实现或语法，而是协议。这些协议可以被任何遵循某些约定的对象来实现。有两个协议：可迭代协议和迭代器协议。 JavaScript 提供了许多迭代集合的方法，从简单的 for 循环到 map() 和 filter()，迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for&amp;hellip;of 循环的行为
var myIterator = { next: function() { // ... }, [Symbol.iterator]: function() { return this } } 可迭代协议 为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性:
[Symbol.iterator] 返回一个对象的无参函数，被返回对象符合迭代器协议。
当一个对象需要被迭代的时候（比如开始用于一个for..of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。
class people{ constructor(index){ this.index = index; } next(){ this.index++; return{ done: this.index &amp;gt; 10, value: this.index } } [Symbol.iterator](){ return this; } } let a = new people(3); for (let val of a){ console.</description></item><item><title>koa中间件源码解析</title><link>https://chenkai.life/nodejs/koa-middleware-analys/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/koa-middleware-analys/</guid><description>中间件是koa的核心，koa的中间件机制是一个剥洋葱式的模型，多个中间件通过use放进一个数组队列然后从外层开始执行，遇到next后进入队列中的下一个中间件，所有中间件执行完后开始回帧，执行队列中之前中间件中未执行的代码部分。
源码 koa在koa-compose中实现了中间件部分，
function compose (middleware) { // compose首先会对middleware进行参数检验，middleware必须是一个函数数组， if (!Array.isArray(middleware)) throw new TypeError(&amp;#39;Middleware stack must be an array!&amp;#39;) for (const fn of middleware) { if (typeof fn !== &amp;#39;function&amp;#39;) throw new TypeError(&amp;#39;Middleware must be composed of functions!&amp;#39;) } /** * @param {Object} context * @return {Promise} * @api public */ return function (context, next) { // last called middleware # let index = -1 return dispatch(0) async function dispatch (i) { // 多次调用next函数会导致1 &amp;lt;= index if (i &amp;lt;= index) return Promise.</description></item><item><title>koa跨域</title><link>https://chenkai.life/nodejs/koa-cross-domain/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/koa-cross-domain/</guid><description>跨域 为什么会有跨域问题？ 这是浏览器的同源策略所造成的，同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
一定要注意跨域是浏览器的限制，其实你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。
如何解决跨域? jsonp: 带有src属性的标签都可以用来， 但是只能处理GET请求 document.domain + iframe跨域 location.hash + iframe window.name + iframe postMessage跨域 Nginx配置反向代理 CORS（跨域资源共享）：支持所有类型的HTTP请求 相信大家对于以上的解决方法都很熟悉，这里不再对每一种方法展开讲解，接下来主要讲一下CORS； 简单请求和非简单请求 浏览器将CORS跨域请求分为简单请求和非简单请求；
如果你使用nginx反向代理解决的跨域问题，则不会有跨域请求这个说法了，因为nginx反向代理就使得前后端是同一个域了，就不存在跨域问题了。
只要同时满足一下两个条件，就属于简单请求 (1)使用下列方法之一：
head get post (2)请求的Heder是
Accept Accept-Language Content-Language Content-Type: 只限于三个值： application/x-www-form-urlencoded multipart/form-data text/plain 不同时满足上面的两个条件，就属于非简单请求。 浏览器对这两种的处理，是不一样的。
简单请求 例子 对于简单请求，浏览器直接发出CORS请求。具体来说，就是头信息之中，增加一个Origin字段。
上面这个例子，post``Content-Type``application/x-www-form-urlencoded``Access-Control-Allow-Origin: http://127.0.0.1:3000``Origin``Origin
CORS请求相关的字段，都以 Access-Control-开头 Access-Control-Allow-Origin
：必选
请求头Origin字段的值 *：接受任何域名 Access-Control-Allow-Credentials
：可选，
true: 表示允许发送cookie，此时Access-Control-Allow-Origin不能设置为*，必须指定明确的，与请求网页一致的域名。 不设置该字段：不需要浏览器发送cookie Access-Control-Expose-Headers
：可选
响应报头指示哪些报头可以公开为通过列出他们的名字的响应的一部分。默认情况下，只显示6个简单的响应标头： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 如果想要让客户端可以访问到其他的首部信息，可以将它们在 Access-Control-Expose-Headers 里面列出来。 withCredentials 属性 CORS请求默认不发送Cookie和HTTP认证信息，如果要把Cookie发到服务器，一方面需要服务器同意，设置响应头Access-Control-Allow-Credentials: true,另一方面在客户端发出请求的时候也要进行一些设置;</description></item><item><title>Kubectl</title><link>https://chenkai.life/libs/kubectl/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/kubectl/</guid><description>This page is an overview of the kubectl command.
Kubectl Autocomplete Kubectl Context and Configuration Apply Creating Objects Viewing, Finding Resources Updating Resources Patching Resources Editing Resources Scaling Resources Deleting Resources Interacting with running Pods Interacting with Nodes and Cluster What&amp;rsquo;s next kubectl - Cheat Sheet Kubectl Autocomplete BASH source &amp;lt;(kubectl completion bash) # setup autocomplete in bash into the current shell, bash-completion package should be installed first. echo &amp;#34;source &amp;lt;(kubectl completion bash)&amp;#34; &amp;gt;&amp;gt; ~/.</description></item><item><title>Nginx</title><link>https://chenkai.life/libs/nginx/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/nginx/</guid><description>安装nginx mac:
brew install nginx centos:
Install the prerequisites:
sudo yum install yum-utils [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true By default, the repository for stable nginx packages is used. If you would like to use mainline nginx packages, run the following command:
sudo yum-config-manager --enable nginx-mainline To install nginx, run the following command:
sudo yum install nginx 其他安装方式</description></item><item><title>node Promise 转换</title><link>https://chenkai.life/nodejs/node-promise/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-promise/</guid><description>如果你曾经使用 Javascript，你必须有经验的回调。Javascript 以其内置的异步哲学而闻名。从标准内置模块到其他框架和库，回调无处不在。这就是在 Javascript 中完成异步编程。但是回调有一个黑暗的一面。这叫 Callback Hells。
回调地狱的解决方案是 Promises。而不是通过回调同步返回值或传递结果，我们可以返回一个 Promise，我们将来会返回一些值或错误。 有许多像好的库如 Bluebird 和 Q 可以用来处理 Promise。但是内置的模块和很多其他库不能使用 Promises。这些库能够将传统的回调方法转换为 Promise，在 Node v8 中我们现在可以使用 util.promisify 来处理回调方法。根据 Node.js 的文档： util.promisify(original)
original Returns: const util = require(&amp;#34;util&amp;#34;); const fs = require(&amp;#34;fs&amp;#34;); const stat = util.promisify(fs.stat); stat(&amp;#34;.&amp;#34;) .then((stats) =&amp;gt; { // Do something with `stats` }) .catch((error) =&amp;gt; { // Handle the error. }); 或者; const util = require(&amp;#34;util&amp;#34;); const fs = require(&amp;#34;fs&amp;#34;); const stat = util.</description></item><item><title>node中的多进程</title><link>https://chenkai.life/nodejs/node-child-process/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-child-process/</guid><description>javascript 是单线程的并且只在一个进程中跑，
child_process child_process 模块提供了衍生子进程的能力，此功能主要由 child_process.spawn() 函数提供：
const { spawn } = require(&amp;#34;child_process&amp;#34;); const ls = spawn(&amp;#34;ls&amp;#34;, [&amp;#34;-lh&amp;#34;, &amp;#34;/usr&amp;#34;]); ls.stdout.on(&amp;#34;data&amp;#34;, (data) =&amp;gt; { console.log(`stdout: ${data}`); }); ls.stderr.on(&amp;#34;data&amp;#34;, (data) =&amp;gt; { console.error(`stderr: ${data}`); }); ls.on(&amp;#34;close&amp;#34;, (code) =&amp;gt; { console.log(`子进程退出，使用退出码 ${code}`); }); child_process.spawn() 方法异步地衍生子进程，且不阻塞 Node.js 事件循环。 child_process.spawnSync() 函数则以同步的方式提供了等效的功能，但会阻塞事件循环直到衍生的进程退出或终止。为方便起见， child_process 模块提供了 child_process.spawn() 和 child_process.spawnSync() 的一些同步和异步的替代方法。 这些替代方法中的每一个都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。
[child_process.spawn()]: 方法使用给定的 command 衍生一个新进程，并带上 args 中的命令行参数。 如果省略 args，则其默认为一个空数组。 [child_process.exec()]: 衍生一个 shell 然后在该 shell 中执行 command，并缓冲任何产生的输出。 [child_process.</description></item><item><title>node复用原始接口下载表格</title><link>https://chenkai.life/nodejs/node-download-biaoge-sheji/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-download-biaoge-sheji/</guid><description>我们在做后台开发时可能有很多接口的数据需要下载下来,如果从头开发无疑会有很多重复代码如参数校验、权限验证等，接下来我谈谈我是如何利用现有的 node 接口下载表格
json 数组转表格 一般我们的接口返回的是 json 数组,我们很容易想到只需要把返回数据的 json 转为表格下载就可以了其他逻辑都是一样的，node 有很多现成的库可以处理如xlsx
function frows2XlsxBufferile(formatData) { const ws = xlsx.utils.json_to_sheet(formatData); const wb = xlsx.utils.book_new(); xlsx.utils.book_append_sheet(wb, ws, &amp;#34;SheetJS&amp;#34;); return xlsx.write(wb, { type: &amp;#34;buffer&amp;#34;, bookType: &amp;#34;xlsx&amp;#34; }); } 在 ctx 上下文添加下载文件的方法 默认情况下返回的是文本数据这里需要处理,我这里需要在header中声明返回的内容是一个需要下载的文件
function file(name, data) { // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition // 说明浏览器应该将内容下载到本地；filename 的值预填为下载后的文件名 this.response.set(&amp;#34;Content-disposition&amp;#34;, `attachment;filename=&amp;#34;${name}&amp;#34;`); // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type // 说明返回的是一个二进制流数据 this.response.set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/octet-stream&amp;#34;); return (this.response.body = data); } 返回表格 我们将上面封装下，方便调用,
async download() { const { ctx } = this; const result = await this.</description></item><item><title>node程序放入docker</title><link>https://chenkai.life/nodejs/node-docker/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-docker/</guid><description>准备 demo 程序 index.js &amp;#34;use strict&amp;#34;; const express = require(&amp;#34;express&amp;#34;); // Constants const PORT = 6677; const HOST = &amp;#34;0.0.0.0&amp;#34;; // App const app = express(); app.get(&amp;#34;/&amp;#34;, (req, res) =&amp;gt; { res.send(&amp;#34;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&amp;#34;); }); app.listen(PORT, HOST); console.log(`Running on http://${HOST}:${PORT}`); 根目录新建Dockerfile文件 ## 定义我们需要从哪个镜像进行构建 FROM node:8 ## 在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ &amp;#34;node&amp;#34;, &amp;#34;index.js&amp;#34; ] .dockerignore 文件 这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中 node_modules npm-debug.</description></item><item><title>NPM</title><link>https://chenkai.life/libs/npm/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/npm/</guid><description>npm 配置 修改配置文件 npm配置文件地址~/.npmrc，npm config ls -l,npm config edit命令;
npm的全局node包在哪里？ 就是那些通过npm install xxx -g或者cnpm install xxx -g或者yarn global add xxx安装的xxx文件，到底安装在什么地方？这个其实也挺好找的。默认情况下，可以通过下面的命令查看其基础路径。
npm config get prefix npm root -g 默认的全局安装包位置： win系统下路径是：%APPDATA%/npm/node_modules/ mac系统下路径是：/usr/local/lib/node_modules/
npm 清空缓存 npm cache clean -
设置npm源
npm config set registry http://registry.npmjs.org/ npm config set registry https://registry.npm.taobao.org/ //临时使用 npm i -g express --registry https://registry.npm.taobao.org 更新npm npm install --global npm npm 发布包 # 登陆 npm login --registry http://registry.npmjs.org # 推送 npm publish --registry http://registry.</description></item><item><title>pg 分词</title><link>https://chenkai.life/database/pg-to-tsvector/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-to-tsvector/</guid><description> 分词例子 to_tsvector()生成的分词带有位置信息，tsvector 没有位置信息
select to_tsvector(&amp;#39;陈 锴 A S F a a a 1 2 3 4&amp;#39;); select to_tsvector(&amp;#39;simple&amp;#39;, &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39;); select to_tsvector(&amp;#39;english&amp;#39;, &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39;); `&amp;#39;1&amp;#39;:8 &amp;#39;12&amp;#39;:3 &amp;#39;2&amp;#39;:9 &amp;#39;3&amp;#39;:10 &amp;#39;4&amp;#39;:11 &amp;#39;a&amp;#39;:1,5,6,7 &amp;#39;apple&amp;#39;:2 &amp;#39;f&amp;#39;:4` select &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39; :: tsvector; `&amp;#39;,&amp;#39; &amp;#39;1&amp;#39; &amp;#39;12&amp;#39; &amp;#39;2&amp;#39; &amp;#39;3&amp;#39; &amp;#39;4&amp;#39; &amp;#39;A&amp;#39; &amp;#39;F&amp;#39; &amp;#39;a&amp;#39; &amp;#39;apple&amp;#39; &amp;#39;一个&amp;#39; &amp;#39;锴&amp;#39; &amp;#39;陈&amp;#39;`</description></item><item><title>pg中为存储过程添加进度</title><link>https://chenkai.life/database/pg-how-to-add-process-in-function/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-how-to-add-process-in-function/</guid><description>有时我们可能需要知道长时间调用存储过程的进度。
通过外部表 首先我想到通过修改一张外部表更新存储过程的进度，后来发现这样是不行的。存储过程执行中对数据库的改变在外部是获取不到的，它只有在执行完毕提交后，我们才能获取结果，所以这种方式我们获取到的进度可能全都是 100%。
raise RAISE语句可以在 sql 运行过程中向程序抛出消息或错误，文档
用法如下所示： sql
RAISE INFO &amp;#39;model_progress:%&amp;#39;,json_build_object(&amp;#39;job_uid&amp;#39;,job_uid,&amp;#39;job_progress&amp;#39;,progress); 程序中我们还可以获取到存储过程抛出的消息：如 node 实现所示
const pool = new Pg.Pool(Config.db); pool.on(&amp;#34;connect&amp;#34;, (cl) =&amp;gt; { cl.on(&amp;#34;notice&amp;#34;, (msg) =&amp;gt; { //获取sql抛出的信息 DbNoticeHandler.handle(msg); }); });</description></item><item><title>pg中如何取消正在执行的存储过程</title><link>https://chenkai.life/database/cancel-runing-function/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/cancel-runing-function/</guid><description>如果存储过程执行过程，需要添加可以取消的功能，这里我们需要用到两个函数。
pg_backend_pid: 查询当前会话的服务器进程的进程 ID， pg_cancel_backend(pid int): 取消后端的当前查询。如果调用角色是其后端被取消或已授予调用角色的角色的成员，则也允许这样做 pg_signal_backend，但是只有超级用户可以取消超级用户后端。 在函数中查询当前的 pid create or replace function pg_cancel_backend() returns void as $$ declare backend_pid bigint; begin --查询当前pid backend_pid = pg_backend_pid(); loop raise notice &amp;#39;%&amp;#39;, format(&amp;#39;%1$s : backend_pid: %2$s&amp;#39;, now(),backend_pid); perform pg_sleep(2); end loop; end; $$ language plpgsql; -- 2019-07-25 03:47:30.783608+00 : backend_pid: 13677 根据 pid 取消当前进程 select pg_cancel_backend(13677);</description></item><item><title>pg中对中文字段的排序</title><link>https://chenkai.life/database/pg-chinese-order/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-chinese-order/</guid><description>PostgreSQL 中对字段排序时中文并不会按照拼音排序，在不同的字符集中，汉字的编码可能不一样，比如 UTF8 和 GBK，其中 GBK 大致是按拼音的顺序进行编码的，而 UTF8 则不是。所以如果你的数据库使用了 UTF8 编码，对中文字段进行排序时，得到的并不是按拼音排序的结果。 PostgreSQL 中，中文按拼音排序的编码包括 GB18030, EUC_CN, GBK, BIG5, EUC_TW 等。为了得到拼音排序，可以使用编码转换后的值来排序，如convert_to(name,'GBK')。
对于多音字、生僻字排序结果不太准确：如根据汉字内码扩展规范(GBK) 在 GBK 编码 10 进制濮编码为 58791，总编码为 55260,</description></item><item><title>pg中的数据库时区</title><link>https://chenkai.life/database/pg-timezone/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-timezone/</guid><description> 原因 系统主机与数据库时间不一致； 数据库配置文件中 timezone 与镜像系统里面设置的时区不一致
解决办法 修改数据库/var/lib/postgresql/data/postgresql.conf 中的 timezone 或者镜像时区保持一致后重启数据库
timestamp with time zone，内部存储的值始终为 UTC（通用协调时间，传统上称为格林威治标准时间）。具有指定显式时区的输入值将使用该时区的适当偏移量转换为 UTC。如果输入字符串中未指定时区，则假定它位于系统的 timezone 参数指示的时区中，并使用区域的偏移量转换为 UTC 。当一个 timestamp with time zone 值被输出，它总是从 UTC 转换成当前 timezone 区域，并作为在该区域中的本地时间显示。
步骤 查看数据库时区
show time zone; 查看系统时间与时区
date Thu Nov 19 09:39:58 CST 2015 date -R Thu, 19 Nov 2015 09:40:33 +0800 视图 pg_timezone_names 保存了所有可供选择的时区
select * from pg_timezone_names; 查看配置文件中时区设置，要想永久生效，此时需要修改配置文件
[grep timezone postgresql.conf log_timezone = &amp;#39;US/Pacific&amp;#39; timezone = &amp;#39;US/Pacific&amp;#39; 修改完配置时重新加载
[postgres@rudy_01 ~]$ pg_ctl reload server signaled [postgres@rudy_01 ~]$ psql postgres=# show time zone; TimeZone</description></item><item><title>pg触发器</title><link>https://chenkai.life/database/pg-trigger/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-trigger/</guid><description>触发器 一个触发器声明了当执行一种特定类型的操作时数据库应该自动执行一个特殊的函数。触发器可以被附加到表（分区的或者不分区的）、视图和外部表。 在表和外部表上，触发器可以被定义为在 INSERT、UPDATE 或 DELETE 操作之前或之后被执行， 可以为每个 SQL 语句被执行一次或者为每个修改的行 被执行一次。UPDATE 触发器可以进一步地设置为只针对 UPDATE 语句的 SET 子句的特定列出发。触发器也可以被 TRUNCATE 语句触发。如果一个触发器事件发生， 触发器函数会在适当的事件被调用来处理该事件。
触发器函数必须在触发器本身被创建之前被定义好。触发器函数必须被定义成一个没有参数的函数，并且返回类型为 trigger（触发器函数通过一个特殊传递的 TriggerData 结构作为其输入，而不是以普通函数参数的形式）。 一旦一个合适的触发器函数被创建，就可以使用 CREATE TRIGGER 建立触发器。同一个触发器函数可以被用于多个触发器。
触发器函数规则 当一个 PL/pgSQL 函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：
NEW 数据类型是 RECORD；该变量为行级触发器中的 INSERT/UPDATE 操作保持新数据行。在语句级别的触发器以及 DELETE 操作，这个变量是 null。 OLD 数据类型是 RECORD；该变量为行级触发器中的 UPDATE/DELETE 操作保持新数据行。在语句级别的触发器以及 INSERT 操作，这个变量是 null。 TG_NAME 数据类型是 name；该变量包含实际触发的触发器名。 TG_WHEN 数据类型是 text；是值为 BEFORE、AFTER 或 INSTEAD OF 的一个字符串，取决于触发器的定义。 TG_LEVEL 数据类型是 text；是值为 ROW 或 STATEMENT 的一个字符串，取决于触发器的定义。 TG_OP 数据类型是 text；是值为 INSERT、UPDATE、DELETE 或 TRUNCATE 的一个字符串，它说明触发器是为哪个操作引发。 TG_RELID 数据类型是 oid；是导致触发器调用的表的对象 ID。 TG_RELNAME 数据类型是 name；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用 TG_TABLE_NAME 替代。 TG_TABLE_NAME 数据类型是 name；是导致触发器调用的表的名称。 TG_TABLE_SCHEMA 数据类型是 name；是导致触发器调用的表所在的模式名。 TG_NARGS 数据类型是 integer；在 CREATE TRIGGER 语句中给触发器函数的参数数量。 TG_ARGV[] 数据类型是 text 数组；来自 CREATE TRIGGER 语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于 tg_nargs）会导致返回一个空值。 一个触发器函数必须返回 NULL 或者是一个与触发器为之引发的表结构完全相同的记录/行值。 一个 PL/pgSQL 触发器函数 触发器函数说明文档</description></item><item><title>postgresql中的sequence</title><link>https://chenkai.life/database/pg-sequence/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-sequence/</guid><description>sequence 号是数据库系统按照一定规则自增的数字序列 sequence 操作函数
Function Return Type Description currval(regclass) bigint Return value most recently obtained with nextval for specified sequence lastval() bigint Return value most recently obtained with nextval for any sequence nextval(regclass) bigint Advance sequence and return new value setval(regclass, bigint) bigint Set sequence&amp;#39;s current value setval(regclass, bigint, boolean) bigint Set sequence&amp;#39;s current value and is_called flag 创建 sequence postgre文档
sequence 操作函数定义
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] name [ AS data_type ] [ INCREMENT [ BY ] increment ] [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ] [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ] [ OWNED BY { table_name.</description></item><item><title>postgres有用的sql</title><link>https://chenkai.life/database/pg-useful-sql/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-useful-sql/</guid><description>数据库迁移备份 备份：pg_dump -U postgres -d myDBname -f dump.sql 还原：
pg_dump -U postgres -d g-default -f g-default.sql
忽略某些 schema psql -N data -N public_data -d g-default -U postgres -f g-default.sql
将 mydb 数据库转储到一个 SQL 脚本文件：pg_dump mydb &amp;gt; db.sql 将上述脚本导入一个(新建的)数据库 newdb：psql -d newdb -f db.sql
将数据库转储为自定义格式的归档文件pg_dump -Fc mydb &amp;gt; db.dump 将数据库转储为目录格式归档：pg_dump -Fd mydb -f dumpdir 将数据库转储为目录格式归档，并行 5 个 worker 工作：pg_dump -Fd mydb -j 5 -f dumpdir 将归档文件导入一个(新建的)数据库 newdb：pg_restore -d newdb db.dump</description></item><item><title>postgre中的复合类型</title><link>https://chenkai.life/database/pg-composite-type/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-composite-type/</guid><description>声明复合类型 Composite Types:复合类型Composite Types表示行或记录的结构; 它本质上只是一个字段名称及其数据类型。 PostgreSQL 允许复合类型像用简单类型相同的方式使用。 例如，表的列可以声明为复合类型。 语法与 CREATE TABLE 相当，只是可以指定字段名称和类型; 目前不能包含任何约束（例如 NOT NULL）。 请注意，AS 关键字是必不可少的; 没有它，系统会认为有一种不同的 CREATE TYPE 命令，你会得到奇怪的语法错误。 以下是定义复合类型的两个简单示例：
CREATE TYPE complex AS ( r double precision, i double precision ); CREATE TYPE inventory_item AS ( name text, supplier_id integer, price numeric ); 定义了类型后，我们可以使用它们：
CREATE TABLE on_hand ( item inventory_item, count integer ); INSERT INTO on_hand VALUES (ROW(&amp;#39;fuzzy dice&amp;#39;, 42, 1.99), 1000); CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric AS &amp;#39;SELECT $1.</description></item><item><title>Redis的五种数据结构及其使用场景</title><link>https://chenkai.life/libs/redis-use-scene/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/redis-use-scene/</guid><description>from https://www.cnblogs.com/ottll/p/9470480.html
String 常用命令：
get、set、incr、decr、mget等
应用场景：
String是最常用的数据类型，普通的key/value都可以归为此类，value其实不仅是String，也可以是数字。
比如想知道什么时候封锁一个IP地址(访问超过几次)。INCRBY命令让这些变得很容易，通过原子递增保持计数。
实现方式：
m,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。
2.Hash
常用命令：
hget、hset、hgetall等
应用场景：
比如我们要存储一个用户的信息，包含以下信息：
用户ID，为查找的key
存储的value用户对象包含姓名name，年龄age，生日birthday 等信息
如果以普通的key/value结构存储，主要有以下两种存储方式：
第一种方式将用户id作为key，其他信息封装成对象以序列化的方式存储，如
set u001 &amp;ldquo;李三,18,20010101&amp;rdquo;
这种方式的缺点，增加了序列化/反序列化的开销；需要修改其中一项信息时，需要把整个对象取回，修改操作需要对并发进行保护，引入CAS等复杂问题。
第二种方式是这个用户信息有多少成员就存成多少个key-value对，用用户id+对应属性名称作为唯一的标识来取得对应属性的值，如：
mset user:001:name &amp;ldquo;李三 &amp;ldquo;user:001:age18 user:001:birthday &amp;ldquo;20010101&amp;rdquo;
虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费较大。
redis提供的hash很好的解决了这个问题，redis的hash实际是内部存储的value为一个HashMap，并且提供了直接存取这个map的成员接口。如
hmset user:001 name &amp;ldquo;李三&amp;rdquo; age 18 birthday &amp;ldquo;20010101&amp;rdquo;
也就是说，key仍然是用户id，value是一个map，这个map的key是成员的属性名，value是属性值。
这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。
实现方式：
Redis的Hash对应的Value内部实际就是一个HashMap，实际有两种不同的实现，如果成员较少时，Redis为了节省内存会采用类似一维数组方式存储，对应的value RedisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap，此时encoding为ht。
3.List
常用命令：
lpush,rpush,lpop,rpop,lrange,BLPOP(阻塞版)等。
应用场景：
最新消息排行。
消息队列。利用Lists的push的操作，将任务存储在list中，然后工作线程再用pop操作将任务取出进行执行。
实现方式：
redis list的实现是一个双向链表，可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，redis内部的很多实现，包括发送缓冲队列等也都用的是这个数据结构。
Set 常用命令：
sadd,srem,spop,sdiff ,smembers,sunion 等。
应用场景：
set类似list，特殊之处是set可以自动排重。
set还提供了某个成员是否在一个set内的接口，这个也是list没有的。
比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。
Redis还为集合提供了求交集、并集、差集等操作。
实现方式：
set内部实现是一个value永远为null的HashMap，实际就是通过hash的方式快速排重的。
Sort Set 常用命令：</description></item><item><title>Reflect和Proxy</title><link>https://chenkai.life/javascript/js-reflect-and-proxy/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-reflect-and-proxy/</guid><description>Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，
new Proxy()表示生成一个 Proxy 实例， target参数表示所要拦截的目标对象， handler参数也是一个对象，用来定制拦截行为。 var proxy = new Proxy( {}, { get: function (target, property) { return 35; }, } ); proxy.time; // 35 proxy.name; // 35 proxy.title; // 35 上面代码中，作为构造函数，Proxy 接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回 35，所以访问任何属性都得到 35。 注意，要使得 Proxy 起作用，必须针对Proxy实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。
如果 handler 没有设置任何拦截，那就等同于直接通向原对象。
let peo = {}; let proxyP = new Proxy(peo, {}); proxyP.</description></item><item><title>sequelize建立表关系</title><link>https://chenkai.life/libs/sequelize-associations/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/sequelize-associations/</guid><description>Associations Sequelize supports the standard associations: One-To-One, One-To-Many and Many-To-Many.
To do this, Sequelize provides four types of associations that should be combined to create them:
The HasOne association The BelongsTo association The HasMany association The BelongsToMany association The guide will start explaining how to define these four types of associations, and then will follow up to explain how to combine those to define the three standard association types (One-To-One, One-To-Many and Many-To-Many).</description></item><item><title>Shell</title><link>https://chenkai.life/libs/shell/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/shell/</guid><description>查看可用的shellcat /etc/shells 切换shell工具chsh -s /bin/bash 使环境变量生效source ~/.zshrc
mac开机自动运行shell脚本 chmod +x ./test.sh #使脚本具有执行权限 系统偏好设置 》 用户与群组 》登录项 》 添加shell脚本 执行shell脚本 作为可执行程序 chmod +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 作为解释器参数 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： /bin/sh test.sh /bin/php test.php shell find 示例 - 查找命令 find /dir/to/search -name &amp;#34;file-to-search&amp;#34; find /dir/to/search -name &amp;#34;file-to-search&amp;#34; -print find /dir/to/search -name &amp;#34;file-to-search&amp;#34; -ls find /dir/to/search -name &amp;#34;regex&amp;#34; -print 要查找当前目录下的所有的Perl（特等）文件： $ find . -name '*.pl' 将。表示当前目录，-name选项指定所有pl（perl）文件。引号避免了shell扩展，当你想使用基于通配符的搜索时，它是必要的（没有引号，shell会将 .pl替换为当前目录中的文件列表）。
仅列出文件并避免所有目录 以下命令将仅列出文件，并将排除目录，特殊文件，管道，符号链接等：
find .</description></item><item><title>Vue组件的自动按需引入</title><link>https://chenkai.life/vue/vue-component-registration/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue-component-registration/</guid><description>在Vue中我们可以通过全局组件、局部注册的方式来使用组件
全局注册 通过app.component来创建全局组件
import { createApp } from &amp;#39;vue&amp;#39; import HelloWorld from &amp;#39;./components/HelloWorld&amp;#39; const app = createApp({}) // 全局注册一个名为hello-wolrd的组件 app.component(&amp;#39;hello-wolrd&amp;#39;, HelloWorld); 一旦我们全局注册了组件，我们就可以在任何地方使用这个组件：&amp;lt;hello-wolrd/&amp;gt;
值得注意的是全局注册会使Vue失去TypeScript的支持, Vue 3 有一个 PR 扩展了全局组件的接口。目前，Volar 已经支持这种用法，我们可以通过在根目录添加components.d.ts文件的方式来添加全对局组件的TypeScript的支持
declare module &amp;#39;vue&amp;#39; { export interface GlobalComponents { HelloWorld: typeof import(&amp;#39;./src/components/HelloWorld.vue&amp;#39;)[&amp;#39;default&amp;#39;] } } 局部注册 我们可以直接从文件中引入vue组件使用，
在单文件组件中（SFC）
&amp;lt;template&amp;gt; &amp;lt;HelloWorld msg=&amp;#34;Welcome to Your Vue.js App&amp;#34;/&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import HelloWorld from &amp;#39;./components/HelloWorld.vue&amp;#39; export default { name: &amp;#39;App&amp;#39;, components: { HelloWorld } } &amp;lt;/script&amp;gt; 在JSX中</description></item><item><title>WebAssembly上手</title><link>https://chenkai.life/web/webassembly/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/webassembly/</guid><description>WebAssembly是什么 WebAssembly是为高效执行和紧凑表示而设计的运行在现代处理器（包括浏览器）中的一种快速、安全、可移植的底层代码格式，具有紧凑的二进制格式，可以以接近本机的性能运行。2019年12月5日W3C宣布WebAssembly核心规范成为正式标准。名字上可以知道是给Web使用的汇编语言。但是WebAssembly并不是直接用汇编语言，而提供了转换机制（LLVM IR），把高级别的语言（AssemblyScript、go、C、C++、Rust等）编译为WebAssembly，以便有机会通过Web浏览器执行低级二进制语法 。
WebAssembl的特点 WebAssembly是一门不同于JavaScript的语言，它不是用来取代JavaScript的。相反，它被设计为和JavaScript一起协同工作，从而使得网络开发者能够利用两种语言的优势，通过使用WebAssembly的JavaScriptAPI，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。
快速：大幅度提高 Javascript 的性能，以接近本机的代码性能执行。 安全：代码经过验证并在内存安全沙盒环境中执行，可防止数据损坏或安全漏洞。 与语言无关：允许任何语言编译到WebAssembly， 可以用其他高级语言写网页。 与硬件无关：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。 与平台无关：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。 紧凑：具有比典型的文本或本机代码格式小的传输速度快的二进制格式。 模块化：程序可以分成较小的部分，可以分别传输，缓存和使用。 高效：可以通过快速一次通过来解码，验证和编译，等同于实时（JIT）或提前（AOT）编译。 Streamable：允许在看到所有数据之前尽快开始解码，验证和编译。 为什么WebAssembly比JavaScript 执行效率更高 WebAssembly最吸引人的特点便是它的执行效率，比JavaScript执行效率更高主要有以下原因：
文件获取阶段：WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段：WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段：WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段：WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码&amp;lt;-&amp;gt;重优化”现象。 执行阶段：WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。 如何使用WebAssembly 高级语言编译到 .wasm 文件 WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。 想要编译成WebAssembly，你首先需要先编译 LLVM，参考webassembly.org. LLVM可以实现</description></item><item><title>Web面试问题</title><link>https://chenkai.life/hide/web-mian-shi-qs2/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/hide/web-mian-shi-qs2/</guid><description>&lt;h2 id="前端工作面试问题">
前端工作面试问题
&lt;a class="heading-link" href="#%e5%89%8d%e7%ab%af%e5%b7%a5%e4%bd%9c%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;p>本文包含了一些用于考查候选者的前端面试问题。不建议对单个候选者问及每个问题 (那需要好几个小时)。只要从列表里挑选一些，就能帮助你考查候选者是否具备所需要的技能。&lt;/p>
&lt;p>&lt;strong>备注：&lt;/strong> 这些问题中很多都是开放性的，可以引发有趣的讨论。这比直接的答案更能体现此人的能力。&lt;/p>
&lt;h2 id="a-nametoc目录a">
&lt;a name='toc'>目录&lt;/a>
&lt;a class="heading-link" href="#a-nametoc%e7%9b%ae%e5%bd%95a">
&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>
&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#general-questions">常见问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#html-questions">HTML 相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#css-questions">CSS 相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#js-questions">JS 相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#testing-questions">测试相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#performance-questions">效能相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#network-questions">网络相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#coding-questions">代码相关问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="#fun-questions">趣味问题&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>yum</title><link>https://chenkai.life/libs/yum/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/libs/yum/</guid><description>yum是种软件包管理器，yum 主要功能是更方便的添加/删除/更新RPM 包，自动解决包的倚赖性问题，便于管理大量系统的更新问题。yum 可以同时配置多个资源库(Repository)，简洁的配置文件（/etc/yum.conf），自动解决增加或删除rpm 包时遇到的依赖性问题，保持与RPM 数据库的一致性。
配置# yum 的配置文件分为两部分：main 和repository
main 部分定义了全局配置选项，整个yum 配置文件应该只有一个main。常位于/etc/yum.conf 中。 repository 部分定义了每个源/服务器的具体配置，可以有一到多个。常位于/etc/yum.repo.d 目录下的各文件中。 yum.conf 文件一般位于/etc目录下，一般其中只包含main部分的配置选项。
# cat /etc/yum.conf
yum.conf
除了上述之外，还有一些可以添加的选项，如：
exclude=selinux*　// 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安装了诸如美化包，中文补丁的朋友特别有用。 gpgcheck=1　// 有1和0两个选择，分别代表是否是否进行gpg(GNU Private Guard) 校验，以确定rpm 包的来源是有效和安全的。这个选项如果设置在[main]部分，则对每个repository 都有效。默认值为0。
1. 配置本地yum源
(1) 挂载光盘
mount /dev/cdrom /mnt/ (2)配置本地yum源
查看/etc/yum.repo.d/下有四个文件
CentOS-Base.repo 是yum 网络源的配置文件
CentOS-Media.repo 是yum 本地源的配置文件
修改CentOS-Media.repo文件
#cat /etc/yum.repo.d/CentOS-Media.repo
CentOS-Media.repo
在baseurl 中修改第2个路径为 /mnt/（即为光盘挂载点）
将enabled=0改为1
(3)禁用网络yum源
将CentOS-Base.repo 重命名为CentOS-Base.repo.bak,否则会先在网络源中寻找适合的包，改名之后直接从本地源读取。 (4) 执行yum命令测试
yum install bind 关于repo的格式# 所有repository 服务器设置都应该遵循如下格式：
[serverid] name=Some name for this server baseurl=url://path/to/repository/ serverid 是用于区别各个不同的repository，必须有一个独一无二的名称； name 是对repository 的描述，支持像𝑟𝑒𝑙𝑒𝑎𝑠𝑒𝑣𝑒𝑟releaseverbasearch这样的变量； baseurl 是服务器设置中最重要的部分，只有设置正确，才能从上面获取软件。它的格式是： baseurl=url://server1/path/to/repository/ url://server2/path/to/repository/ url://server3/path/to/repository/ 其中url 支持的协议有 http:// ftp:// file:// 三种。baseurl 后可以跟多个url，你可以自己改为速度比较快的镜像站，但baseurl 只能有一个，也就是说不能像如下格式：</description></item><item><title>一个关于Promise的问题</title><link>https://chenkai.life/javascript/one-question-about-promise/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/one-question-about-promise/</guid><description>一道题带来的疑问 掘金上的一道题： JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个，一个解法如下：
const timeout = (time) =&amp;gt; new Promise((resolve) =&amp;gt; { setTimeout(resolve, time); }); class Scheduler { constructor() { this.awaitArr = []; this.count = 0; } async add(promiseCreator) { if (this.count &amp;gt;= 2) { await new Promise((resolve) =&amp;gt; { this.awaitArr.push(resolve); }); } this.count++; const res = await promiseCreator(); this.count--; if (this.awaitArr.length) { this.awaitArr.shift()(); } return res; } } const scheduler = new Scheduler(); const addTask = (time, order) =&amp;gt; { scheduler.</description></item><item><title>了解什么是Polyfill</title><link>https://chenkai.life/posts/polyfill/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/polyfill/</guid><description>什么是 polyfill 初次了解 polyfill 这个词,是在一次面试中，题目是使用数组的reduse方式实现map方法，全世界使用着许多不同的浏览器和版本的浏览器，每个浏览器都具有与其他浏览器完全不同的功能集。这会使浏览器开发成为一项艰巨的任务。流行浏览器的最新版本可以完成许多旧浏览器无法完成的任务-但您可能仍必须支持旧浏览器。通过尝试使用 polyfills 重新创建缺少的功能，Polyfill.io 使支持不同的浏览器变得更简单：您可以在支持或不支持的浏览器中利用最新和最强大的功能。
如 vue 中对 bind 的 polyfill 代码如下
function polyfillBind(fn, ctx) { function boundFn(a) { var l = arguments.length; return l ? l &amp;gt; 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx); } boundFn._length = fn.length; return boundFn; } function nativeBind(fn, ctx) { return fn.bind(ctx); } var bind = Function.prototype.bind ? nativeBind : polyfillBind; 常用对 polyfill 方法 babel-polyfill 提供完整的 ES2015+环境
polyfill.io polyfill.</description></item><item><title>介绍几个表达式和运算符</title><link>https://chenkai.life/javascript/js-operator/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-operator/</guid><description>空值合并运算符 ??是一个逻辑操作符，当左侧的表达式结果为 null 或者 undefined 时，其返回右侧表达式的结果，否则返回左侧表达式的结果。
以前，如果想为一个变量赋默认值，通常的做法是使用逻辑或操作符|| 然而，由于 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， ''， NaN， null， undefined）都不会被返回。这导致如果你使用0，''或NaN作为有效值，就会出现不可预料的后果。空值合并操作符可以避免这种陷阱，其只在第一个操作数为null 或 undefined 时（而不是其它假值）返回第二个操作数
let myText = &amp;#39;&amp;#39;; // An empty string (which is also a falsy value) let notFalsyText = myText || &amp;#39;Hello world&amp;#39;; console.log(notFalsyText); // Hello world let preservingFalsy = myText ?? &amp;#39;Hi neighborhood&amp;#39;; console.log(preservingFalsy); // &amp;#39;&amp;#39; (as myText is neither undefined nor null) //因为空值合并操作符和其他逻辑操作符之间的运算优先级/运算顺序是未定义的 null || undefined ?? &amp;#34;foo&amp;#34;; // 抛出 SyntaxError (null || undefined ) ?</description></item><item><title>你不知道的package.json</title><link>https://chenkai.life/posts/you-dont-konw-package-json/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/you-dont-konw-package-json/</guid><description>engines 描述模块的兼容性如:
指定模块运行的 node 版本
{ &amp;#34;engines&amp;#34;: { &amp;#34;Node.js&amp;#34;: &amp;#34;&amp;gt;=0.10.3 &amp;lt;15&amp;#34; } } 指定模块运行的 npm 版本
{ &amp;#34;engines&amp;#34;: { &amp;#34;npm&amp;#34;: &amp;#34;~1.0.20&amp;#34; } } 禁止使用 yarn
{ &amp;#34;engines&amp;#34;: { &amp;#34;yarn&amp;#34;: &amp;#34;please use npm&amp;#34; } } files 指定发布到 npm 中的文件,默认是所有文件[&amp;quot;*&amp;quot;] 你也可以通过.npmignore防止某些文件被包含在内，它不会覆盖files字段，但会覆盖其子目录。 如果不存在.npmignore将使用.gitignore替代
一般来说npm上我们只需要发布打包好的文件，对于git则恰好相反我们只需要提交源代码
bin 安装可执行文件 如果你的包都有一个或多个想要安装到 PATH 中的可执行文件，请在package.json中提供一个bin字段，它是命令名到本地文件名的映射。当这个包被全局安装时，该文件将被链接到全局bin所在的位置，因此它可以按名称运行。当这个包作为另一个包的依赖项安装时，该文件将被链接到该包可以直接通过 npm exec 或通过 npm run-script 调用它们时在其他脚本中的名称, 以typescript举例，在package.json文件中存在
{ &amp;#34;bin&amp;#34;: { &amp;#34;tsc&amp;#34;: &amp;#34;./bin/tsc&amp;#34;, &amp;#34;tsserver&amp;#34;: &amp;#34;./bin/tsserver&amp;#34; } } 全局安装 所以通过全局安装npm install -g typescript 我们可以在命令行中使用tsc命令, 通过which tsc 我们可以查看可执行文件在/Users/chenkai/.</description></item><item><title>使用koa创建基于http2的服务</title><link>https://chenkai.life/nodejs/koa-http2/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/koa-http2/</guid><description>使用koa创建服务 使用koa我们可以很容易创建一个http服务
const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.body = &amp;#39;Hello World&amp;#39;; }); app.listen(3000); 其中app.listen(...) 方法只是以下内容的糖：
const http = require(&amp;#39;http&amp;#39;); const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.body = &amp;#39;Hello World&amp;#39;; }); http.createServer(app.callback()).listen(3000) 创建一个http2服务 想当然的我们可能会首先尝试使用一下代码创建一个http2服务
const http2 = require(&amp;#39;http2&amp;#39;); const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.body = &amp;#39;Hello World&amp;#39;; }); http2.</description></item><item><title>前后端通过切片上传文件</title><link>https://chenkai.life/web/web-upload-file/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/web-upload-file/</guid><description>最近在做前端上传文件，主要包括选择单个｜多个文件、单个｜多个文件夹、拖拽文件｜文件夹方式上传文件，上传时通过分片计算文件hash值实现断点续传、秒传功能，简要介绍下具体实行思路
获取用户选择文件 注意这种方式用到的部分特性是非标准的
拖拽上传 从可拖拽区域中获取过滤获取拖拽的文件的FileSystemEntry
async drop(e) { e.stopPropagation(); e.preventDefault(); let items = e.dataTransfer.items; let dropFilesEntrys = []; for (let item of items) { if (!item || !item.webkitGetAsEntry) continue; item = item.webkitGetAsEntry(); if (!item) continue; let filesEntrys = await this.getFilesEntrys(item); dropFilesEntrys.push(...filesEntrys); } let files = await this.transformFilesEntrys(dropFilesEntrys); this.handerFiles(files); }, 获取FileSystemEntry包含的FilesEntrys，FileSystemEntry可能代表文件系统中的文件或者目录
/** * 获取drop区域的文件 * @returns FilesEntrys */ async getFilesEntrys(item) { let filesEntrys = []; let scanFiles = async (item) =&amp;gt; { return new Promise((resolve) =&amp;gt; { if (item.</description></item><item><title>前端开发面试题</title><link>https://chenkai.life/hide/web-mian-shi-qs1/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/hide/web-mian-shi-qs1/</guid><description>前端开发面试题 （题目列表页） 目录 前言 HTML部分 CSS部分 JavaScript部分 其他问题 前端学习网站推荐 前言 前言
HTML Doctype作用？严格模式与混杂模式如何区分？它们有何意义?
HTML5 为什么只需要写 &lt;!DOCTYPE HTML>？
行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？
页面导入样式时，使用link和@import有什么区别？
介绍一下你对浏览器内核的理解？
常见的浏览器内核有哪些？
html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
简述一下你对HTML语义化的理解？
HTML5的离线储存怎么使用，工作原理能不能解释一下？
浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？
请描述一下 cookies，sessionStorage 和 localStorage 的区别？
iframe有那些缺点？
Label的作用是什么？是怎么用的？（加 for 或 包裹）
HTML5的form如何关闭自动完成功能？
如何实现浏览器内多个标签页之间的通信? (阿里)
webSocket如何兼容低浏览器？(阿里)
页面可见性（Page Visibility API） 可以有哪些用途？
如何在页面上实现一个圆形的可点击区域？
实现不使用 border 画出1px高的线，在不同浏览器的Quirksmode和CSSCompat模式下都能保持同一效果。
网页验证码是干嘛的，是为了解决什么安全问题？
title与h1的区别、b与strong的区别、i与em的区别？
CSS 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？
CSS选择符有哪些？哪些属性可以继承？
CSS优先级算法如何计算？
CSS3新增伪类有那些？
如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？
display有哪些值？说明他们的作用。
position的值relative和absolute定位原点是？
CSS3有哪些新特性？
请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？
用纯CSS创建一个三角形的原理是什么？
css多列等高如何实现？
一个满屏 品 字布局 如何设计?</description></item><item><title>前端开发面试题及答案</title><link>https://chenkai.life/hide/web-min-shi-qsan/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/hide/web-min-shi-qsan/</guid><description>前端开发面试题
前言 只看问题点这里
看全部问题和答案点这里
本文由我收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！
前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。
最近也收到许多微博私信的鼓励和更正题目信息，后面会经常更新题目和答案到github博客。希望前端er达到既能使用也会表达，对理论知识有自己的理解。可根据下面的知识点一个一个去进阶学习，形成自己的职业技能链。
面试有几点需注意：(来源寒冬winter 老师，github:@wintercn)
面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。
题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。
细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。
回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲( •̣̣̣̣̣̥́௰•̣̣̣̣̣̥̀ )）
资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。
前端开发所需掌握知识点概要：
HTML&amp;amp;CSS： 对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、 Hack、CSS预处理器、CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5（离线 &amp;amp; 存储、Histoy,多媒体、WebGL\SVG\Canvas）； JavaScript： 数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、 内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、 其他： 主流MVVM框架(React\Vue\Angular)、Hybrid App\React Native\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、 重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等； 作为一名前端工程师，无论工作年头长短都应该掌握的知识点：
此条由 王子墨 发表在 攻城师的实验室
1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。 2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。 3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。 4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。 5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。 6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型 7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们 8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。 9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。 10、JSON —— 作用、用途、设计结构。 备注：</description></item><item><title>如何优雅的提示用户需要升级npm依赖包版本？</title><link>https://chenkai.life/posts/npm-deprecate-version/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/npm-deprecate-version/</guid><description>背景 某次更新@ckpack/vue-color时引入了严重bug，影响的版本是&amp;gt;=1.0.0,&amp;lt;=1.1.3，并在1.1.4中修复了该问题，问题来了，如何优雅的提示安装该包的人需要升级1.1.4版本呢？
解决办法 首先想到的是百度、谷歌没有，但是找到🤷‍♂️ 哪就看看npm有哪些命令吧npm help access, adduser, audit, bin, bugs, cache, ci, completion, config, dedupe, deprecate, diff, dist-tag, docs, doctor, edit, exec, explain, explore, find-dupes, fund, get, help, hook, init, install, install-ci-test, install-test, link, ll, login, logout, ls, org, outdated, owner, pack, ping, pkg, prefix, profile, prune, publish, rebuild, repo, restart, root, run-script, search, set, set-script, shrinkwrap, star, stars, start, stop, team, test, token, uninstall, unpublish, unstar, update, version, view, whoami 直觉告诉我用unpublish，npm help unpublish 试试, 帮助信息中有一句 Warning Consider using the npm help deprecate command instead, if your intent is to encourage users to upgrade, or if you no longer want to maintain a package.</description></item><item><title>展开语法和剩余参数</title><link>https://chenkai.life/javascript/js-spread-and-rest/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-spread-and-rest/</guid><description>展开语法 展开语法(Spread syntax),只能用于可迭代对象, 可以在函数调用/数组构造时, 将数组表达式或者 string 在语法层面展开；还可以在构造字面量对象时, 将对象表达式按 key-value 的方式展开
a = { name: &amp;#34;mdn&amp;#34; }; b = [1, 2, 3]; console.log({ ...a }); console.log([...b]); //函数参数 function sum(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); console.log(sum.apply(null, numbers)); //构造 var parts = [&amp;#34;shoulders&amp;#34;, &amp;#34;knees&amp;#34;]; var lyrics = [&amp;#34;head&amp;#34;, ...parts, &amp;#34;and&amp;#34;, &amp;#34;toes&amp;#34;]; // [&amp;#34;head&amp;#34;, &amp;#34;shoulders&amp;#34;, &amp;#34;knees&amp;#34;, &amp;#34;and&amp;#34;, &amp;#34;toes&amp;#34;] var obj1 = { foo: &amp;#34;bar&amp;#34;, x: 42 }; var obj2 = { foo: &amp;#34;baz&amp;#34;, y: 13 }; var clonedObj = { .</description></item><item><title>常用的shell命令总结</title><link>https://chenkai.life/posts/commonly-used-shel-command/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/commonly-used-shel-command/</guid><description>常用的shell命令
alias用来设置指令的别名 apkAlpine Linux下的包管理工具apk install xxx awk文本和数据进行处理的编程语言 cat连接文件并打印到标准输出设备上 cd切换用户当前工作目录 chmod用来变更文件或目录的权限 chsh用来更换登录系统时使用的shellchsh -s /bin/zsh command调用并执行指定的命令command echo Linux cp将源文件或目录复制到目标文件或目录中cp -r /usr/men /usr/zh crontab提交和管理用户的需要周期性执行的任务 curl利用URL规则在命令行下工作的文件传输工具curl baidu.com -o baidu.html --progress df显示磁盘的相关信息df -ah diff比较给定的两个文件的不同diff /usr/li test.txt dig域名查询工具dig baidu.com dirs显示目录记录dirs du显示每个文件和目录的磁盘使用空间du -sh ./* echo输出指定的字符串或者变量 egrep在文件内查找指定的字符串与grep类似 env显示系统中已存在的环境变量env exec调用并执行指定的命令 exit退出当前的shell export设置或显示系统环境变量export -p fc修改历史命令并执行fc -l -10 find在指定目录下查找文件find / 'nginx.conf' grep强大的文本搜索工具grep &amp;quot;match_pattern&amp;quot; file_1 file_2 gunzip用来解压缩文件gunzip /opt/etc.zip.gz gzip用来压缩文件gzip -9v ./1.html head在屏幕上显示指定文件的开头若干行head -n 10 CHANGELOG history用于显示历史命令history 100 host常用的分析域名查询工具host chenkai.life htop一个互动的进程查看器，可以动态观察系统进程状况 iconv转换文件的编码方式iconv file1 -f EUC-JP-MS -t UTF-8 -o file2 ifconfig配置和显示Linux系统网卡的网络参数 kill删除执行中的程序或工作 last列出目前与过去登入系统的用户相关信息 locate文件查找工具,将硬盘中的所有档案和目录资料先建立一个索引数据库locate nginx login登录系统或切换用户身份 logname用来显示用户名称 ls显示目录内容列表ls -alh ln用来为文件创建软硬连接 创建硬链接ln 源文件 目标文件，软链接ln -s 源文文件或目录 目标文件或目录 lsof用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)lsof -i:5577 mkdir用来创建目录mkdir -m 700 /usr/meng/test more显示文件内容，每次显示一屏more -c -10 file mv用来对文件或目录重新命名mv file_1.</description></item><item><title>拷贝数据到剪贴板</title><link>https://chenkai.life/web/brower-copy-to-clipboard/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/brower-copy-to-clipboard/</guid><description>介绍几种在浏览器中拷贝数据到剪贴板的方法
document.execCommand(&amp;ldquo;copy&amp;rdquo;) 拷贝当前选中内容到剪贴板, 该 api 已经废弃不推荐使用，
function fallbackCopyTextToClipboard(text) { const textArea = document.createElement(&amp;#34;textarea&amp;#34;); textArea.value = text; textArea.style.top = &amp;#34;0&amp;#34;; textArea.style.left = &amp;#34;0&amp;#34;; textArea.style.position = &amp;#34;fixed&amp;#34;; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { let msg = document.execCommand(&amp;#34;copy&amp;#34;); if (!msg) { throw new Error(&amp;#34;Copy filed&amp;#34;); } } finally { document.body.removeChild(textArea); } } navigator.clipboard 剪贴板 Clipboard API 提供了响应剪贴板命令（剪切、复制和粘贴）与异步读写系统剪贴板的能力。从权限 Permissions API 获取权限之后，才能访问剪贴板内容；如果用户没有授予权限，则不允许读取或更改剪贴板内容。该 API 被设计用来取代使用 document.execCommand() 的剪贴板访问方式。(基于 HTTP 的网站中包含的脚本则不能获得剪贴板对象)
await navigator.clipboard.writeText(data); npm package clipboard, 内部使用的 document.execCommand(), clipboardy, 该库较重，支持 web 平台之外的 copy</description></item><item><title>浏览器处理cookie</title><link>https://chenkai.life/web/cookie/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/cookie/</guid><description>设置 cookie function setCookie(options) { const { name, data } = options; const age = options.age || 24 * 3600000; const domain = options.domain || window.location.hostname; document.cookie = `${name}=${data}; path=/; max-age=${age}; domain=${domain}`; } 获取 cookie function getCookie(cookie_name) { let value = null; let allcookies = document.cookie; let cookie_pos = allcookies.indexOf(cookie_name); if (cookie_pos != -1) { cookie_pos = cookie_pos + cookie_name.length + 1; let cookie_end = allcookies.indexOf(&amp;#34;;&amp;#34;, cookie_pos); if (cookie_end == -1) { cookie_end = allcookies.</description></item><item><title>深入理解UUID</title><link>https://chenkai.life/posts/uuid-understand/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/uuid-understand/</guid><description>UUID是什么 UUIDUniversally unique identifier 是一种唯一的字符串，用来标识一个设备或一个应用程序的唯一性。根据标准方法生成时，UUID 出于实用目的是唯一的。与大多数其他编号方案不同，它们的唯一性不依赖于中央注册机构或生成它们的各方之间的协调。虽然UUID 被复制的概率不是零，但它足够接近零，可以忽略不计.
UUID是固定长度128位，表示为 32 个十六进制（base-16）数字，显示在由连字符分隔的五组中，格式为 8-4-4-4-12 总共 36 个字符（32 个十六进制字符和 4 个连字符）例如：
123e4567-e89b-12d3-a456-426614174000 xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
数字的四位M是 UUID 版本（version），数字的 1 到 3 位最高有效位是NUUID的变体（variant），在示例中，M是1，N是a(10xx 2 )，这意味着这是一个version-1、variant-1 的 UUID。
变体（variant） UUID的变体（variant）字段，占1或2或3比特。RFC 4122定义了4种变体：
变体 0 (形如0xxx), 用于向后兼容已经过时的1988年开发的 Apollo 网络计算系统（NCS）1.5 UUID 格式. 变体 1 (形如10xx), 它是按照大端序作为二进制存储与传输 变体 2 (形如110x), 它是按照小端序作为二进制存储与传输 变体 3 (形如111x), 保留未使用 UUID的编码有很多种下面我只介绍Version 4 (random)，
版本（version） 对于“变体（variants）1、2，标准中定义了五个版本（versions），在特定用例中每个版本可能比其他版本更合适。版本由 M 字符串中指示。
版本1 - UUID 是根据时间和 节点ID（通常是MAC地址）生成； 版本2 - UUID是根据标识符（通常是组或用户ID）、时间和节点ID生成； 版本3、版本5 - 确定性UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成； 版本4 - UUID 使用随机性或伪随机性生成。 UUID的实现 浏览器提供了(crypto.</description></item><item><title>简单谈谈JS中的沙箱</title><link>https://chenkai.life/javascript/js-sandbox/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/javascript/js-sandbox/</guid><description>沙箱(sandbox)是一种安全机制， 为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供用后即回收的磁盘及内存空间。
JS 中沙箱的使用场景 前端 JS 中也会有应用到沙箱的时候，毕竟有时候你要获取到的是第三方的 JS 文件或数据？而这数据又是不一定可信的时候，创建沙箱，做好保险工作尤为重要
jsonp：解析服务器所返回的 jsonp 请求时，如果不信任 jsonp 中的数据，可以通过创建沙箱的方式来解析获取数据；（TSW 中处理 jsonp 请求时，创建沙箱来处理和解析数据）； 执行第三方 js：当你有必要执行第三方 js 的时候，而这份 js 文件又不一定可信的时候； 在线代码编辑器：相信大家都有使用过一些在线代码编辑器，而这些代码的执行，基本都会放置在沙箱中，防止对页面本身造成影响；（例如：https://codesandbox.io/s/new） vue 模板中表达式计算：vue 模板中表达式的计算被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不能够在模板表达式中试图访问用户定义的全局变量
总而言之：当你要解析或执行不可信的 JS 的时候，当你要隔离被执行代码的执行环境的时候，当你要对执行代码中可访问对象进行限制的时候，沙箱就派上用场了 JS 沙箱实现 Function Function 构造函数创建一个新的 Function 对象。直接调用此构造函数可用动态创建函数，但会遇到和 eval 类似的的安全问题和(相对较小的)性能问题。然而，与 eval 不同的是，Function 创建的函数只能在全局作用域中运行。
eval eval() 函数会将传入的字符串当做 JavaScript 代码进行执行,eval() 是一个危险的函数， 它使用与调用者相同的权限执行代码。如果你用 eval() 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。更重要的是，第三方代码可以看到某一个 eval() 被调用时的作用域，这也有可能导致一些不同方式的攻击。相似的 Function 就不容易被攻击。
vm vm 模块支持在 V8 虚拟机上下文中编译和运行代码。 vm 模块不是一种安全机制。不要使用它来运行不受信任的代码。
const { Script, createContext } = require(&amp;#34;vm&amp;#34;); /** * * @param {string} code 需要执行的代码, 执行的代码被包括在一个自执行函数中 * @param {object} context 设置执行代码的上下文对象，默认包含 resolve: 用于代码返回值, reject: 用于代码抛出异常 * @param {object} options 可选参数 * @returns 执行代码返回值 */ async function runScript(code, context = {}, options = {}) { return new Promise((resolve, reject) =&amp;gt; { const { timeout = 120 * 1000, breakOnSigint = true } = options; const script = new Script(`(async()=&amp;gt;{${code}})()`); script.</description></item><item><title>面试总结</title><link>https://chenkai.life/hide/mian-shi-zhong-jie/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/hide/mian-shi-zhong-jie/</guid><description>自我介绍 https://www.zhipin.com/web/geek/resume
对公司有什么想要了解的 问答 做过最满意的项目是什么？ 上传、job任务
可以从以下几方面介绍
项目背景 为什么要做这件事情？ 最终达到什么效果？ 你处于什么样的角色，起到了什么方面的作用？ 在项目中遇到什么技术问题？具体是如何解决的？ 如果再做这个项目，你会在哪些方面进行改善？ 最近有了解哪些前沿知识 typescritp Vue3.0 WebAssembly worker_threads graphql pwa js 知识点 string array object funcion 原型 异步
js继承的各种实现以及优缺点 通过prototype指定 Object.setPrototypeOf 用 Object.create实现类继承 ES6的extends javascript 连等赋值问题 var a = {n:1}; var b = a; // 持有a，以回查 a.x = a = {n:2}; alert(a.x);// --&amp;gt; undefined alert(b.x);// --&amp;gt; {n:2} .运算优先于=赋值运算，因此此处赋值可理解为
声明a对象中的x属性，用于赋值，此时b指向a，同时拥有未赋值的x属性 对a对象赋值，此时变量名a改变指向到对象{n:2} 对步骤1中x属性，也即a原指向对象的x属性，也即b指向对象的x属性赋值 array reduse 实现map方法 不用reduse实现：
Array.prototype.map = function (fun) { let mapArr = []; for (let val of this) { mapArr.</description></item><item><title>面试题</title><link>https://chenkai.life/hide/mian-shi/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/hide/mian-shi/</guid><description>反思自己存在以下问题
相关方法还是掌握的不够熟练，不借助编辑器提示难以下手 遇到相关算法题脑子有些混乱，冷静下来想想还是能写出来 一些至少概念了解但并不十分清楚 缺乏面试经验，脑子有些转不过来 平常没有做相关面试题，面试题还是要刷的 还记起来的面试题大概有以下题目:
array reduse 实现map方法 做不出来的原因， 对this还是不够熟悉
不用reduse实现：
Array.prototype.map = function (fun) { let mapArr = []; for (let val of this) { mapArr.push(fun.call(null, val)); } return mapArr; } [1, 2, 3].map((val) =&amp;gt; val); 使用reduse实现：
Array.prototype.map = function (fun) { let mapArr = []; this.reduce((accumulator, currentValue, index) =&amp;gt; { mapArr.push(fun.call(null, this[index])); },null); return mapArr; } koa中间件传参数，允许输入参数限制请求 function name(methods) { return async function(ctx, next){ let startDate = new Date(); if (methods.</description></item><item><title>计算广告-基本概念</title><link>https://chenkai.life/posts/computing-advertising/</link><pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/computing-advertising/</guid><description>广告市场的参与者 Demand 需求方,这里的需求方包括广告主，代表广告主利益的代理商或其他技术形态的采买方，概括来说，就是想要投放广告的一方。
Supply 供给方,这里的供给方可以是媒体，也可以是其他技术形态的变现平台。在移动互联网时代，媒体指一切拥有流量的电视媒体、报纸、Web网站、移动APP、H5页面等等。概括来说就是给想要投放广告的需求方提供广告位的一方。
受众 受众就是我们这群看广告的人啦，之所以说是被动的，因为给我们看什么广告并不是我们决定的，而是由需求方和供给方来决定的。
SSP(supply side platform) 供给方平台, 它是为媒体方服务的，负责和ADX对接。接入SSP的媒体，在广告位有单个流量到来时，可发起广告请求，向ADX询问是否有合适的广告可展现。
DSP(demand side platform) 需求方平台, 它是为广告主服务的，负责和ADX对接。若干广告主将预算、创意、出价、流量要求等提交给DSP，DSP负责具体投放决策。
ADX(ad exchange) 它是为DSP和SSP服务的，起到衔接、匹配的作用。它接收到SSP的请求后，将广告流量信息传递给DSP，询问它们的出价。DSP响应后返回相应的广告创意及出价。
DMP(Data Management Platform) DMP能够为广告投放提供人群标签进行受众精准定向，并通过投放数据建立用户画像，进行人群标签的管理以及再投放。
Advertiser 广告主, 广告主手握预算，他们有展示自己产品的需求，需要优质的广告
Publisher 媒体方, 媒体拥有广告展示资源，他们有将广告位和流量变现的需求
广告市场的收费方式 广告这一商业行为，对于需求方来说，其目的主要有两个：一是吸引用户消费，二是塑造品牌形象；对于供给方来说，那当然是赚钱了。需求方想要在供给方这里放广告，当然是要付钱的。那么本节所介绍的，就是需求方如何向供给方付钱的。
CPM（Cost Per Mille） 千次展示计费 = (消费量/展现量)*1000), 即每展示1000次需求方的广告，需求方需要支付给供给方的钱。假设约定是1000元，那么广告展示5000次的话，需求方需要支付供给方5000元。
它受到越来越多的审查，因为无论消费者是否真正看到它，客户都要为印象付费。例如，在网络上，如果广告出现在浏览器窗口下方并且用户从不向下滚动，则广告商仍需付费。在移动端，同样如此。这很容易受到欺诈，典型情况是欺诈者在同一空间中加载 5、10 或 15 个广告，彼此堆叠。
CPC(Cost per Click) 按点击计费 = 消费量/点击量, 即广告每被受众点击一次，需求方需要支付给供给方的钱。假设约定的是一次3块，如果广告展示了1000次，共被点击20次，那么需求方需要支付给供给方60元。
一些广告客户更喜欢购买 CPC 而不是 CPM，因为他们认为只有在有人对消息足够感兴趣并想要更多信息时才会付费。这很可能是真的。一些 CPC 计划非常有效，但如果公司故意使用机器人或其他技术来驱动不是由真人发起的点击，则存在欺诈的可能性。
CPA(Cost per Action) 按转化付费 = 消费量/转化量 = (CPC*点击量)/(CVR*点击量) = CPC/CVR, 这里的转化形式可以很多，比如我们推送了一个公众号的广告，用户点击并关注公众号算是一种转化，推送了一个商品广告，用户购买或者加入购物车算是一种转化。假设需求方通过广告展示获得了200个用户的关注，每一个关注支付给供给方5元，那么供给方的收入共1000元。
CPS(Cost per Sale) 按销售额付费, CPS是CPA支付模式的一个具体案例，主要按照需求方的收入来决定的。假设需求方通过广告展示获得了1000元的销售额，按照20%的比例支付给供给方，那么供给方的收入便是200元。</description></item><item><title>Base64原理及实现</title><link>https://chenkai.life/posts/base64/</link><pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/base64/</guid><description>base64 Base64是用64个字符来表示数据的方法。Base64要求把每三个8Bit的字节转换为四个6Bit的字节，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。如果要转码数据字节不是3的倍数，最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。 转换后，我们每个字节范围为[00000000-00111111],所以我们可以用一个64码表来得到我们想要的字符串（也就是最终的Base64编码）标准的Base64用[A-Z,a-z,0-9,+,/]64个字符编码。
编码 深入了解base64前，我们需要先了解编码。编码是信息从一种形式或格式转换为另一种形式的过程。计算机中，所有的数据在存储和运算时都使用二进制示，n位二进制组合成2的n次方个不同的信息，给每个信息规定一个具体码组，这种过程叫编码。而具体用哪些二进制数字表示哪个符号，每个人都可以约定自己的一套编码。
如常用的ASCII是由美国国家标准学会制定的一种单字节字符编码，标准ASCII码使用7位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0到9、标点符号。在有的语言中128个符号是不够的，有些编码方案利用字节中闲置的最高位编入新的符号，有的利用两个（GBK等）或更多字节（utf-32等）表示一个符号（汉字）
Base64编码 base64编码过程：
ascii码s133对应的编码115 49 51 51 在内存2进制表示： 01110011 00110001 00110011 00110011 每三组分为6Bit四组011100 110011 000100 110011 001100 110000 000000 000000 高位补0得到 00011100 00110011 00000100 00110011 00001100 00110000 00000000 00000000 对应十进制 28 51 4 51 12 48 0 0 查对照表 生成base64码czEzMw== base64解码过程：
base64编码过程逆向即为解码
javascript代码实现 Base64 = { _table: [ &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;F&amp;#39;, &amp;#39;G&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;K&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;N&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;P&amp;#39;, &amp;#39;Q&amp;#39;, &amp;#39;R&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;, &amp;#39;g&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;j&amp;#39;, &amp;#39;k&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;q&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;v&amp;#39;, &amp;#39;w&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;z&amp;#39;, &amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;+&amp;#39;, &amp;#39;/&amp;#39; ], _getReg: function () { return RegExp(`^[${this.</description></item></channel></rss>