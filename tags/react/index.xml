<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React on CK's Blog</title><link>https://chenkai.life/tags/react/</link><description>Recent content in React on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 25 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://chenkai.life/tags/react/index.xml" rel="self" type="application/rss+xml"/><item><title>React API &amp; 组件</title><link>https://chenkai.life/react/react-apicompoent/</link><pubDate>Sun, 25 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-apicompoent/</guid><description>API react 包还导出了一些其他的 API，这些 API 对于创建组件非常有用
createContext 可以创建一个 context，你可以将其提供给子组件，通常会与 useContext 一起配合使用。
forwardRef 允许组件将 DOM 节点作为 ref 暴露给父组件。
lazy 允许你延迟加载组件，直到该组件需要第一次被渲染。
lazy(load) 参数
load: 一个返回 Promise 或另一个 thenable（具有 then 方法的类 Promise 对象）的函数。React 不会在你尝试首次渲染返回的组件之前调用 load 函数。在 React 首次调用 load 后，它将等待其解析，然后将解析值的 .default 渲染为 React 组件。返回的 Promise 和 Promise 的解析值都将被缓存，因此 React 不会多次调用 load 函数。如果 Promise 被拒绝，则 React 将抛出拒绝原因给最近的错误边界处理。 返回值
lazy 返回一个 React 组件，你可以在 fiber 树中渲染。当懒加载组件的代码仍在加载时，尝试渲染它将会处于 暂停 状态。使用 可以在其加载时显示一个正在加载的提示。 import { lazy } from &amp;#39;react&amp;#39;; const MarkdownPreview = lazy(() =&amp;gt; import(&amp;#39;.</description></item><item><title>React Hook Context</title><link>https://chenkai.life/react/react-hooks-context/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-context/</guid><description>useContext 使用 Context 深层传递参数
useContext(SomeContext) 参数
SomeContext：用 createContext 创建的 context。context 本身不包含信息，它只代表你可以提供或从组件中读取的信息类型。 返回值
useContext 为调用组件返回 context 的值。它被确定为传递给树中调用组件上方最近的 SomeContext.Provider 的 value。如果没有这样的 provider，那么返回值将会是为创建该 context 传递给 createContext 的 defaultValue。返回的值始终是最新的。如果 context 发生变化，React 会自动重新渲染读取 context 的组件。 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &amp;lt;MyContext.Provider&amp;gt; 的 value prop 决定。调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 通过使用 memoization 来优化。
当组件上层最近的 &amp;lt;MyContext.Provider&amp;gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。
基础用法 // ThemeContext.js import { useState, createContext, useContext } from &amp;#34;react&amp;#34;; const themes = { light: { color: &amp;#34;#000000&amp;#34;, background: &amp;#34;#eeeeee&amp;#34; }, dark: { color: &amp;#34;#ffffff&amp;#34;, background: &amp;#34;#222222&amp;#34; } }; // 设置Context 默认值 export const ThemeContext = createContext(themes.</description></item><item><title>React Hook Effect</title><link>https://chenkai.life/react/react-hooks-effect/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-effect/</guid><description>useEffect 每当你的组件渲染时，React 将更新屏幕，然后运行 useEffect 中的代码(屏幕更新渲染之后)
该 Hook 接收一个包含命令式、且可能有副作用代码的函数。在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。使用 useEffect 完成副作用操作。
通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。同时你也可以使用多个effect hook，React 将按照 effect 声明的顺序依次调用组件中的每一个 effect。
参考 useEffect(setup, dependencies?) 参数
setup：处理 Effect 的函数。setup 函数选择性返回一个 清理（cleanup） 函数。当组件被添加到 DOM 的时候，React 将运行 setup 函数。在每次依赖项变更重新渲染后，React 将首先使用旧值运行 cleanup 函数（如果你提供了该函数），然后使用新值运行 setup 函数。在组件从 DOM 中移除后，React 将最后一次运行 cleanup 函数。 dependencies：setup 代码中引用的所有响应式值的列表。响应式值包括 props、state 以及所有直接在组件内部声明的变量和函数。如果你的代码检查工具 配置了 React，那么它将验证是否每个响应式值都被正确地指定为一个依赖项。依赖项列表的元素数量必须是固定的，并且必须像 [dep1, dep2, dep3] 这样内联编写。React 将使用 Object.is 来比较每个依赖项和它先前的值。如果省略此参数，则在每次重新渲染组件之后，将重新运行 Effect 函数。如果传递空数组则仅在 初始渲染后 运行(开发环境下除外)。 返回值 undefined</description></item><item><title>React Hook Ref</title><link>https://chenkai.life/react/react-hooks-ref/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-ref/</guid><description>useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue。返回的 ref 对象在组件的整个生命周期内保持不变, ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与state不同，更新 ref 不会重新渲染组件。
参考 const ref = useRef(initialValue) 参数
initialValue: ref 对象的 current 属性的初始值。可以是任意类型的值。这个参数在首次渲染后被忽略 返回值
ref: 返回一个只有一个current属性的对象, 初始值为传递的 initialValue。之后可以将其设置为其他值。如果将 ref 对象作为一个 JSX 节点的 ref 属性传递给 React，React 将为它设置 current 属性。 在后续的渲染中，useRef 将返回同一个对象。 注意事项
不要在渲染期间写入或者读取 ref.current 改变 ref.current 属性时，React 不会重新渲染组件 除了 初始化 外不要在渲染期间写入或者读取 ref.current 在严格模式下，React 将会 调用两次组件方法 通过 ref 操作 DOM 一个常见的用例便是命令式地访问子组件
function TextInputWithFocusButton() { const inputRef = useRef(null); const onButtonClick = () =&amp;gt; { // 当 React 创建 DOM 节点并将其渲染到屏幕时，React 将会把 DOM 节点设置为 ref 对象的 current 属性 // 当节点从屏幕上移除时，React 将把 current 属性设置回 null // `current` 指向已挂载到 DOM 上的文本输入元素 inputRef.</description></item><item><title>React Hook State</title><link>https://chenkai.life/react/react-hooks-state/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-state/</guid><description>useState 在函数组件中存储内部 state
const [state, setState] = useState(initialState); 参数:
initialState: state初始值, 如果传递函数作为 initialState，则它将被视为初始化函数。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。 返回值:
state: 当前的 state setState: 更新 state 的方法, 它接收一个新的 state 值并将组件的一次重新渲染加入队列。如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过 基础用法 这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加
function Counter(props) { const [count, setCount] = useState(props.initialCount) return ( &amp;lt;button type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; setCount(count + 1)}&amp;gt; count is: {count} &amp;lt;/button&amp;gt; ); } Counter.defaultProps = { initialCount: 10, } 值得注意的是，类似class 组件中的setState,在我们执行setCount时count的值不是立即更新的，而是在下一个重渲染时才会更新，后调用的 setCount() 将覆盖同一周期内先调用 setCount 的值。
// 所以如在同一周期内多次执行setCount setCount(count + 1); setCount(count + 2); setCount(count + 1); // 这相当于setCount(count + 1); 因此count数仅增加一,解决办法可以参考函数式更新</description></item><item><title>React Hook 其他</title><link>https://chenkai.life/react/react-hooks-%E5%85%B6%E4%BB%96/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-%E5%85%B6%E4%BB%96/</guid><description>useDebugValue useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。
useDebugValue(value, format?) 参数
value：在 React 开发工具中显示的值。可以是任何类型。 format：它接受一个格式化函数。当组件被检查时，React 开发工具将用 value 作为参数来调用格式化函数，然后显示返回的格式化值（可以是任何类型）。如果不指定格式化函数，则会显示 value。 返回值
useDebugValue 没有返回值。 基础用法 function testHook(initialCount) { const [count, setCount] = useState(initialCount) // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. &amp;#34;testHook: 好好学习&amp;#34; useDebugValue(&amp;#39;好好学习&amp;#39;); return [count, setCount]; } function Counter(props) { const [count, setCount] = testHook(props.initialCount); return ( &amp;lt;button type=&amp;#34;button&amp;#34; onClick={() =&amp;gt; setCount(count + 1)}&amp;gt; count is: {count} &amp;lt;/button&amp;gt; ); } 延迟格式化 debug 值 在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。</description></item><item><title>React Hook 性能</title><link>https://chenkai.life/react/react-hooks-%E6%80%A7%E8%83%BD/</link><pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-hooks-%E6%80%A7%E8%83%BD/</guid><description>useMemo 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。
参考 const cachedValue = useMemo(calculateValue, dependencies?) 参数
calculateValue：要缓存计算值的函数。它应该是一个没有任何参数的纯函数，并且可以返回任意类型。React 将会在首次渲染时调用该函数 dependencies: 如果 dependencies 没有发生变化，React 将直接返回相同值。否则，将会再次调用 calculateValue 并返回最新结果，然后缓存该结果以便下次重复使用 返回值
不带参数调用 calculateValue 的结果, 如果依赖项没有发生改变，它将返回上次缓存的值 注意事项 传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。 **你只可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。**将来，React 可能会选择“遗忘”以前的一些 memoized 值并在下次渲染时重新计算它们 你不能在循环语句或条件语句中调用它 在严格模式下，为了 帮你发现意外的错误，React 将会 调用你的计算函数两次 //当a&amp;amp;b不变时返回memoizedValue（引用不变） const memoizedValue = useMemo(() =&amp;gt; computeExpensiveValue(a, b), [a, b]); 基础用法 function CountButton() { let [ label, setLabel ] = useState(&amp;#39;&amp;#39;); let [ count, setCount ] = useState(0); // 如果依赖项label不变memoizedValue不会重新计算 const memoizedValue = useMemo(()=&amp;gt;{ return label.</description></item><item><title>React 基础</title><link>https://chenkai.life/react/react-%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/react/react-%E5%9F%BA%E7%A1%80/</guid><description>Hooks 基础 在React中，如果在编写函数组件并需要向其添加一些 state，以前的做法是必须将其它转化为 class。通过一个实例化的class，保存组件的state等状态，对于每一次更新只需要调用render方法就可以。但是 Class组件在变得复杂之后会变得难以维护。
在function组件中，没有一个状态去保存这些信息，每一次函数上下文执行，所有变量，常量都重新声明，执行完毕，再被垃圾机制回收。为了保存一些状态,执行一些副作用钩子,React 16.8新增了React Hooks，去帮助记录组件的状态，处理一些额外的副作用。通过React Hook 可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。你可以在现有的函数组件中使用 Hook，所以通常来说hook使得在组件之间复用状态逻辑变得方便、更容易实现代码的关注点分离。
Hooks的原理 React 保持对当前渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。
每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 useState() 调用会得到各自独立的本地 state 的原因。
// 每次执行一个`hooks`函数，都产生一个`hook`对象，里面保存了当前`hook`信息, // 然后将每个`hooks`以链表形式串联起来，并赋值给`workInProgress`的`memoizedState`。 // 也就证实了上述所说的，函数组件用`memoizedState`存放`hooks`链表。 function mountWorkInProgressHook(): Hook { const hook: Hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // This is the first hook in the list currentlyRenderingFiber.</description></item></channel></rss>