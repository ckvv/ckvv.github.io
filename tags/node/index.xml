<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>node on CK's Blog</title><link>https://chenkai.life/tags/node/</link><description>Recent content in node on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 11 Aug 2021 11:12:19 +0800</lastBuildDate><atom:link href="https://chenkai.life/tags/node/index.xml" rel="self" type="application/rss+xml"/><item><title>node复用原始接口下载表格</title><link>https://chenkai.life/nodejs/node_download_biaoge_sheji/</link><pubDate>Wed, 11 Aug 2021 11:12:19 +0800</pubDate><guid>https://chenkai.life/nodejs/node_download_biaoge_sheji/</guid><description>我们在做后台开发时可能有很多接口的数据需要下载下来,如果从头开发无疑会有很多重复代码如参数校验、权限验证等，接下来我谈谈我是如何利用现有的node接口下载表格
json数组转表格 一般我们的接口返回的是json数组,我们很容易想到只需要把返回数据的json转为表格下载就可以了其他逻辑都是一样的，node有很多现成的库可以处理如xlsx
function frows2XlsxBufferile(formatData) { const ws = xlsx.utils.json_to_sheet(formatData); const wb = xlsx.utils.book_new(); xlsx.utils.book_append_sheet(wb, ws, &amp;#39;SheetJS&amp;#39;); return xlsx.write(wb, { type: &amp;#39;buffer&amp;#39;, bookType: &amp;#39;xlsx&amp;#39; }); } 在ctx上下文添加下载文件的方法 默认情况下返回的是文本数据这里需要处理,我这里需要在header中声明返回的内容是一个需要下载的文件
function file(name, data) { // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition // 说明浏览器应该将内容下载到本地；filename 的值预填为下载后的文件名 this.response.set(&amp;#39;Content-disposition&amp;#39;, `attachment;filename=&amp;#34;${name}&amp;#34;`); // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type // 说明返回的是一个二进制流数据 this.response.set(&amp;#39;Content-Type&amp;#39;, &amp;#39;application/octet-stream&amp;#39;); return this.response.body = data; } 返回表格 我们将上面封装下，方便调用,
async download() { const { ctx } = this; const result = await this.</description></item><item><title>node调用系统命令</title><link>https://chenkai.life/nodejs/node_run_command/</link><pubDate>Thu, 15 Jul 2021 11:28:21 +0800</pubDate><guid>https://chenkai.life/nodejs/node_run_command/</guid><description>const exec = require(&amp;#39;util&amp;#39;).promisify(require(&amp;#39;child_process&amp;#39;).exec); async function run(command) { const { stdout, stderr } = await exec(command); if (stderr) { return { code:1, data:stderr }; } if (stdout) { return { code:0, data:stdout }; } } (async ()=&amp;gt;{ let result = await run(&amp;#39;cd ../ &amp;amp;&amp;amp; ls&amp;#39;); let result2 = await run(&amp;#39;wc -l index.js&amp;#39;); console.log(result) console.log(result2) })()</description></item><item><title>node http请求解析</title><link>https://chenkai.life/nodejs/node-http_analys/</link><pubDate>Sat, 10 Jul 2021 11:03:22 +0800</pubDate><guid>https://chenkai.life/nodejs/node-http_analys/</guid><description>本指南的宗旨将让你对 HTTP 传输处理有一个清晰完整的了解。在不考虑特定编程语言及开发环境下，我们假设你已经知道在一般情况下 HTTP 是如何进行工作的。我们同样假定你熟悉 Node.js 的 EventEmitters 和 Streams。当然，如果你确实不了解它们，我们强烈建议你把以上列出的内容快速而完整地阅读一遍。
创建一个后台服务 任何网络服务应用程序总是要先创建一个服务对象。这在 Node.js 中通常通过 createServer 方法。
const http = require(&amp;#39;http&amp;#39;); const server = http.createServer((request, response) =&amp;gt; { // magic happens here! }); 每当有 HTTP 请求到达服务器时，createServer 中传入的函数就被自动执行。所以这个函数也被称为是请求处理函数。实际上，由 createServer 构造函数返回的 Server 对象是一个 EventEmitter，我们在这里仅是对创建 server 和对它添加监听事件进行了简化处理。
const server = http.createServer(); server.on(&amp;#39;request&amp;#39;, (request, response) =&amp;gt; { // the same kind of magic happens here! }); 当一个 HTTP 到达服务端，node 调用 request 处理程序，并产生一些唾手可得的对象用以处理传输，这些对象就是 request 和 response。我们马上会讲到。</description></item><item><title>node中的多进程</title><link>https://chenkai.life/nodejs/node_child_process/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://chenkai.life/nodejs/node_child_process/</guid><description>javascript是单线程的并且只在一个进程中跑，
child_process child_process 模块提供了衍生子进程的能力，此功能主要由 child_process.spawn() 函数提供：
const { spawn } = require(&amp;#39;child_process&amp;#39;); const ls = spawn(&amp;#39;ls&amp;#39;, [&amp;#39;-lh&amp;#39;, &amp;#39;/usr&amp;#39;]); ls.stdout.on(&amp;#39;data&amp;#39;, (data) =&amp;gt; { console.log(`stdout: ${data}`); }); ls.stderr.on(&amp;#39;data&amp;#39;, (data) =&amp;gt; { console.error(`stderr: ${data}`); }); ls.on(&amp;#39;close&amp;#39;, (code) =&amp;gt; { console.log(`子进程退出，使用退出码 ${code}`); }); child_process.spawn() 方法异步地衍生子进程，且不阻塞 Node.js 事件循环。 child_process.spawnSync() 函数则以同步的方式提供了等效的功能，但会阻塞事件循环直到衍生的进程退出或终止。为方便起见， child_process 模块提供了 child_process.spawn() 和 child_process.spawnSync() 的一些同步和异步的替代方法。 这些替代方法中的每一个都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。
[child_process.spawn()]: 方法使用给定的 command 衍生一个新进程，并带上 args 中的命令行参数。 如果省略 args，则其默认为一个空数组。 [child_process.exec()]: 衍生一个 shell 然后在该 shell 中执行 command，并缓冲任何产生的输出。 [child_process.</description></item><item><title>批量运行node程序</title><link>https://chenkai.life/nodejs/run_multy_node_on_shell/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://chenkai.life/nodejs/run_multy_node_on_shell/</guid><description>每次开机都需要手动执行一遍所有node程序,很是麻烦，于是找了一个方法可以用脚本的形式批量打开终端tab页，并执行node程序
ttab ttab是一种macOS（OS X） CLI，用于以编程方式在标准终端应用程序中打开新的终端选项卡/窗口Terminal，具有执行命令和/或特定标题和特定显示设置。
npm install ttab ttab help ttab --help Opens a new terminal tab or window in OS X's Terminal application or iTerm2. ttab [-w] [-s &amp;lt;settings&amp;gt;] [-t &amp;lt;title&amp;gt;] [-q] [-g|-G] [-d &amp;lt;dir&amp;gt;] [&amp;lt;cmd&amp;gt; ...] -w open new tab in new terminal window -s &amp;lt;settings&amp;gt; assign a settings set (profile) -t &amp;lt;title&amp;gt; specify title for new tab -q clear the new tab's screen -g create tab in background (don't activate Terminal/iTerm) -G create tab in background and don't activate new tab -d &amp;lt;dir&amp;gt; specify working directory; -d '' disables inheriting the current dir.</description></item><item><title>检测node程序自动重启</title><link>https://chenkai.life/nodejs/node_auto_reatart_when_change_nodemon/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://chenkai.life/nodejs/node_auto_reatart_when_change_nodemon/</guid><description>nodemon是一种工具，通过在检测到目录中的文件更改时自动重新启动节点应用程序来帮助开发基于node.js的应用程序
nodemon将全局安装到您的系统路径 npm install -g nodemon nodemon包装您的应用程序，因此您可以传递通常传递给应用程序的所有参数 nodemon [your node app] 查看帮助 nodemon -h 配置文件 nodemon支持本地和全局配置文件。这些通常是命名的nodemon.json,可以位于当前工作目录或主目录中。可以使用该&amp;ndash;config 选项指定备用本地配置文件。
{ &amp;quot;verbose&amp;quot;: true, &amp;quot;ignore&amp;quot;: [&amp;quot;*.test.js&amp;quot;, &amp;quot;fixtures/*&amp;quot;], &amp;quot;execMap&amp;quot;: { &amp;quot;rb&amp;quot;: &amp;quot;ruby&amp;quot;, &amp;quot;pde&amp;quot;: &amp;quot;processing --sketch={{pwd}} --run&amp;quot; } } nodemon支持使用package.json配置,以与配置文件相同的格式指定配置，但nodemonConfig在package.json文件中
{ &amp;quot;name&amp;quot;: &amp;quot;nodemon&amp;quot;, &amp;quot;homepage&amp;quot;: &amp;quot;http://nodemon.io&amp;quot;, &amp;quot;...&amp;quot;: &amp;quot;... other standard package.json values&amp;quot;, &amp;quot;nodemonConfig&amp;quot;: { &amp;quot;ignore&amp;quot;: [&amp;quot;test/*&amp;quot;, &amp;quot;docs/*&amp;quot;], &amp;quot;delay&amp;quot;: &amp;quot;2500&amp;quot; } } 忽略指定文件 在某些情况下，您将要忽略某些特定文件，目录或文件模式，以防止nodemon过早地重新启动您的应用程序。在默认情况下，nodemon会忽略.</description></item><item><title>eggjs</title><link>https://chenkai.life/nodejs/eggjs/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/nodejs/eggjs/</guid><description>egg初始化设置 const dir = path.join(app.baseDir, '/app/model/'); app.loader.loadToContext(dir, 'model'); //只执行一次 app.once('server', async (server) =&amp;gt; { //设置一个空的上下文 const ctx = app.createAnonymousContext(); //获取设置 var settings = await ctx.model.setting.getAll(); });</description></item><item><title>jsonwebtoken</title><link>https://chenkai.life/nodejs/jsonwebtoken/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/nodejs/jsonwebtoken/</guid><description>什么是JSON Web Token？ JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑且独立的方式，用于在各方之间用SON对象安全地传输信息。此信息可以通过数字签名进行验证和信任。 JWT可以使用加密算法（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名。
什么时候应该使用JSON Web令牌 以下是JSON Web令牌有用的一些场景：
授权：这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，允许用户访问该令牌允许的路由，服务和资源。 Single Sign On是一种现在广泛使用JWT的功能，因为它的开销很小，并且能够在不同的域中轻松使用。
信息交换：JSON Web令牌是在各方之间安全传输信息的好方法。因为JWT可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。
JSON Web令牌结构 JSON Web Tokens由.分隔的三个部分组成，它们是：
头 有效载荷 签名 因此，JWT通常如xxxxx.yyyyy.zzzzz所示. 头 标头通常由两部分组成：令牌的类型，即JWT，以及正在使用的签名算法，例如HMAC SHA256或RSA。
{ &amp;quot;alg&amp;quot;: &amp;quot;HS256&amp;quot;, &amp;quot;typ&amp;quot;: &amp;quot;JWT&amp;quot; } 然后，这个JSON被编码为Base64Url，形成JWT的第一部分。
有效载荷 令牌的第二部分是有效负载，其中包含声明。声明是关于实体（通常是用户）和其他数据的声明。有三种类型:registered、public、private claims.
registered：这些是一组预定义声明，不是强制性的，但建议使用，以提供一组有用的，可互操作的声明。其中一些是： iss（发行人）， exp（到期时间），sub（主题）， aud（观众）等。 public：这些可以由使用JWT的人随意定义。但为避免冲突，应在 IANA JSON Web令牌注册表中定义它们，或者将 其定义为包含防冲突命名空间的URI。 private claims： 这是创建共享使用它们同意并既不是当事人之间的信息自定义声明注册或公众的权利要求 然后，有效负载经过Base64Url编码，形成JSON Web令牌的第二部分。</description></item><item><title>node Promise 转换</title><link>https://chenkai.life/nodejs/node_promise/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/nodejs/node_promise/</guid><description>如果你曾经使用Javascript，你必须有经验的回调。Javascript以其内置的异步哲学而闻名。从标准内置模块到其他框架和库，回调无处不在。这就是在Javascript中完成异步编程。但是回调有一个黑暗的一面。这叫Callback Hells。
回调地狱的解决方案是Promises。而不是通过回调同步返回值或传递结果，我们可以返回一个Promise，我们将来会返回一些值或错误。 有许多像好的库如Bluebird和Q可以用来处理Promise。但是内置的模块和很多其他库不能使用Promises。这些库能够将传统的回调方法转换为Promise，在Node v8中我们现在可以使用util.promisify来处理回调方法。根据Node.js的文档： util.promisify(original)
original Returns: const util = require(&amp;#39;util&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); const stat = util.promisify(fs.stat); stat(&amp;#39;.&amp;#39;).then((stats) =&amp;gt; { // Do something with `stats` }).catch((error) =&amp;gt; { // Handle the error. }); 或者 const util = require(&amp;#39;util&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); const stat = util.promisify(fs.stat); async function callStat() { const stats = await stat(&amp;#39;.&amp;#39;); console.log(`This directory is owned by ${stats.uid}`); } 看传统的例子：</description></item><item><title>node事件循环</title><link>https://chenkai.life/nodejs/node_event_loop/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/nodejs/node_event_loop/</guid><description>事件循环 事件循环是 Node.js 处理非阻塞 I/O 操作的机制，事件循环使Node.js可以通过将操作转移到系统内核中来执行非阻塞I/O操作，由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会告诉Node.js，将适当的回调添加到轮询队列中以最终执行。
事件轮询机制解析 面的图表展示了事件循环操作顺序的简化概览,每个框被称为事件循环机制的一个阶段。每个阶段都有一个FIFO队列来执行回调。当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。
┌───────────────────────────┐ ┌─&amp;gt;│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │&amp;lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ 阶段概述</description></item><item><title>node程序放入docker</title><link>https://chenkai.life/nodejs/node_docker/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/nodejs/node_docker/</guid><description>准备demo程序 index.js &amp;#39;use strict&amp;#39;; const express = require(&amp;#39;express&amp;#39;); // Constants const PORT = 6677; const HOST = &amp;#39;0.0.0.0&amp;#39;; // App const app = express(); app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; { res.send(&amp;#39;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&amp;#39;); }); app.listen(PORT, HOST); console.log(`Running on http://${HOST}:${PORT}`); 根目录新建Dockerfile文件 ## 定义我们需要从哪个镜像进行构建 FROM node:8 ## 在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ &amp;quot;node&amp;quot;, &amp;quot;index.js&amp;quot; ] .</description></item><item><title>pg中为存储过程添加进度</title><link>https://chenkai.life/database/pg_how_to_add_process_in_function/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/database/pg_how_to_add_process_in_function/</guid><description>有时我们可能需要知道长时间调用存储过程的进度。
通过外部表 首先我想到通过修改一张外部表更新存储过程的进度，后来发现这样是不行的。存储过程执行中对数据库的改变在外部是获取不到的，它只有在执行完毕提交后，我们才能获取结果，所以这种方式我们获取到的进度可能全都是100%。
raise RAISE语句可以在sql运行过程中向程序抛出消息或错误，文档
用法如下所示： sql
RAISE INFO &amp;#39;model_progress:%&amp;#39;,json_build_object(&amp;#39;job_uid&amp;#39;,job_uid,&amp;#39;job_progress&amp;#39;,progress); 程序中我们还可以获取到存储过程抛出的消息：如node实现所示
const pool = new Pg.Pool(Config.db); pool.on(&amp;#39;connect&amp;#39;, (cl) =&amp;gt; { cl.on(&amp;#39;notice&amp;#39;, (msg)=&amp;gt; { //获取sql抛出的信息 DbNoticeHandler.handle(msg); }); });</description></item><item><title>流读取json</title><link>https://chenkai.life/nodejs/stream_read_geojson/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/nodejs/stream_read_geojson/</guid><description>流读取json需要用到两个库JSONStream和es
JSONStream 流JSON.parse
JSONStream.parse(&amp;quot;JSONPath表达式&amp;quot;) JSONPath表达式 JSONPath表达式始终引用JSON结构，其方式与XPath表达式与XML文档结合使用的方式相同。由于JSON结构通常是匿名的，并且不一定具有“根成员对象”，因此JSONPath假定$分配给外部对象的抽象名称 例子：
$.store.book[0].title $['store']['book'][0]['title'] XPath和JSONPath语法
XPath JSONPath Description / $ the root object/element . @ the current object/element / . or [] child operator .. n/a parent operator // .. recursive descent. JSONPath borrows this syntax from E4X. * * wildcard. All objects/elements regardless their names.</description></item><item><title>node服务端渲染</title><link>https://chenkai.life/nodejs/node-service-rendering/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-service-rendering/</guid><description>服务端渲染是指，浏览器向服务器发出请求页面，服务端将准备好的模板和数据组装成完整的HTML返回给浏览器展示。 前后的分离后，浏览器加载完页面后还需要再次向服务器发起请求数据，如果我们事先将需要请求到数据放入到页面就无需加载页面后再次向服务器发起请求，减少初始初始页面加载时间 node的服务端渲染库有很多。handlebars, ejs, ejs, hbs, pug, velocityjs, Nunjucks, twig, dot,templayed
直接使用Nunjucks Nunjucks文档
// render.js const Router = require(&amp;#39;koa-router&amp;#39;) const router = new Router() const nunjucks = require(&amp;#39;nunjucks&amp;#39;); const path = require(&amp;#39;path&amp;#39;) let env = nunjucks.configure(path.join(__dirname, &amp;#39;../public&amp;#39;),{ // noCache: true, }); router.get(&amp;#39;/&amp;#39;, async (ctx, next) =&amp;gt; { ctx.body = env.render(&amp;#39;index.html&amp;#39;, { title: &amp;#39;title&amp;#39;, user: { name: &amp;#39;test&amp;#39;, age: 18 } }); }); module.exports = router app.use(render.routes(), render.allowedMethods()); 使用koa-views + Nunjucks 等 const views = require(&amp;#39;koa-views&amp;#39;) const path = require(&amp;#39;path&amp;#39;) // Must be used before any router is used app.</description></item></channel></rss>