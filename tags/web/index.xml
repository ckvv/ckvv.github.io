<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on CK's Blog</title><link>https://chenkai.life/tags/web/</link><description>Recent content in Web on CK's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 05 Jul 2024 16:18:04 +0800</lastBuildDate><atom:link href="https://chenkai.life/tags/web/index.xml" rel="self" type="application/rss+xml"/><item><title>范围请求(Http Range Request)</title><link>https://chenkai.life/web/%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82/</guid><description>Http Range Request允许服务器仅将 HTTP 消息的一部分发送回客户端。范围请求对于支持随机访问的媒体播放器、知道它们只需要大文件的一部分的数据工具以及允许用户暂停和恢复下载的下载管理器等客户端非常有用。
下面是一个实现例子:
import { createServer } from &amp;#39;node:http&amp;#39;; import { createReadStream } from &amp;#39;node:fs&amp;#39;; import { stat } from &amp;#39;node:fs/promises&amp;#39;; const server = createServer(async (req, res) =&amp;gt; { const filePath = &amp;#39;test.mp4&amp;#39;; const range = req.headers.range; const fileSize = (await stat(filePath)).size; res.statusCode = 200; res.setHeader(&amp;#39;Content-Type&amp;#39;, &amp;#39;video/mp4&amp;#39;); if (range) { const ranges = range ? range.replace(&amp;#39;bytes=&amp;#39;, &amp;#39;&amp;#39;).split(&amp;#39;-&amp;#39;) : [&amp;#39;0&amp;#39;, `${fileSize - 1}`]; const start = Number.parseInt(ranges[0]) || 0; const end = Number.</description></item><item><title>DOM中的event</title><link>https://chenkai.life/web/dom-event/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/dom-event/</guid><description>event Event 接口表示在 DOM 中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由 API 生成（例如指示动画已经完成运行的事件，视频已被暂停等等。事件通常由外部源触发，同样也会以编程方式触发，例如执行一个 element 的一个 HTMLElement.click( ) 方法，或通过定义事件，然后使用 EventTarget.dispatchEvent() 将其派发到一个指定的目标。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。 事件处理函数可以附加在各种对象上，包括 DOM 元素,window,document 对象. 等
有三种方式可以为 DOM 元素注册事件处理函数
EventTarget.addEventListener // Assuming myButton is a button element myButton.addEventListener( &amp;#34;click&amp;#34;, function () { alert(&amp;#34;Hello world&amp;#34;); }, false ); HTML 属性 &amp;lt;button onclick=&amp;#34;alert(&amp;#39;Hello world!&amp;#39;)&amp;#34;&amp;gt;&amp;lt;/button&amp;gt; DOM 元素属性 该函数在定义时，可以传入一个 event 形式的参数。 在 HTML 规范中，其返回值会以一种特殊的方式被处理。
// Assuming myButton is a button element myButton.onclick = function(event){alert(&amp;#39;Hello world&amp;#39;);}; 创建自定义事件 可以使用事件构造函数创建事件
var event = new Event(&amp;#34;build&amp;#34;); let eventEle = document.</description></item><item><title>Vue样式dev和build下不一致</title><link>https://chenkai.life/vue/vue-page-style-dev-build-different/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/vue/vue-page-style-dev-build-different/</guid><description>一次更新镜像后发现 vue 项目页面混乱，在开发模式模式下，写的样式有效，打包后无效
一、多个相同样式文件同时存在项目中 现象：修改组件时，在项目中复制了一个组件重命名后进行修改，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：在本地试图修改总是不见效果，在控制台查看样式仍是之前的样式，把其中一处样式在所有相关组件中修改，打包上传后样式生效，这说明是旧的样式在打包时覆盖了新的样式。将旧组件删除后解决上述问题。 原因猜测：因为相同组件包含不同样式时，无法判断哪份样式时在后面渲染，如果旧样式刚好打包后在后面渲染，则会覆盖掉新写的样式。在本地执行时，因为样式没有打包，访问页面时渲染的都是组件自身样式，所以不会出现上述问题。
二、全局(main.js)引用样式 现象：在全局引入了 Element UI 样式，在 header 组件中修改部分样式，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：因为在项目中段发现该问题，以为是后续的样式造成的影响(虽然我也认为可能性极小)，删除新写的组件，没有效果。运行一段时间之前的代码，项目正常运行，这迫使我回想中间这段时间对项目做了什么？除了新写了一些组件，还将一些配置信息从 index.js 中转移到了 main.js 中，测试发现果然是这里出现了问题。配置中同时出现了 Element UI 样式文件引用，还有 router 的引用，将 yang 样式引用放在 router 引用后解决问题。 原因猜测：不正常的样式显示的还是组件原始的样式，由此猜测 router 加载时会加载组件样式，将样式文件在 router 后引用会将 router 加载时渲染的样式覆盖掉，所以建议将 router 的引用放在最后面。在每个组件的样式中记得添加 ‘scoped’.
import &amp;#34;element-ui/lib/theme-chalk/index.css&amp;#34;; //element样式文件 import App from &amp;#34;./App&amp;#34;; 如果相反，那么 element-ui 的样式会覆盖自定义的样式，所以会出现你修改的样式不生效问题！！</description></item><item><title>处理浏览器中的字体常见问题</title><link>https://chenkai.life/web/handling-fonts-in-the-web/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/handling-fonts-in-the-web/</guid><description>当页面中的标题字数是不定的，并且需要适应各种机型屏幕宽度，可能会遇到下面的需求,
字体末尾如何显示省略号 如果显示区域很小，我们可以只设置为单行显示，对于单行文本末尾显示省略号很简单
.wrapper { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } 但是如果是显示区域很大,我们需要设置多行的最后一行显示省略号，对于多行文本，常用的方法如下
移动端兼容较好，适用于 webkit 内核浏览器, 另外对于超出部分的字体仍会显示出来，如下图所示
hello hello hello hello hello hello hello hello 所以我们一般需要搭配固定高度及overflow: hidden;, line-height或者font-size使用
hello hello hello hello hello hello hello hello .wrapper { display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; } 解决多行文字时最后一排文字可能超出边框显示不全问题 对于多行文字，最后一排文字可能超出边框显示不全的情况，对于这种情况我们需要设置外部容器高度为字体高度的整数倍如对于一个高6em的容器,我们可以设置他的line-height为3em, 或者我们设置他的font-size为 2.5em,并且把line-height设置为1.2,
如何文字大小自适应容器 动态修改字体大小 根据不同的字体长度, 设置不同的字体大小； 或者逐渐修改初始字体大小，直到字体容器宽度和高度小于外层包裹的容器宽, 但是由于字体大小有最小值，这种办法对太对的文本也无能为力
zoom,transform 缩放字体容器 我们可以通过外层容器宽高和字体容器宽高计算出需要缩放的比例，通过设置 zoom、scale 来自适应容器宽高,如:
&amp;lt;div class=&amp;#34;auto-size&amp;#34; contenteditable=&amp;#34;true&amp;#34; style=&amp;#34;border: 1px solid gray; width: 120px; height: 120px;resize: both; overflow: scroll;&amp;#34; &amp;gt; &amp;lt;span&amp;gt; 通过拖动右下角,或者增加删除文字查看字体缩放。 &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; function autoFit(ele) { const wrapperSty = ele.</description></item><item><title>浏览器中获取宽、高相关的属性</title><link>https://chenkai.life/web/get-width-and-height-attributes-in-the-browser/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/get-width-and-height-attributes-in-the-browser/</guid><description>我们可能需要针对宽屏和高屏编写不同代码，下面我总结一下从浏览器中获取宽、高相关的属性
css 如果宽高屏不设计具体逻辑代码，我们可以采用 css 的@media媒体查询的方式判断;
orientation 宽度和高度相等时会被判断为纵向
/* viewport 处于纵向，即高度大于等于宽度 */ @media (orientation: portrait) { } /* viewport 处于横向，即宽度大于高度。 */ @media (orientation: landscape) { } aspect-ratio 利用宽高比我们也可以判断宽高屏，当如果同时满足后面的样式会覆盖前面，所以下面当宽高相等时生效的是@media (aspect-ratio: 1/1) {}
/* 最大宽高比 */ @media (max-aspect-ratio: 1/1) { } /* 最小宽高比 */ @media (min-aspect-ratio: 1/1) { } /* 指定宽高比 */ @media (aspect-ratio: 1/1) { } js window innerHeight innerWidth outerHeight outerWidth 获取浏览器窗口的视口（viewport）高度、宽度（以像素为单位）
screen height: 以像素为单位返回屏幕的高度
width: 以像素为单位返回屏幕的宽度.
orientation: 返回当前屏幕的转向.
availHeight: 指定屏幕的高度（以像素为单位）减去操作系统显示的永久或半永久用户界面功能，例如 Windows 上的任务栏.</description></item><item><title>浏览器如何渲染页面</title><link>https://chenkai.life/web/how-brower-render-page/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/how-brower-render-page/</guid><description>参考https://coolshell.cn/articles/9666.html
文章是为了说明浏览器如何将 HTML，CSS 和 JavaScript 转换为网站。
首先 浏览器是一个可以从远程服务器或者本地磁盘将文件加载、显示、交互的软件。
浏览器有两个重要部分：
渲染引擎（Rendering Engine）：一般习惯称为“浏览器内核”，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同如 Gecko（火狐）、Blink（Chrome）、Webkit（Safari）、Trident（IE）等，因此同一网页在不同的内核的浏览器里的渲染效果也可能不同。
JavaScript 引擎：JavaScript 由 ECMAScript，DOM 和 BOM 三者组成，不同浏览器针对 JavaScript 语法和语义标准有多种实现如：
Chrome 使用 V8 引擎， Safari 使用 JavaScriptCore， Firefox 使用 SpiderMonkey 浏览器接收数据 数据是通过 Internet 以数据包（Packet）为单位按字节形式发送到浏览器。浏览器将从硬盘（或网络）中读取 HTML 的原始数据字节转换为字符。
从原始字节到 DOM 当浏览器接受到扩展名为.html 时，会将该文件解释为 html 对其进行解析，文件中的每个开始和结束 html 标签会转换为节点如
&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; 创建这些节点后，然后将这些节点链接到称为 DOM 的树数据结构中。DOM 建立父子关系，相邻的兄弟关系等。每个节点之间的关系都在此 DOM 对象中建立。浏览器必须先将 html 数据的原始字节转换为 DOM，然后才能进行任何操作。
当浏览器接收数据的原始字节并启动 DOM 构造过程时，它还将发出请求以获取链接的样式表。 一旦浏览器开始解析 html，一旦找到文件的 link 标签，浏览器 css 就会同时发出获取请求的请求。
从原始字节到 CSSOM 当浏览器收到 CSS 的原始字节时，也会启动 HTML 原始字节的类似过程。将数据的原始字节转换为字符，然后标记化节点，最后还形成 CSS 树结构，称为 CSS 对象模型，简称 CSSOM。 CSS 有一个叫做Cascade的东西。级联是浏览器如何确定将哪些样式应用于元素的方式。</description></item><item><title>谈谈Web项目中图标的方式</title><link>https://chenkai.life/web/use-icon-in-web/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/use-icon-in-web/</guid><description>谈谈 Web 项目中图标的方式
单个图标 我们可以选择单独引用图标文件如 png、svg 等等，这种方式缺点显而易见，图标多了之后不方便维护
字体文件 通过font-face,我们可以指定一个用于显示文本的自定义字体，字体文件内部类似一个svg我们可以在字体文件里面随便定义这些字符的形状，
通过对应字体文件的字体编码我们就可以使用这些图标了,如下面是一个close图标
&amp;lt;i class=&amp;#34;iconfont&amp;#34;&amp;gt;&amp;amp;#xe64f;&amp;lt;/i&amp;gt; 这样有个明显的缺点就是图标不直观，我们很难根据&amp;amp;#x33;知道它是什么图标，我们可以通过提前定义好对应图标 css 的::before的 content，将其改造成自定义 class 引用的方式
.icon-close:before { content: &amp;#34;\e64f&amp;#34;; } 然后我们在页面中可以这样使用
&amp;lt;span class=&amp;#34;iconfont icon-close&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 因为是字体格式所以这种方式使用图标有以下特点
兼容性最好，支持 ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 不支持多色。 symbol 引用 symbol 元素用来定义一个图形模板对象，它可以用一个use元素实例化。一个symbol元素本身是不呈现的。只有symbol元素的实例（亦即，一个引用了symbol的 use元素）才能呈现，如
&amp;lt;svg&amp;gt; &amp;lt;!-- symbol definition NEVER draw --&amp;gt; &amp;lt;symbol id=&amp;#34;sym01&amp;#34; viewBox=&amp;#34;0 0 150 110&amp;#34;&amp;gt; &amp;lt;circle cx=&amp;#34;50&amp;#34; cy=&amp;#34;50&amp;#34; r=&amp;#34;40&amp;#34; stroke-width=&amp;#34;8&amp;#34; stroke=&amp;#34;red&amp;#34; fill=&amp;#34;red&amp;#34; /&amp;gt; &amp;lt;circle cx=&amp;#34;90&amp;#34; cy=&amp;#34;60&amp;#34; r=&amp;#34;40&amp;#34; stroke-width=&amp;#34;8&amp;#34; stroke=&amp;#34;green&amp;#34; fill=&amp;#34;white&amp;#34; /&amp;gt; &amp;lt;/symbol&amp;gt; &amp;lt;!-- actual drawing by &amp;#34;use&amp;#34; element --&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;0&amp;#34; width=&amp;#34;100&amp;#34; height=&amp;#34;50&amp;#34; /&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;50&amp;#34; width=&amp;#34;75&amp;#34; height=&amp;#34;38&amp;#34; /&amp;gt; &amp;lt;use xlink:href=&amp;#34;#sym01&amp;#34; x=&amp;#34;0&amp;#34; y=&amp;#34;100&amp;#34; width=&amp;#34;50&amp;#34; height=&amp;#34;25&amp;#34; /&amp;gt; &amp;lt;/svg&amp;gt; symbol的作用域是全局的我们也可以在 svg 中单独使用如</description></item><item><title>跨域资源共享 (CORS)</title><link>https://chenkai.life/web/cross-origin-resource-sharing/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/cross-origin-resource-sharing/</guid><description>转载自 web.dev
浏览器的同源策略阻止了浏览器读取不同源的资源。这种机制能够阻止恶意网站读取另一个网站的数据，但也会阻碍合法使用。如果您希望获取其他国家的天气数据该怎么办？
在现代网络应用程序中，应用程序通常希望从不同源获取资源。例如，您想要从不同的域读取 JSON 数据或者将另一个网站的图像加载到&amp;lt;canvas&amp;gt;元素中。
换句话说，部分公共资源应该可以供任何人读取，但同源策略会阻碍这一点。开发者使用过诸如 JSONP 之类的变通方法，但跨域资源共享 (CORS) 能够通过标准方式修复此问题。
启用 CORS 可以让服务器告知浏览器自己已获许使用其他源。
资源请求在网络上是如何运作的？ # 图：客户端请求和服务器响应图示
浏览器和服务器可以使用超文本传输协议 (HTTP) 来通过网络交换数据。HTTP 定义了请求者和响应者之间的通信规则，其中包括获取资源所需的信息。
HTTP 标头用于协商客户端和服务器之间的消息交换类型，并用于确定访问权限。浏览器的请求和服务器的响应消息都分为两部分：标头和主体：
标头 # 包含消息的相关信息，例如消息类型或消息编码。标头可以包括各种信息，这些信息通过键值对表示。请求头和响应头包含不同的信息。
请务必注意，标头不能包含评论。
请求头示例
Accept: text/html Cookie: Version=1 以上内容相当于表示“我希望收到 HTML 的响应。这是我的一个 cookie。”
响应头示例
Content-Encoding: gzip Cache-Control: no-store 以上内容相当于表示“数据是用 gzip 编码的。请不要将其缓存。”
主体 # 消息本身。主体可以是纯文本、二进制图像、JSON、HTML 等。
CORS 是如何运作的？ # 请记住，同源策略会让浏览器阻止跨域请求。当您想从不同的源获取公共资源时，提供资源的服务器需要告知浏览器“发出该请求的这个源可以访问我的资源”。浏览器会记住这一点，并允许跨域资源共享。
第一步：客户端（浏览器）请求 # 当浏览器发出跨域请求时，该浏览器会添加一个包含当前源（协议、主机和端口）的Origin标头。
第二步：服务器响应 # 在服务器端，当服务器看到该标头并想要允许访问时，就需要在响应中加入一个Access-Control-Allow-Origin标头来指定请求源（或加入*来允许任何源。）
第三步：浏览器接收响应 # 当浏览器看到带有相应Access-Control-Allow-Origin标头的响应时，即允许与客户端网站共享响应数据。
查看 CORS 的实际应用 # 这是一个使用 Express 的小型网络服务器。
第一个端点（第 8 行）没有设置任何响应头，该端点只会在响应中发送一个文件。</description></item><item><title>WebWorker</title><link>https://chenkai.life/web/web-worker/</link><pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/web-worker/</guid><description>一、概述 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。
Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。
Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。
Web Worker 有以下几个使用注意点。
（1）同源限制
分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。
（2）DOM 限制
Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。
（3）通信联系
Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
（4）脚本限制
Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。
（5）文件限制
Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。
二、基本用法 2.1 主线程 主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。
var worker = new Worker(&amp;#34;work.js&amp;#34;); Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如 404 错误），Worker 就会默默地失败。</description></item><item><title>在浏览器中本地运行 Node.js - WebContainers</title><link>https://chenkai.life/web/web-containers/</link><pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/web-containers/</guid><description>起因 在nodejs.dev网站看到了一个在线编辑的程序https://nodejs.dev/learn/introduction-to-nodejs#an-example-nodejs-application ,起初我以为这是一个类似codepen的在线编辑器，通过关键词webcontainer, 我发现这是一个在浏览器中本地运行 Node.js 程序， 并找到了下面这篇文章https://blog.stackblitz.com/posts/introducing-webcontainers/，
以下内容为文章翻译：
WebContainers 简介：在浏览器中本地运行 Node.js ERIC SIMONS可能 2021 年 2 月 20 日新闻和公告
你好呀！我们是 StackBlitz，一个专门为 Web 开发量身定制的在线 IDE。在本周的 Google I/O 主题演讲中，您可能已经看到了我们的先睹为快。
今天，我们很高兴地宣布，我们一直在与 Next.js 和 Google 的团队合作开发一项新技术。
几年前，我们意识到网络正走向一个关键的转折点。 WebAssembly 的出现和新的 功能 API 使编写一个基于 WebAssembly 的操作系统变得可能，它的功能足以运行 Node.js，完全在你的浏览器中。我们设想了一个比本地环境更快、更安全和一致的卓越开发环境，以实现无缝代码协作，而无需设置本地环境。
这听起来有些牵强。但是，如果网络现在为 平面设计师、视频编辑器 /web.dev/clipchamp/) 和 丰富的文档编辑，我们想知道：开发人员最终有可能*使用*网络来*构建*网络吗？
我们决定试一试。我们抱有最好的希望，也期待最坏的结果。两年后（时间过得真快 😅），结果出乎意料地惊人。
今天我们很高兴地宣布WebContainers WebContainers 允许您创建全栈 Node.js 环境，这些环境在几毫秒内启动并立即在线和链接共享 - 只需单击一下。该环境加载了 VS Code 强大的编辑体验、完整的终端、npm 等。它还完全在您的浏览器内运行，这会产生一些关键优势：
比您的本地环境更快。构建完成速度最多可提高 20%，软件包安装完成速度比 yarn/npm 快 &amp;gt;= 5 倍。 Node.js 在浏览器中调试。与 Chrome DevTools 的无缝集成支持原生后端调试，无需安装或扩展。 默认安全。所有代码执行都发生在内部浏览器的安全沙箱中，而不是在远程虚拟机或本地二进制文件上。 没错：Node.</description></item><item><title>WebAssembly上手</title><link>https://chenkai.life/web/webassembly/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/webassembly/</guid><description>WebAssembly是什么 WebAssembly是为高效执行和紧凑表示而设计的运行在现代处理器（包括浏览器）中的一种快速、安全、可移植的底层代码格式，具有紧凑的二进制格式，可以以接近本机的性能运行。2019年12月5日W3C宣布WebAssembly核心规范成为正式标准。名字上可以知道是给Web使用的汇编语言。但是WebAssembly并不是直接用汇编语言，而提供了转换机制（LLVM IR），把高级别的语言（AssemblyScript、go、C、C++、Rust等）编译为WebAssembly，以便有机会通过Web浏览器执行低级二进制语法 。
WebAssembl的特点 WebAssembly是一门不同于JavaScript的语言，它不是用来取代JavaScript的。相反，它被设计为和JavaScript一起协同工作，从而使得网络开发者能够利用两种语言的优势，通过使用WebAssembly的JavaScriptAPI，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。
快速：大幅度提高 Javascript 的性能，以接近本机的代码性能执行。 安全：代码经过验证并在内存安全沙盒环境中执行，可防止数据损坏或安全漏洞。 与语言无关：允许任何语言编译到WebAssembly， 可以用其他高级语言写网页。 与硬件无关：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。 与平台无关：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。 紧凑：具有比典型的文本或本机代码格式小的传输速度快的二进制格式。 模块化：程序可以分成较小的部分，可以分别传输，缓存和使用。 高效：可以通过快速一次通过来解码，验证和编译，等同于实时（JIT）或提前（AOT）编译。 Streamable：允许在看到所有数据之前尽快开始解码，验证和编译。 为什么WebAssembly比JavaScript 执行效率更高 WebAssembly最吸引人的特点便是它的执行效率，比JavaScript执行效率更高主要有以下原因：
文件获取阶段：WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段：WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段：WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段：WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码&amp;lt;-&amp;gt;重优化”现象。 执行阶段：WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。 如何使用WebAssembly 高级语言编译到 .wasm 文件 WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。 想要编译成WebAssembly，你首先需要先编译 LLVM，参考webassembly.org. LLVM可以实现</description></item><item><title>前后端通过切片上传文件</title><link>https://chenkai.life/web/web-upload-file/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/web-upload-file/</guid><description>最近在做前端上传文件，主要包括选择单个｜多个文件、单个｜多个文件夹、拖拽文件｜文件夹方式上传文件，上传时通过分片计算文件hash值实现断点续传、秒传功能，简要介绍下具体实行思路
获取用户选择文件 注意这种方式用到的部分特性是非标准的
拖拽上传 从可拖拽区域中获取过滤获取拖拽的文件的FileSystemEntry
async drop(e) { e.stopPropagation(); e.preventDefault(); let items = e.dataTransfer.items; let dropFilesEntrys = []; for (let item of items) { if (!item || !item.webkitGetAsEntry) continue; item = item.webkitGetAsEntry(); if (!item) continue; let filesEntrys = await this.getFilesEntrys(item); dropFilesEntrys.push(...filesEntrys); } let files = await this.transformFilesEntrys(dropFilesEntrys); this.handerFiles(files); }, 获取FileSystemEntry包含的FilesEntrys，FileSystemEntry可能代表文件系统中的文件或者目录
/** * 获取drop区域的文件 * @returns FilesEntrys */ async getFilesEntrys(item) { let filesEntrys = []; let scanFiles = async (item) =&amp;gt; { return new Promise((resolve) =&amp;gt; { if (item.</description></item><item><title>拷贝数据到剪贴板</title><link>https://chenkai.life/web/brower-copy-to-clipboard/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/brower-copy-to-clipboard/</guid><description>介绍几种在浏览器中拷贝数据到剪贴板的方法
document.execCommand(&amp;ldquo;copy&amp;rdquo;) 拷贝当前选中内容到剪贴板, 该 api 已经废弃不推荐使用，
function fallbackCopyTextToClipboard(text) { const textArea = document.createElement(&amp;#34;textarea&amp;#34;); textArea.value = text; textArea.style.top = &amp;#34;0&amp;#34;; textArea.style.left = &amp;#34;0&amp;#34;; textArea.style.position = &amp;#34;fixed&amp;#34;; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { let msg = document.execCommand(&amp;#34;copy&amp;#34;); if (!msg) { throw new Error(&amp;#34;Copy filed&amp;#34;); } } finally { document.body.removeChild(textArea); } } navigator.clipboard 剪贴板 Clipboard API 提供了响应剪贴板命令（剪切、复制和粘贴）与异步读写系统剪贴板的能力。从权限 Permissions API 获取权限之后，才能访问剪贴板内容；如果用户没有授予权限，则不允许读取或更改剪贴板内容。该 API 被设计用来取代使用 document.execCommand() 的剪贴板访问方式。(基于 HTTP 的网站中包含的脚本则不能获得剪贴板对象)
await navigator.clipboard.writeText(data); npm package clipboard, 内部使用的 document.execCommand(), clipboardy, 该库较重，支持 web 平台之外的 copy</description></item><item><title>浏览器处理cookie</title><link>https://chenkai.life/web/cookie/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/cookie/</guid><description>设置 cookie function setCookie(options) { const { name, data } = options; const age = options.age || 24 * 3600000; const domain = options.domain || window.location.hostname; document.cookie = `${name}=${data}; path=/; max-age=${age}; domain=${domain}`; } 获取 cookie function getCookie(cookie_name) { let value = null; let allcookies = document.cookie; let cookie_pos = allcookies.indexOf(cookie_name); if (cookie_pos != -1) { cookie_pos = cookie_pos + cookie_name.length + 1; let cookie_end = allcookies.indexOf(&amp;#34;;&amp;#34;, cookie_pos); if (cookie_end == -1) { cookie_end = allcookies.</description></item></channel></rss>