<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database on CK's Blog</title><link>https://chenkai.life/tags/database/</link><description>Recent content in Database on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 21 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://chenkai.life/tags/database/index.xml" rel="self" type="application/rss+xml"/><item><title>PostgreSQL</title><link>https://chenkai.life/database/pg/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg/</guid><description>排序 order by用于对表进行排序
SELECT select_list FROM table_expression ORDER BY sort_expression1 [ASC | DESC] [NULLS { FIRST | LAST }] [, sort_expression2 [ASC | DESC] [NULLS { FIRST | LAST }] ...] 当指定了多个表达式时，后面的值用于根据前面的值对相等的行进行排序。
每个表达式后面都可以跟一个可选的ASC或DESC关键字，以将排序方向设置为升序或降序。 可选参数NULLS FIRST可NULLS LAST用于确定空值是出现在排序顺序中的非空值之前还是之后。默认(NULLS FIRST) 其中sort_expression可以是任何有效的表达式如
SELECT a, b FROM table1 ORDER BY a + b, c; SELECT a, b FROM table1 ORDER BY CASE WHEN a &amp;gt;= 0 and b THEN a ELSE -1 END, c; 中文字段的排序 PostgreSQL 中的 ORDER BY 默认使用的是基于当前数据库的默认排序规则进行排序。在不同的字符集中，汉字的编码可能不一样，比如 UTF8 和 GBK，其中 GBK 大致是按拼音的顺序进行编码的，而 UTF8 则不是。所以如果你的数据库使用了 UTF8 编码，对中文字段进行排序时，得到的并不是按拼音排序的结果。 PostgreSQL 中，中文按拼音排序的编码包括 GB18030, EUC_CN, GBK, BIG5 等。 为了得到拼音排序，</description></item><item><title>pg 分词</title><link>https://chenkai.life/database/pg-to-tsvector/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-to-tsvector/</guid><description> 分词例子 to_tsvector()生成的分词带有位置信息，tsvector 没有位置信息
select to_tsvector(&amp;#39;陈 锴 A S F a a a 1 2 3 4&amp;#39;); select to_tsvector(&amp;#39;simple&amp;#39;, &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39;); select to_tsvector(&amp;#39;english&amp;#39;, &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39;); `&amp;#39;1&amp;#39;:8 &amp;#39;12&amp;#39;:3 &amp;#39;2&amp;#39;:9 &amp;#39;3&amp;#39;:10 &amp;#39;4&amp;#39;:11 &amp;#39;a&amp;#39;:1,5,6,7 &amp;#39;apple&amp;#39;:2 &amp;#39;f&amp;#39;:4` select &amp;#39;陈 锴 一个 , A apple 12 F a a a 1 2 3 4&amp;#39; :: tsvector; `&amp;#39;,&amp;#39; &amp;#39;1&amp;#39; &amp;#39;12&amp;#39; &amp;#39;2&amp;#39; &amp;#39;3&amp;#39; &amp;#39;4&amp;#39; &amp;#39;A&amp;#39; &amp;#39;F&amp;#39; &amp;#39;a&amp;#39; &amp;#39;apple&amp;#39; &amp;#39;一个&amp;#39; &amp;#39;锴&amp;#39; &amp;#39;陈&amp;#39;`</description></item><item><title>pg中为存储过程添加进度</title><link>https://chenkai.life/database/pg-how-to-add-process-in-function/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-how-to-add-process-in-function/</guid><description>有时我们可能需要知道长时间调用存储过程的进度。
通过外部表 首先我想到通过修改一张外部表更新存储过程的进度，后来发现这样是不行的。存储过程执行中对数据库的改变在外部是获取不到的，它只有在执行完毕提交后，我们才能获取结果，所以这种方式我们获取到的进度可能全都是 100%。
raise RAISE语句可以在 sql 运行过程中向程序抛出消息或错误，文档
用法如下所示： sql
RAISE INFO &amp;#39;model_progress:%&amp;#39;,json_build_object(&amp;#39;job_uid&amp;#39;,job_uid,&amp;#39;job_progress&amp;#39;,progress); 程序中我们还可以获取到存储过程抛出的消息：如 node 实现所示
const pool = new Pg.Pool(Config.db); pool.on(&amp;#34;connect&amp;#34;, (cl) =&amp;gt; { cl.on(&amp;#34;notice&amp;#34;, (msg) =&amp;gt; { //获取sql抛出的信息 DbNoticeHandler.handle(msg); }); });</description></item><item><title>pg中如何取消正在执行的存储过程</title><link>https://chenkai.life/database/cancel-runing-function/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/cancel-runing-function/</guid><description>如果存储过程执行过程，需要添加可以取消的功能，这里我们需要用到两个函数。
pg_backend_pid: 查询当前会话的服务器进程的进程 ID， pg_cancel_backend(pid int): 取消后端的当前查询。如果调用角色是其后端被取消或已授予调用角色的角色的成员，则也允许这样做 pg_signal_backend，但是只有超级用户可以取消超级用户后端。 在函数中查询当前的 pid create or replace function pg_cancel_backend() returns void as $$ declare backend_pid bigint; begin --查询当前pid backend_pid = pg_backend_pid(); loop raise notice &amp;#39;%&amp;#39;, format(&amp;#39;%1$s : backend_pid: %2$s&amp;#39;, now(),backend_pid); perform pg_sleep(2); end loop; end; $$ language plpgsql; -- 2019-07-25 03:47:30.783608+00 : backend_pid: 13677 根据 pid 取消当前进程 select pg_cancel_backend(13677);</description></item><item><title>pg中的数据库时区</title><link>https://chenkai.life/database/pg-timezone/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-timezone/</guid><description> 原因 系统主机与数据库时间不一致； 数据库配置文件中 timezone 与镜像系统里面设置的时区不一致
解决办法 修改数据库/var/lib/postgresql/data/postgresql.conf 中的 timezone 或者镜像时区保持一致后重启数据库
timestamp with time zone，内部存储的值始终为 UTC（通用协调时间，传统上称为格林威治标准时间）。具有指定显式时区的输入值将使用该时区的适当偏移量转换为 UTC。如果输入字符串中未指定时区，则假定它位于系统的 timezone 参数指示的时区中，并使用区域的偏移量转换为 UTC 。当一个 timestamp with time zone 值被输出，它总是从 UTC 转换成当前 timezone 区域，并作为在该区域中的本地时间显示。
步骤 查看数据库时区
show time zone; 查看系统时间与时区
date Thu Nov 19 09:39:58 CST 2015 date -R Thu, 19 Nov 2015 09:40:33 +0800 视图 pg_timezone_names 保存了所有可供选择的时区
select * from pg_timezone_names; 查看配置文件中时区设置，要想永久生效，此时需要修改配置文件
[grep timezone postgresql.conf log_timezone = &amp;#39;US/Pacific&amp;#39; timezone = &amp;#39;US/Pacific&amp;#39; 修改完配置时重新加载
[postgres@rudy_01 ~]$ pg_ctl reload server signaled [postgres@rudy_01 ~]$ psql postgres=# show time zone; TimeZone</description></item><item><title>pg触发器</title><link>https://chenkai.life/database/pg-trigger/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-trigger/</guid><description>触发器 一个触发器声明了当执行一种特定类型的操作时数据库应该自动执行一个特殊的函数。触发器可以被附加到表（分区的或者不分区的）、视图和外部表。 在表和外部表上，触发器可以被定义为在 INSERT、UPDATE 或 DELETE 操作之前或之后被执行， 可以为每个 SQL 语句被执行一次或者为每个修改的行 被执行一次。UPDATE 触发器可以进一步地设置为只针对 UPDATE 语句的 SET 子句的特定列出发。触发器也可以被 TRUNCATE 语句触发。如果一个触发器事件发生， 触发器函数会在适当的事件被调用来处理该事件。
触发器函数必须在触发器本身被创建之前被定义好。触发器函数必须被定义成一个没有参数的函数，并且返回类型为 trigger（触发器函数通过一个特殊传递的 TriggerData 结构作为其输入，而不是以普通函数参数的形式）。 一旦一个合适的触发器函数被创建，就可以使用 CREATE TRIGGER 建立触发器。同一个触发器函数可以被用于多个触发器。
触发器函数规则 当一个 PL/pgSQL 函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：
NEW 数据类型是 RECORD；该变量为行级触发器中的 INSERT/UPDATE 操作保持新数据行。在语句级别的触发器以及 DELETE 操作，这个变量是 null。 OLD 数据类型是 RECORD；该变量为行级触发器中的 UPDATE/DELETE 操作保持新数据行。在语句级别的触发器以及 INSERT 操作，这个变量是 null。 TG_NAME 数据类型是 name；该变量包含实际触发的触发器名。 TG_WHEN 数据类型是 text；是值为 BEFORE、AFTER 或 INSTEAD OF 的一个字符串，取决于触发器的定义。 TG_LEVEL 数据类型是 text；是值为 ROW 或 STATEMENT 的一个字符串，取决于触发器的定义。 TG_OP 数据类型是 text；是值为 INSERT、UPDATE、DELETE 或 TRUNCATE 的一个字符串，它说明触发器是为哪个操作引发。 TG_RELID 数据类型是 oid；是导致触发器调用的表的对象 ID。 TG_RELNAME 数据类型是 name；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用 TG_TABLE_NAME 替代。 TG_TABLE_NAME 数据类型是 name；是导致触发器调用的表的名称。 TG_TABLE_SCHEMA 数据类型是 name；是导致触发器调用的表所在的模式名。 TG_NARGS 数据类型是 integer；在 CREATE TRIGGER 语句中给触发器函数的参数数量。 TG_ARGV[] 数据类型是 text 数组；来自 CREATE TRIGGER 语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于 tg_nargs）会导致返回一个空值。 一个触发器函数必须返回 NULL 或者是一个与触发器为之引发的表结构完全相同的记录/行值。 一个 PL/pgSQL 触发器函数 触发器函数说明文档</description></item><item><title>postgresql中的sequence</title><link>https://chenkai.life/database/pg-sequence/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-sequence/</guid><description>sequence 号是数据库系统按照一定规则自增的数字序列 sequence 操作函数
Function Return Type Description currval(regclass) bigint Return value most recently obtained with nextval for specified sequence lastval() bigint Return value most recently obtained with nextval for any sequence nextval(regclass) bigint Advance sequence and return new value setval(regclass, bigint) bigint Set sequence&amp;#39;s current value setval(regclass, bigint, boolean) bigint Set sequence&amp;#39;s current value and is_called flag 创建 sequence postgre文档
sequence 操作函数定义
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] name [ AS data_type ] [ INCREMENT [ BY ] increment ] [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ] [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ] [ OWNED BY { table_name.</description></item><item><title>postgres有用的sql</title><link>https://chenkai.life/database/pg-useful-sql/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-useful-sql/</guid><description>数据库迁移备份 备份：pg_dump -U postgres -d myDBname -f dump.sql 还原：
pg_dump -U postgres -d g-default -f g-default.sql
忽略某些 schema psql -N data -N public_data -d g-default -U postgres -f g-default.sql
将 mydb 数据库转储到一个 SQL 脚本文件：pg_dump mydb &amp;gt; db.sql 将上述脚本导入一个(新建的)数据库 newdb：psql -d newdb -f db.sql
将数据库转储为自定义格式的归档文件pg_dump -Fc mydb &amp;gt; db.dump 将数据库转储为目录格式归档：pg_dump -Fd mydb -f dumpdir 将数据库转储为目录格式归档，并行 5 个 worker 工作：pg_dump -Fd mydb -j 5 -f dumpdir 将归档文件导入一个(新建的)数据库 newdb：pg_restore -d newdb db.dump</description></item><item><title>postgre中的复合类型</title><link>https://chenkai.life/database/pg-composite-type/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/database/pg-composite-type/</guid><description>声明复合类型 Composite Types:复合类型Composite Types表示行或记录的结构; 它本质上只是一个字段名称及其数据类型。 PostgreSQL 允许复合类型像用简单类型相同的方式使用。 例如，表的列可以声明为复合类型。 语法与 CREATE TABLE 相当，只是可以指定字段名称和类型; 目前不能包含任何约束（例如 NOT NULL）。 请注意，AS 关键字是必不可少的; 没有它，系统会认为有一种不同的 CREATE TYPE 命令，你会得到奇怪的语法错误。 以下是定义复合类型的两个简单示例：
CREATE TYPE complex AS ( r double precision, i double precision ); CREATE TYPE inventory_item AS ( name text, supplier_id integer, price numeric ); 定义了类型后，我们可以使用它们：
CREATE TABLE on_hand ( item inventory_item, count integer ); INSERT INTO on_hand VALUES (ROW(&amp;#39;fuzzy dice&amp;#39;, 42, 1.99), 1000); CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric AS &amp;#39;SELECT $1.</description></item></channel></rss>