<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>vue on CK's Blog</title><link>https://chenkai.life/tags/vue/</link><description>Recent content in vue on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Jul 2021 15:37:56 +0800</lastBuildDate><atom:link href="https://chenkai.life/tags/vue/index.xml" rel="self" type="application/rss+xml"/><item><title>vue_nextTick的原理</title><link>https://chenkai.life/web/vue_nexttick/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/vue_nexttick/</guid><description>nextTick是vue的一个全局API， 作用是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
const callbacks = [] let pending = false function flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &amp;lt; copies.length; i++) { copies[i]() } } // Here we have async deferring wrappers using microtasks. // In 2.</description></item><item><title>vue实践</title><link>https://chenkai.life/web/vue_guide/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/vue_guide/</guid><description>参考vue风格指南 参考vue编程指南
Vue Router 路由懒加载 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载
规范 vue文件内css样式尽量使用局部样式。全局样式可以统一放入静态库由app.vue文件导入
注意事项 vue data中的对象状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新
最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, 'newProp', 123), 或者 以新对象替换老对象。例如，利用对象展开运算符我们可以这样写： state.obj = { ...state.obj, newProp: 123 }</description></item><item><title>vue样式dev和build下不一致</title><link>https://chenkai.life/web/vue_page_style_dev_build_different/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/vue_page_style_dev_build_different/</guid><description>一次更新镜像后发现vue项目页面混乱，在开发模式模式下，写的样式有效，打包后无效
一、多个相同样式文件同时存在项目中 现象：修改组件时，在项目中复制了一个组件重命名后进行修改，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：在本地试图修改总是不见效果，在控制台查看样式仍是之前的样式，把其中一处样式在所有相关组件中修改，打包上传后样式生效，这说明是旧的样式在打包时覆盖了新的样式。将旧组件删除后解决上述问题。 原因猜测：因为相同组件包含不同样式时，无法判断哪份样式时在后面渲染，如果旧样式刚好打包后在后面渲染，则会覆盖掉新写的样式。在本地执行时，因为样式没有打包，访问页面时渲染的都是组件自身样式，所以不会出现上述问题。
二、全局(main.js)引用样式 现象：在全局引入了Element UI 样式，在header组件中修改部分样式，在本地执行正常，后打包上传，无法展示正常效果。 解决过程：因为在项目中段发现该问题，以为是后续的样式造成的影响(虽然我也认为可能性极小)，删除新写的组件，没有效果。运行一段时间之前的代码，项目正常运行，这迫使我回想中间这段时间对项目做了什么？除了新写了一些组件，还将一些配置信息从index.js中转移到了main.js中，测试发现果然是这里出现了问题。配置中同时出现了Element UI 样式文件引用，还有router的引用，将yang样式引用放在router引用后解决问题。 原因猜测：不正常的样式显示的还是组件原始的样式，由此猜测router加载时会加载组件样式，将样式文件在router后引用会将router加载时渲染的样式覆盖掉，所以建议将router的引用放在最后面。在每个组件的样式中记得添加 ‘scoped’.
import &amp;#39;element-ui/lib/theme-chalk/index.css&amp;#39; //element样式文件 import App from &amp;#39;./App&amp;#39; 如果相反，那么element-ui的样式会覆盖自定义的样式，所以会出现你修改的样式不生效问题！！</description></item><item><title>vue项目添加单元测试</title><link>https://chenkai.life/web/vue_test/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/web/vue_test/</guid><description>创建vue的单元测试项目
vue-cli 创建项目 vue create vue-test Vue CLI 3可以向项目组中直接添加unit-jest vue add @vue/unit-jest 可以发现项目中多了很多文件，并且已经创建了一个测试文件demo，
进行测试 vue在添加单元测试框架时会在package.jsonscripts添加一个test:unit，我们可以允许此命令打开测试
在vue版本过低的项目中添加单元测试 我们可以选择以下两种方式
升级vue版本及其依赖 vue版本如果太旧的不支持此种方式直接添加单元测试,可以选择更新vue版本2.5以上，并更新其依赖库。 此种方法可能会出现浏览器报exportes错误，把.babelrc文件transform-runtime删除即可。
采用旧版本方式 Note: This example is outdated. It&amp;rsquo;s now recommended to scaffold your project with Vue CLI 3 which provides out-of-the-box configurations for unit testing.
vue-test-utils-jest-example Example project using Jest + vue-test-utils together</description></item></channel></rss>