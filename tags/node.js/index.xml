<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Node.js on CK's Blog</title><link>https://chenkai.life/tags/node.js/</link><description>Recent content in Node.js on CK's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 08 May 2024 18:58:53 +0800</lastBuildDate><atom:link href="https://chenkai.life/tags/node.js/index.xml" rel="self" type="application/rss+xml"/><item><title>在浏览器中本地运行 Node.js - WebContainers</title><link>https://chenkai.life/web/web-containers/</link><pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/web/web-containers/</guid><description>起因 在nodejs.dev网站看到了一个在线编辑的程序https://nodejs.dev/learn/introduction-to-nodejs#an-example-nodejs-application ,起初我以为这是一个类似codepen的在线编辑器，通过关键词webcontainer, 我发现这是一个在浏览器中本地运行 Node.js 程序， 并找到了下面这篇文章https://blog.stackblitz.com/posts/introducing-webcontainers/，
以下内容为文章翻译：
WebContainers 简介：在浏览器中本地运行 Node.js ERIC SIMONS可能 2021 年 2 月 20 日新闻和公告
你好呀！我们是 StackBlitz，一个专门为 Web 开发量身定制的在线 IDE。在本周的 Google I/O 主题演讲中，您可能已经看到了我们的先睹为快。
今天，我们很高兴地宣布，我们一直在与 Next.js 和 Google 的团队合作开发一项新技术。
几年前，我们意识到网络正走向一个关键的转折点。 WebAssembly 的出现和新的 功能 API 使编写一个基于 WebAssembly 的操作系统变得可能，它的功能足以运行 Node.js，完全在你的浏览器中。我们设想了一个比本地环境更快、更安全和一致的卓越开发环境，以实现无缝代码协作，而无需设置本地环境。
这听起来有些牵强。但是，如果网络现在为 平面设计师、视频编辑器 /web.dev/clipchamp/) 和 丰富的文档编辑，我们想知道：开发人员最终有可能*使用*网络来*构建*网络吗？
我们决定试一试。我们抱有最好的希望，也期待最坏的结果。两年后（时间过得真快 😅），结果出乎意料地惊人。
今天我们很高兴地宣布WebContainers WebContainers 允许您创建全栈 Node.js 环境，这些环境在几毫秒内启动并立即在线和链接共享 - 只需单击一下。该环境加载了 VS Code 强大的编辑体验、完整的终端、npm 等。它还完全在您的浏览器内运行，这会产生一些关键优势：
比您的本地环境更快。构建完成速度最多可提高 20%，软件包安装完成速度比 yarn/npm 快 &amp;gt;= 5 倍。 Node.js 在浏览器中调试。与 Chrome DevTools 的无缝集成支持原生后端调试，无需安装或扩展。 默认安全。所有代码执行都发生在内部浏览器的安全沙箱中，而不是在远程虚拟机或本地二进制文件上。 没错：Node.</description></item><item><title>JsonWebToken</title><link>https://chenkai.life/nodejs/jsonwebtoken/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/jsonwebtoken/</guid><description>什么是 JSON Web Token？ JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑且独立的方式，用于在各方之间用 SON 对象安全地传输信息。此信息可以通过数字签名进行验证和信任。 JWT 可以使用加密算法（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。
什么时候应该使用 JSON Web 令牌 以下是 JSON Web 令牌有用的一些场景：
授权：这是使用 JWT 的最常见方案。一旦用户登录，每个后续请求将包括 JWT，允许用户访问该令牌允许的路由，服务和资源。 Single Sign On 是一种现在广泛使用 JWT 的功能，因为它的开销很小，并且能够在不同的域中轻松使用。
信息交换：JSON Web 令牌是在各方之间安全传输信息的好方法。因为 JWT 可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。
JSON Web 令牌结构 JSON Web Tokens 由.分隔的三个部分组成，它们是：
头 有效载荷 签名 因此，JWT 通常如xxxxx.yyyyy.zzzzz所示. 头 标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。
{ &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 然后，这个 JSON 被编码为 Base64Url，形成 JWT 的第一部分。</description></item><item><title>node Promise 转换</title><link>https://chenkai.life/nodejs/node-promise/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-promise/</guid><description>如果你曾经使用 Javascript，你必须有经验的回调。Javascript 以其内置的异步哲学而闻名。从标准内置模块到其他框架和库，回调无处不在。这就是在 Javascript 中完成异步编程。但是回调有一个黑暗的一面。这叫 Callback Hells。
回调地狱的解决方案是 Promises。而不是通过回调同步返回值或传递结果，我们可以返回一个 Promise，我们将来会返回一些值或错误。 有许多像好的库如 Bluebird 和 Q 可以用来处理 Promise。但是内置的模块和很多其他库不能使用 Promises。这些库能够将传统的回调方法转换为 Promise，在 Node v8 中我们现在可以使用 util.promisify 来处理回调方法。根据 Node.js 的文档： util.promisify(original)
original Returns: const util = require(&amp;#34;util&amp;#34;); const fs = require(&amp;#34;fs&amp;#34;); const stat = util.promisify(fs.stat); stat(&amp;#34;.&amp;#34;) .then((stats) =&amp;gt; { // Do something with `stats` }) .catch((error) =&amp;gt; { // Handle the error. }); 或者; const util = require(&amp;#34;util&amp;#34;); const fs = require(&amp;#34;fs&amp;#34;); const stat = util.</description></item><item><title>node中的多进程</title><link>https://chenkai.life/nodejs/node-child-process/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-child-process/</guid><description>javascript 是单线程的并且只在一个进程中跑，
child_process child_process 模块提供了衍生子进程的能力，此功能主要由 child_process.spawn() 函数提供：
const { spawn } = require(&amp;#34;child_process&amp;#34;); const ls = spawn(&amp;#34;ls&amp;#34;, [&amp;#34;-lh&amp;#34;, &amp;#34;/usr&amp;#34;]); ls.stdout.on(&amp;#34;data&amp;#34;, (data) =&amp;gt; { console.log(`stdout: ${data}`); }); ls.stderr.on(&amp;#34;data&amp;#34;, (data) =&amp;gt; { console.error(`stderr: ${data}`); }); ls.on(&amp;#34;close&amp;#34;, (code) =&amp;gt; { console.log(`子进程退出，使用退出码 ${code}`); }); child_process.spawn() 方法异步地衍生子进程，且不阻塞 Node.js 事件循环。 child_process.spawnSync() 函数则以同步的方式提供了等效的功能，但会阻塞事件循环直到衍生的进程退出或终止。为方便起见， child_process 模块提供了 child_process.spawn() 和 child_process.spawnSync() 的一些同步和异步的替代方法。 这些替代方法中的每一个都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。
[child_process.spawn()]: 方法使用给定的 command 衍生一个新进程，并带上 args 中的命令行参数。 如果省略 args，则其默认为一个空数组。 [child_process.exec()]: 衍生一个 shell 然后在该 shell 中执行 command，并缓冲任何产生的输出。 [child_process.</description></item><item><title>node复用原始接口下载表格</title><link>https://chenkai.life/nodejs/node-download-biaoge-sheji/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-download-biaoge-sheji/</guid><description>我们在做后台开发时可能有很多接口的数据需要下载下来,如果从头开发无疑会有很多重复代码如参数校验、权限验证等，接下来我谈谈我是如何利用现有的 node 接口下载表格
json 数组转表格 一般我们的接口返回的是 json 数组,我们很容易想到只需要把返回数据的 json 转为表格下载就可以了其他逻辑都是一样的，node 有很多现成的库可以处理如xlsx
function frows2XlsxBufferile(formatData) { const ws = xlsx.utils.json_to_sheet(formatData); const wb = xlsx.utils.book_new(); xlsx.utils.book_append_sheet(wb, ws, &amp;#34;SheetJS&amp;#34;); return xlsx.write(wb, { type: &amp;#34;buffer&amp;#34;, bookType: &amp;#34;xlsx&amp;#34; }); } 在 ctx 上下文添加下载文件的方法 默认情况下返回的是文本数据这里需要处理,我这里需要在header中声明返回的内容是一个需要下载的文件
function file(name, data) { // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition // 说明浏览器应该将内容下载到本地；filename 的值预填为下载后的文件名 this.response.set(&amp;#34;Content-disposition&amp;#34;, `attachment;filename=&amp;#34;${name}&amp;#34;`); // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type // 说明返回的是一个二进制流数据 this.response.set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/octet-stream&amp;#34;); return (this.response.body = data); } 返回表格 我们将上面封装下，方便调用,
async download() { const { ctx } = this; const result = await this.</description></item><item><title>node程序放入docker</title><link>https://chenkai.life/nodejs/node-docker/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/node-docker/</guid><description>准备 demo 程序 index.js &amp;#34;use strict&amp;#34;; const express = require(&amp;#34;express&amp;#34;); // Constants const PORT = 6677; const HOST = &amp;#34;0.0.0.0&amp;#34;; // App const app = express(); app.get(&amp;#34;/&amp;#34;, (req, res) =&amp;gt; { res.send(&amp;#34;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&amp;#34;); }); app.listen(PORT, HOST); console.log(`Running on http://${HOST}:${PORT}`); 根目录新建Dockerfile文件 ## 定义我们需要从哪个镜像进行构建 FROM node:8 ## 在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ &amp;#34;node&amp;#34;, &amp;#34;index.js&amp;#34; ] .dockerignore 文件 这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中 node_modules npm-debug.</description></item></channel></rss>