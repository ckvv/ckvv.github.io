<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>koa on CK's Blog</title><link>https://chenkai.life/tags/koa/</link><description>Recent content in koa on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 17 Aug 2021 11:09:03 +0000</lastBuildDate><atom:link href="https://chenkai.life/tags/koa/index.xml" rel="self" type="application/rss+xml"/><item><title>koa跨域</title><link>https://chenkai.life/nodejs/koa%E8%B7%A8%E5%9F%9F/</link><pubDate>Tue, 17 Aug 2021 11:09:03 +0000</pubDate><guid>https://chenkai.life/nodejs/koa%E8%B7%A8%E5%9F%9F/</guid><description>跨域 为什么会有跨域问题？ 这是浏览器的同源策略所造成的，同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
一定要注意跨域是浏览器的限制，其实你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。
如何解决跨域? jsonp: 带有src属性的标签都可以用来， 但是只能处理GET请求 document.domain + iframe跨域 location.hash + iframe window.name + iframe postMessage跨域 Nginx配置反向代理 CORS（跨域资源共享）：支持所有类型的HTTP请求 相信大家对于以上的解决方法都很熟悉，这里不再对每一种方法展开讲解，接下来主要讲一下CORS； 简单请求和非简单请求 浏览器将CORS跨域请求分为简单请求和非简单请求；
如果你使用nginx反向代理解决的跨域问题，则不会有跨域请求这个说法了，因为nginx反向代理就使得前后端是同一个域了，就不存在跨域问题了。
只要同时满足一下两个条件，就属于简单请求 (1)使用下列方法之一：
head get post (2)请求的Heder是
Accept Accept-Language Content-Language Content-Type: 只限于三个值： application/x-www-form-urlencoded multipart/form-data text/plain 不同时满足上面的两个条件，就属于非简单请求。 浏览器对这两种的处理，是不一样的。
简单请求 例子 对于简单请求，浏览器直接发出CORS请求。具体来说，就是头信息之中，增加一个Origin字段。</description></item><item><title>koa中间件源码解析</title><link>https://chenkai.life/nodejs/koa_middleware_analys/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://chenkai.life/nodejs/koa_middleware_analys/</guid><description>中间件是koa的核心，koa的中间件机制是一个剥洋葱式的模型，多个中间件通过use放进一个数组队列然后从外层开始执行，遇到next后进入队列中的下一个中间件，所有中间件执行完后开始回帧，执行队列中之前中间件中未执行的代码部分。
源码 koa在koa-compose中实现了中间件部分，
function compose (middleware) { // compose首先会对middleware进行参数检验，middleware必须是一个函数数组， if (!Array.isArray(middleware)) throw new TypeError(&amp;#39;Middleware stack must be an array!&amp;#39;) for (const fn of middleware) { if (typeof fn !== &amp;#39;function&amp;#39;) throw new TypeError(&amp;#39;Middleware must be composed of functions!&amp;#39;) } /** * @param {Object} context * @return {Promise} * @api public */ return function (context, next) { // last called middleware # let index = -1 return dispatch(0) async function dispatch (i) { // 多次调用next函数会导致1 &amp;lt;= index if (i &amp;lt;= index) return Promise.</description></item></channel></rss>