<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Koa on CK's Blog</title><link>https://chenkai.life/tags/koa/</link><description>Recent content in Koa on CK's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 05 Jul 2024 16:17:27 +0800</lastBuildDate><atom:link href="https://chenkai.life/tags/koa/index.xml" rel="self" type="application/rss+xml"/><item><title>koa中间件源码解析</title><link>https://chenkai.life/nodejs/koa-middleware-analys/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/koa-middleware-analys/</guid><description>中间件是koa的核心，koa的中间件机制是一个剥洋葱式的模型，多个中间件通过use放进一个数组队列然后从外层开始执行，遇到next后进入队列中的下一个中间件，所有中间件执行完后开始回帧，执行队列中之前中间件中未执行的代码部分。
源码 koa在koa-compose中实现了中间件部分，
function compose (middleware) { // compose首先会对middleware进行参数检验，middleware必须是一个函数数组， if (!Array.isArray(middleware)) throw new TypeError(&amp;#39;Middleware stack must be an array!&amp;#39;) for (const fn of middleware) { if (typeof fn !== &amp;#39;function&amp;#39;) throw new TypeError(&amp;#39;Middleware must be composed of functions!&amp;#39;) } /** * @param {Object} context * @return {Promise} * @api public */ return function (context, next) { // last called middleware # let index = -1 return dispatch(0) async function dispatch (i) { // 多次调用next函数会导致1 &amp;lt;= index if (i &amp;lt;= index) return Promise.</description></item><item><title>koa跨域</title><link>https://chenkai.life/nodejs/koa-cross-domain/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/nodejs/koa-cross-domain/</guid><description>跨域 为什么会有跨域问题？ 这是浏览器的同源策略所造成的，同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
一定要注意跨域是浏览器的限制，其实你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。
如何解决跨域? jsonp: 带有src属性的标签都可以用来， 但是只能处理GET请求 document.domain + iframe跨域 location.hash + iframe window.name + iframe postMessage跨域 Nginx配置反向代理 CORS（跨域资源共享）：支持所有类型的HTTP请求 相信大家对于以上的解决方法都很熟悉，这里不再对每一种方法展开讲解，接下来主要讲一下CORS； 简单请求和非简单请求 浏览器将CORS跨域请求分为简单请求和非简单请求；
如果你使用nginx反向代理解决的跨域问题，则不会有跨域请求这个说法了，因为nginx反向代理就使得前后端是同一个域了，就不存在跨域问题了。
只要同时满足一下两个条件，就属于简单请求 (1)使用下列方法之一：
head get post (2)请求的Heder是
Accept Accept-Language Content-Language Content-Type: 只限于三个值： application/x-www-form-urlencoded multipart/form-data text/plain 不同时满足上面的两个条件，就属于非简单请求。 浏览器对这两种的处理，是不一样的。
简单请求 例子 对于简单请求，浏览器直接发出CORS请求。具体来说，就是头信息之中，增加一个Origin字段。
上面这个例子，post``Content-Type``application/x-www-form-urlencoded``Access-Control-Allow-Origin: http://127.0.0.1:3000``Origin``Origin
CORS请求相关的字段，都以 Access-Control-开头 Access-Control-Allow-Origin
：必选
请求头Origin字段的值 *：接受任何域名 Access-Control-Allow-Credentials
：可选，
true: 表示允许发送cookie，此时Access-Control-Allow-Origin不能设置为*，必须指定明确的，与请求网页一致的域名。 不设置该字段：不需要浏览器发送cookie Access-Control-Expose-Headers
：可选
响应报头指示哪些报头可以公开为通过列出他们的名字的响应的一部分。默认情况下，只显示6个简单的响应标头： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 如果想要让客户端可以访问到其他的首部信息，可以将它们在 Access-Control-Expose-Headers 里面列出来。 withCredentials 属性 CORS请求默认不发送Cookie和HTTP认证信息，如果要把Cookie发到服务器，一方面需要服务器同意，设置响应头Access-Control-Allow-Credentials: true,另一方面在客户端发出请求的时候也要进行一些设置;</description></item></channel></rss>