<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>webpack on CK's Blog</title><link>https://chenkai.life/tags/webpack/</link><description>Recent content in webpack on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://chenkai.life/tags/webpack/index.xml" rel="self" type="application/rss+xml"/><item><title>webpack总结</title><link>https://chenkai.life/posts/webpack/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/webpack/</guid><description>loader webpack 可以使用 loader 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。你可以使用 Node.js 来很简单地编写自己的 loader。loader 通过在 require() 语句中使用 loadername! 前缀来激活，或者通过 webpack 配置中的正则表达式来自动应用;
import Worker from &amp;#39;worker-loader!./Worker.js&amp;#39;; // 或者 { module: { rules: [ { test: /\.worker\.js$/, use: { loader: &amp;#39;worker-loader&amp;#39; } } ] } } 懒加载 代码分离 shimming 一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 $）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 shimming 发挥作用的地方。 使用 ProvidePlugin 后，能够在通过 webpack 编译的每个模块中，通过访问一个变量来获取到 package 包。如果 webpack 知道这个变量在某个模块中被使用了，那么 webpack 将在最终 bundle 中引入我们给定的 package。 本质上，我们所做的，就是告诉 webpack……</description></item></channel></rss>