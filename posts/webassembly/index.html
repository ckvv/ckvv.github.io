<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=description content="WebAssembly是什么    WebAssembly是为高效执行和紧凑表示而设计的运行在现代处理器（包括浏览器）中的一种快速、安全、可移植的底层代码格式，具有紧凑的二进制格式，可以以接近本机的性能运行。2019年12月5日W3C宣布WebAssembly核心规范成为正式标准。名字上可以知道是给Web使用的汇编语言。但是WebAssembly并不是直接用汇编语言，而提供了转换机制（LLVM IR），把高级别的语言（AssemblyScript、go、C、C++、Rust等）编译为WebAssembly，以便有机会通过Web浏览器执行低级二进制语法 。
WebAssembl的特点    WebAssembly是一门不同于JavaScript的语言，它不是用来取代JavaScript的。相反，它被设计为和JavaScript一起协同工作，从而使得网络开发者能够利用两种语言的优势，通过使用WebAssembly的JavaScriptAPI，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。
 快速：大幅度提高 Javascript 的性能，以接近本机的代码性能执行。 安全：代码经过验证并在内存安全沙盒环境中执行，可防止数据损坏或安全漏洞。 与语言无关：允许任何语言编译到WebAssembly， 可以用其他高级语言写网页。 与硬件无关：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。 与平台无关：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。 紧凑：具有比典型的文本或本机代码格式小的传输速度快的二进制格式。 模块化：程序可以分成较小的部分，可以分别传输，缓存和使用。 高效：可以通过快速一次通过来解码，验证和编译，等同于实时（JIT）或提前（AOT）编译。 Streamable：允许在看到所有数据之前尽快开始解码，验证和编译。  为什么WebAssembly比JavaScript 执行效率更高    WebAssembly最吸引人的特点便是它的执行效率，比JavaScript执行效率更高主要有以下原因：
 文件获取阶段：WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段：WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段：WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段：WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码<->重优化”现象。 执行阶段：WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。  如何使用WebAssembly    高级语言编译到 .wasm 文件    WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。 想要编译成WebAssembly，你首先需要先编译 LLVM，参考webassembly."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="WebAssembly上手"><meta name=twitter:description content="WebAssembly是什么    WebAssembly是为高效执行和紧凑表示而设计的运行在现代处理器（包括浏览器）中的一种快速、安全、可移植的底层代码格式，具有紧凑的二进制格式，可以以接近本机的性能运行。2019年12月5日W3C宣布WebAssembly核心规范成为正式标准。名字上可以知道是给Web使用的汇编语言。但是WebAssembly并不是直接用汇编语言，而提供了转换机制（LLVM IR），把高级别的语言（AssemblyScript、go、C、C++、Rust等）编译为WebAssembly，以便有机会通过Web浏览器执行低级二进制语法 。
WebAssembl的特点    WebAssembly是一门不同于JavaScript的语言，它不是用来取代JavaScript的。相反，它被设计为和JavaScript一起协同工作，从而使得网络开发者能够利用两种语言的优势，通过使用WebAssembly的JavaScriptAPI，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。
 快速：大幅度提高 Javascript 的性能，以接近本机的代码性能执行。 安全：代码经过验证并在内存安全沙盒环境中执行，可防止数据损坏或安全漏洞。 与语言无关：允许任何语言编译到WebAssembly， 可以用其他高级语言写网页。 与硬件无关：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。 与平台无关：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。 紧凑：具有比典型的文本或本机代码格式小的传输速度快的二进制格式。 模块化：程序可以分成较小的部分，可以分别传输，缓存和使用。 高效：可以通过快速一次通过来解码，验证和编译，等同于实时（JIT）或提前（AOT）编译。 Streamable：允许在看到所有数据之前尽快开始解码，验证和编译。  为什么WebAssembly比JavaScript 执行效率更高    WebAssembly最吸引人的特点便是它的执行效率，比JavaScript执行效率更高主要有以下原因：
 文件获取阶段：WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段：WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段：WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段：WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码<->重优化”现象。 执行阶段：WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。  如何使用WebAssembly    高级语言编译到 .wasm 文件    WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。 想要编译成WebAssembly，你首先需要先编译 LLVM，参考webassembly."><meta property="og:title" content="WebAssembly上手"><meta property="og:description" content="WebAssembly是什么    WebAssembly是为高效执行和紧凑表示而设计的运行在现代处理器（包括浏览器）中的一种快速、安全、可移植的底层代码格式，具有紧凑的二进制格式，可以以接近本机的性能运行。2019年12月5日W3C宣布WebAssembly核心规范成为正式标准。名字上可以知道是给Web使用的汇编语言。但是WebAssembly并不是直接用汇编语言，而提供了转换机制（LLVM IR），把高级别的语言（AssemblyScript、go、C、C++、Rust等）编译为WebAssembly，以便有机会通过Web浏览器执行低级二进制语法 。
WebAssembl的特点    WebAssembly是一门不同于JavaScript的语言，它不是用来取代JavaScript的。相反，它被设计为和JavaScript一起协同工作，从而使得网络开发者能够利用两种语言的优势，通过使用WebAssembly的JavaScriptAPI，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。
 快速：大幅度提高 Javascript 的性能，以接近本机的代码性能执行。 安全：代码经过验证并在内存安全沙盒环境中执行，可防止数据损坏或安全漏洞。 与语言无关：允许任何语言编译到WebAssembly， 可以用其他高级语言写网页。 与硬件无关：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。 与平台无关：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。 紧凑：具有比典型的文本或本机代码格式小的传输速度快的二进制格式。 模块化：程序可以分成较小的部分，可以分别传输，缓存和使用。 高效：可以通过快速一次通过来解码，验证和编译，等同于实时（JIT）或提前（AOT）编译。 Streamable：允许在看到所有数据之前尽快开始解码，验证和编译。  为什么WebAssembly比JavaScript 执行效率更高    WebAssembly最吸引人的特点便是它的执行效率，比JavaScript执行效率更高主要有以下原因：
 文件获取阶段：WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段：WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段：WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段：WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码<->重优化”现象。 执行阶段：WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。  如何使用WebAssembly    高级语言编译到 .wasm 文件    WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。 想要编译成WebAssembly，你首先需要先编译 LLVM，参考webassembly."><meta property="og:type" content="article"><meta property="og:url" content="https://chenkai.life/posts/webassembly/"><meta property="article:published_time" content="2021-07-09T15:37:56+08:00"><meta property="article:modified_time" content="2021-07-09T15:37:56+08:00"><title>WebAssembly上手 · CK's Blog</title><link rel=canonical href=https://chenkai.life/posts/webassembly/><link rel=stylesheet href=/css/coder.min.0e0f0ac9929898ae6625ca3789e3f9e2e630ead0a5e0f1fe96c1ba7d8774342c.css integrity="sha256-Dg8KyZKYmK5mJco3ieP54uYw6tCl4PH+lsG6fYd0NCw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.ffed55576b1fe8cd1a532c3c9691900c09813ce5a8e0fbf58a6e377169305cf3.css integrity="sha256-/+1VV2sf6M0aUyw8lpGQDAmBPOWo4Pv1im43cWkwXPM=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.72.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><span id=dark-mode-toggle class=colorscheme-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-anheimoshi"/></svg></span></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>CK's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><svg class="icon" aria-hidden="true"><use xlink:href="#icon-caidan"/></svg></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/>Home</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/index.xml>RSS</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item id=search-content><input class=search-int type=text placeholder=Search>
<button class=search-btn data-type=google>Google</button>
<button class=search-btn data-type=github>GitHub</button></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://chenkai.life/posts/webassembly/>WebAssembly上手</a></h1><div class=edit-link style=float:right;color:#0366d6><a class=title target=_blank href=https://github.com/chenkai0520/chenkai0520.github.io/edit/main/content/posts/WebAssembly.md>编辑</a></div></div><div class=post-meta><div class=date><span class=posted-on><svg class="icon" aria-hidden="true"><use xlink:href="#icon-date"/></svg><time datetime=2021-07-09T15:37:56+08:00>2021-07-09</time></span></div><div class=tags><svg class="icon" aria-hidden="true"><use xlink:href="#icon-biaoqian"/></svg><span class=tag><a href=/tags/%E6%96%87%E7%AB%A0/>文章</a></span></div></div></header><div><h1 id=webassembly是什么>WebAssembly是什么
<a class=heading-link href=#webassembly%e6%98%af%e4%bb%80%e4%b9%88><i class="fa fa-link" aria-hidden=true></i></a></h1><p>WebAssembly是为高效执行和紧凑表示而设计的运行在现代处理器（包括浏览器）中的一种快速、安全、可移植的底层代码格式，具有紧凑的二进制格式，可以以接近本机的性能运行。2019年12月5日W3C宣布WebAssembly核心规范成为正式标准。名字上可以知道是给Web使用的汇编语言。但是WebAssembly并不是直接用汇编语言，而提供了转换机制（LLVM IR），把高级别的语言（AssemblyScript、go、C、C++、Rust等）编译为WebAssembly，以便有机会通过Web浏览器执行低级二进制语法 。</p><h1 id=webassembl的特点>WebAssembl的特点
<a class=heading-link href=#webassembl%e7%9a%84%e7%89%b9%e7%82%b9><i class="fa fa-link" aria-hidden=true></i></a></h1><p>WebAssembly是一门不同于JavaScript的语言，它不是用来取代JavaScript的。相反，它被设计为和JavaScript一起协同工作，从而使得网络开发者能够利用两种语言的优势，通过使用WebAssembly的JavaScriptAPI，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。</p><ul><li>快速：大幅度提高 Javascript 的性能，以接近本机的代码性能执行。</li><li>安全：代码经过验证并在内存安全沙盒环境中执行，可防止数据损坏或安全漏洞。</li><li>与语言无关：允许任何语言编译到WebAssembly， 可以用其他高级语言写网页。</li><li>与硬件无关：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。</li><li>与平台无关：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。</li><li>紧凑：具有比典型的文本或本机代码格式小的传输速度快的二进制格式。</li><li>模块化：程序可以分成较小的部分，可以分别传输，缓存和使用。</li><li>高效：可以通过快速一次通过来解码，验证和编译，等同于实时（JIT）或提前（AOT）编译。</li><li>Streamable：允许在看到所有数据之前尽快开始解码，验证和编译。</li></ul><h1 id=为什么webassembly比javascript-执行效率更高>为什么WebAssembly比JavaScript 执行效率更高
<a class=heading-link href=#%e4%b8%ba%e4%bb%80%e4%b9%88webassembly%e6%af%94javascript-%e6%89%a7%e8%a1%8c%e6%95%88%e7%8e%87%e6%9b%b4%e9%ab%98><i class="fa fa-link" aria-hidden=true></i></a></h1><p>WebAssembly最吸引人的特点便是它的执行效率，比JavaScript执行效率更高主要有以下原因：</p><ul><li>文件获取阶段：WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小；</li><li>解析阶段：WebAssembly 的解码时间比 JavaScript 的解析时间更短；</li><li>编译和优化阶段：WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。</li><li>重优化阶段：WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码&lt;->重优化”现象。</li><li>执行阶段：WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。</li><li>垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。</li></ul><h1 id=如何使用webassembly>如何使用WebAssembly
<a class=heading-link href=#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8webassembly><i class="fa fa-link" aria-hidden=true></i></a></h1><h2 id=高级语言编译到-wasm-文件>高级语言编译到 .wasm 文件
<a class=heading-link href=#%e9%ab%98%e7%ba%a7%e8%af%ad%e8%a8%80%e7%bc%96%e8%af%91%e5%88%b0-wasm-%e6%96%87%e4%bb%b6><i class="fa fa-link" aria-hidden=true></i></a></h2><p>WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。 想要编译成WebAssembly，你首先需要先编译 LLVM，参考<a href=http://webassembly.org.cn/getting-started/developers-guide/>webassembly.org.</a> LLVM可以实现</p><ul><li>LLVM IR 到不同 CPU 架构机器码的生成；</li><li>机器码编译时性能和大小优化。</li></ul><p>LLVM实现了LLVM IR 到 WebAssembly 字节码的编译功能，也就是说只要高级语言能转换成 LLVM IR，就能被编译成 WebAssembly字节码，目前能编译成WebAssembly主要包括C、C++、Rust、Go、AssemblyScript（类似TypeScript）等。</p><p>对前端来说使用AssemblyScript是最为简单的办法，AssemblyScript和TypeScript有细微区别，为了方便编译成WebAssembly在TypeScript的基础上加了更严格的类型限制，AssemblyScript的实现原理其实也借助了LLVM，它通过TypeScript编译器把TS源码解析成AST，再把AST翻译成IR，再通过LLVM编译成WebAssembly字节码实现；与现有的Web生态系统集成-无需设置繁重的工具链。只需npm安装它，通过asc把assemblyscript编译为WebAssembly。</p><p>安装参考<a href=https://www.assemblyscript.org/quick-start.html>assemblyscript</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>npm init

npm install --save @assemblyscript/loader
npm install --save-dev assemblyscript

//创建推荐的目录结构和配置文件
npx asinit .

</code></pre></div><p>原始assemblyscript，导出一个获取第n个素数的函数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>/**
</span><span style=color:#75715e> * 判断一个数是否是素数
</span><span style=color:#75715e> * @param x 
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isPrime</span>(<span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>u32</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>bool</span> {
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
  }

  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>x</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>x</span> <span style=color:#f92672>%</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
    }
  }

  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
}

<span style=color:#75715e>/**
</span><span style=color:#75715e> * 获取第n个素数
</span><span style=color:#75715e> * @param x 
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getPrime</span>(<span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>u32</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>number</span> {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>index</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
  <span style=color:#66d9ef>do</span> {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isPrime</span>(<span style=color:#a6e22e>i</span>)) {
      <span style=color:#f92672>++</span><span style=color:#a6e22e>index</span>;
    }
    <span style=color:#f92672>++</span><span style=color:#a6e22e>i</span>;
  } <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>index</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>x</span>);

  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
}

</code></pre></div><p>对应js代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>/**
</span><span style=color:#75715e> * 判断一个数是否是素数
</span><span style=color:#75715e> * @param x 
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isPrime</span>(<span style=color:#a6e22e>x</span>) {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
    }
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>x</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>x</span> <span style=color:#f92672>%</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }
    }
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
}


<span style=color:#75715e>/**
</span><span style=color:#75715e> * 获取第n个素数
</span><span style=color:#75715e> * @param x 
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getPrime</span>(<span style=color:#a6e22e>x</span>) {
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>do</span> {
        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isPrime</span>(<span style=color:#a6e22e>i</span>)) {
            <span style=color:#f92672>++</span><span style=color:#a6e22e>index</span>;
        }
        <span style=color:#f92672>++</span><span style=color:#a6e22e>i</span>;
        <span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;hello&#39;</span>)
    } <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>index</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>x</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
}

</code></pre></div><p>编译成WebAssembly</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>asc assembly/index.ts -b build/optimized.wasm

</code></pre></div><h2 id=浏览器中加载wasm模块到javascript>浏览器中加载wasm模块到JavaScript
<a class=heading-link href=#%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%ad%e5%8a%a0%e8%bd%bdwasm%e6%a8%a1%e5%9d%97%e5%88%b0javascript><i class="fa fa-link" aria-hidden=true></i></a></h2><p>在<a href=http://webassembly.org.cn/docs/future-features/>未来计划</a>中， WebAssembly模块可以使用 ES6 模块(使用<code>&lt;script type="module"></code>)加载，WebAssembly 目前只能通过 JavaScript 来加载和编译。基础的加载，只需要3步： 1.获取 .wasm 二进制文件，将它转换成类型数组或者 ArrayBuffer 2.将二进制数据编译成一个 WebAssembly.Module 3.使用 imports 实例化这个 WebAssembly.Module，获取 exports</p><p>获取到WebAssembly实例后就可以通过JS去调用了。浏览器提供WebAssemblyAPI编译WebAssembly</p><ul><li>WebAssembly.compile() 编译WebAssembly二进制代码</li><li>WebAssembly.compileStreaming() 从原始字节码编译WebAssembly二进制代码</li><li>WebAssembly.instantiate() 允许你编译和实例化 WebAssembly 代码</li><li>WebAssembly.instantiateStreaming()直接从流式底层源编译和实例化WebAssembly模块。这是加载wasm代码一种非常有效的优化方式</li></ul><p>浏览器中编译获取WebAssembly实例</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>(<span style=color:#a6e22e>async</span> () =&gt; {
    
    <span style=color:#75715e>//包含一些想要导入到新创建Instance中值的对象，导入外部api供内部调用
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>importObject</span> <span style=color:#f92672>=</span> {
        <span style=color:#a6e22e>env</span><span style=color:#f92672>:</span> {
            <span style=color:#a6e22e>abort</span>(<span style=color:#a6e22e>_msg</span>, <span style=color:#a6e22e>_file</span>, <span style=color:#a6e22e>line</span>, <span style=color:#a6e22e>column</span>) {
                <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;abort called at index.ts:&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>line</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>column</span>);
            },
            <span style=color:#a6e22e>console</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>console</span>
        },
    };
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>module</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>WebAssembly</span>.<span style=color:#a6e22e>instantiateStreaming</span>(
        <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#34;./build/optimized.wasm&#34;</span>),
        <span style=color:#a6e22e>importObject</span>
    );
    
    <span style=color:#75715e>//获取导出的模块
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>instance</span>.<span style=color:#66d9ef>export</span>.<span style=color:#a6e22e>getPrime</span>
})();

</code></pre></div><p>浏览器中js和webassembly计算素数效率对比，横轴是第n个素数，纵轴是计算所需时间（ms），从结果中我们可以看出可以看出webassembly的销量是明显高于js的,</p><blockquote><p>效率对比并不固定，不同函数，不同功能会有差别</p><p><img src=https://user-gold-cdn.xitu.io/2020/6/14/172b1f244327b0ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt=js和webassembly计算素数效率对比></p></blockquote><h1 id=不止于浏览器>不止于浏览器
<a class=heading-link href=#%e4%b8%8d%e6%ad%a2%e4%ba%8e%e6%b5%8f%e8%a7%88%e5%99%a8><i class="fa fa-link" aria-hidden=true></i></a></h1><p>WebAssembly 作为一种底层字节码，除了能在浏览器中运行外，还能在其它环境运行</p><h2 id=直接执行-wasm-二进制文件>直接执行 wasm 二进制文件
<a class=heading-link href=#%e7%9b%b4%e6%8e%a5%e6%89%a7%e8%a1%8c-wasm-%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6><i class="fa fa-link" aria-hidden=true></i></a></h2><p>前面提到的 Binaryen 提供了在命令行中直接执行 wasm 二进制文件的工具，在 Mac 系统下通过 brew install binaryen 安装成功后，通过 wasm-shell f.wasm 文件即可直接运行</p><h2 id=node中加载wasm模块>node中加载wasm模块
<a class=heading-link href=#node%e4%b8%ad%e5%8a%a0%e8%bd%bdwasm%e6%a8%a1%e5%9d%97><i class="fa fa-link" aria-hidden=true></i></a></h2><p>目前 V8 JS 引擎已经添加了对 WebAssembly 的支持，V8 JS 引擎在运行 WebAssembly 时，WebAssembly 和 JS 是在同一个虚拟机中执行，而不是 WebAssembly 在一个单独的虚拟机中运行，这样方便实现 JS 和 WebAssembly 之间的相互调用，在 Nodejs 环境中运行 WebAssembly 的意义其实不大，原因在于 Nodejs 支持运行原生模块，而原生模块的性能比 WebAssembly 要好。 如果你是通过 C、Rust 去编写 WebAssembly，你可以直接编译成 Nodejs 可以调用的原生模块。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;fs&#34;</span>);
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>loader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;@assemblyscript/loader&#34;</span>);
<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loader</span>.<span style=color:#a6e22e>instantiateSync</span>(<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFileSync</span>(<span style=color:#a6e22e>__dirname</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/build/optimized.wasm&#34;</span>), { <span style=color:#75715e>/* imports */</span> })

</code></pre></div><p>WebAssembly的设计初衷之一是为了解决JavaScript的性能问题，使得Web网页应用有接近本机原生应用的性能。作为一个通用、开放、高效的底层虚拟机抽象，众多编程语言（如C/C++,Rust,等）可以将现有应用编译成为WASM的目标代码，运行在浏览器中。这让应用开发技术与运行时技术解耦，极大促进了代码复用。</p><p>最后献上Docker创始人Solomon Hykes在WASI发布之际的一句Twitter</p><p><img src=https://user-gold-cdn.xitu.io/2020/6/14/172b206346be96ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt=img></p></div><footer></footer><div id=vcomments></div></article></section></div></main><script src=/js/coder.min.a350362441276ec5c1671926420497bb8e52b63ead1d51d3c9bc4342d0039526.js integrity="sha256-o1A2JEEnbsXBZxkmQgSXu45Stj6tHVHTybxDQtADlSY="></script><script src=/js/custom.js></script><script src=/js/font.min.js></script></body></html>