<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on CK's Blog</title><link>https://chenkai.life/posts/</link><description>Recent content in Posts on CK's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 08 Dec 2021 18:05:32 +0800</lastBuildDate><atom:link href="https://chenkai.life/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>使用koa创建基于http2的服务</title><link>https://chenkai.life/posts/koa-http2/</link><pubDate>Wed, 08 Dec 2021 18:05:32 +0800</pubDate><guid>https://chenkai.life/posts/koa-http2/</guid><description>使用koa创建服务 使用koa我们可以很容易创建一个http服务
const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.body = &amp;#39;Hello World&amp;#39;; }); app.listen(3000); 其中app.listen(...) 方法只是以下内容的糖：
const http = require(&amp;#39;http&amp;#39;); const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.body = &amp;#39;Hello World&amp;#39;; }); http.createServer(app.callback()).listen(3000) 创建一个http2服务 想当然的我们可能会首先尝试使用一下代码创建一个http2服务
const http2 = require(&amp;#39;http2&amp;#39;); const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); app.use(async ctx =&amp;gt; { ctx.</description></item><item><title>深入理解UUID</title><link>https://chenkai.life/posts/uuid-understand/</link><pubDate>Tue, 07 Dec 2021 15:24:55 +0800</pubDate><guid>https://chenkai.life/posts/uuid-understand/</guid><description>UUID是什么 UUID(Universally unique identifier)[https://en.wikipedia.org/wiki/Universally_unique_identifier] 是一种唯一的字符串，用来标识一个设备或一个应用程序的唯一性。根据标准方法生成时，UUID 出于实用目的是唯一的。与大多数其他编号方案不同，它们的唯一性不依赖于中央注册机构或生成它们的各方之间的协调。虽然UUID 被复制的概率不是零，但它足够接近零，可以忽略不计.
UUID是固定长度128位，表示为 32 个十六进制（base-16）数字，显示在由连字符分隔的五组中，格式为 8-4-4-4-12 总共 36 个字符（32 个十六进制字符和 4 个连字符）例如：
123e4567-e89b-12d3-a456-426614174000 xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
数字的四位M是 UUID 版本（version），数字的 1 到 3 位最高有效位是NUUID的变体（variant），在示例中，M是1，N是a(10xx 2 )，这意味着这是一个version-1、variant-1 的 UUID。
变体（variant） UUID的变体（variant）字段，占1或2或3比特。RFC 4122定义了4种变体：
变体 0 (形如0xxx), 用于向后兼容已经过时的1988年开发的 Apollo 网络计算系统（NCS）1.5 UUID 格式. 变体 1 (形如10xx), 它是按照大端序作为二进制存储与传输 变体 2 (形如110x), 它是按照小端序作为二进制存储与传输 变体 3 (形如111x), 保留未使用 UUID的编码有很多种下面我只介绍Version 4 (random)，
版本（version） 对于“变体（variants）1、2，标准中定义了五个版本（versions），在特定用例中每个版本可能比其他版本更合适。版本由 M 字符串中指示。</description></item><item><title>Github Copilot AI 编程初体验</title><link>https://chenkai.life/posts/github-copilot/</link><pubDate>Tue, 16 Nov 2021 17:00:13 +0800</pubDate><guid>https://chenkai.life/posts/github-copilot/</guid><description>Github Copilot 作为微软与OpenAI共同推出了一款AI编程工具, 通过用户的注释、函数名、等自动生成代码。一直没有觉得噱头大过实际。今天体验了下从结果上来说还是很让人惊艳的。尤其是本篇文章中的部分段落也是Github Copilot补充的。
Github Copilot 如何工作 Github Copilot 通过使用Github上的公共源代码和自然语言作为训练数据，根据自然语言提示生成代码。为了生成代码，GitHub Copilot 会将您正在编辑的部分文件传输到服务器作为上下文。然后该服务使用 OpenAI Codex （基于GPT-3 ）来合成和建议单个行和整个函数。
安装Github Copilot GitHub Copilot 可用作 Neovim、JetBrains 和 Visual Studio Code 的扩展。具体安装过程参考https://github.com/github/copilot-docs
使用Github Copilot 安装完插件之后你只需要像平常那样写代码即可，Github Copilot会在合适的时间和位置对代码进行补全,按tab键进行确认, 你也可以通过其他按键切换其他提示方案并选择合适的方案使用。
上图中高亮部分对代码均为Github Copilot的提示。尤其是下面几段测试代码完全按照我想要的进行提示.
关于Github Copilot的一些问题 Github Copilot推出后关于它的质疑也很多例如:
私有项目代码的安全性 Github Copilot是否会引入恶意代码 Copilot关于公共存储库的培训是否侵犯版权</description></item><item><title>常用的shell命令总结</title><link>https://chenkai.life/posts/commonly-used-shel-command/</link><pubDate>Wed, 10 Nov 2021 18:56:53 +0800</pubDate><guid>https://chenkai.life/posts/commonly-used-shel-command/</guid><description>常用的shell命令
alias用来设置指令的别名 apkAlpine Linux下的包管理工具apk install xxx awk文本和数据进行处理的编程语言 cat连接文件并打印到标准输出设备上 cd切换用户当前工作目录 chmod用来变更文件或目录的权限 chsh用来更换登录系统时使用的shellchsh -s /bin/zsh command调用并执行指定的命令command echo Linux cp将源文件或目录复制到目标文件或目录中cp -r /usr/men /usr/zh crontab提交和管理用户的需要周期性执行的任务 curl利用URL规则在命令行下工作的文件传输工具 curl baidu.com -o baidu.html --progress df显示磁盘的相关信息df -ah diff比较给定的两个文件的不同diff /usr/li test.txt dig域名查询工具dig baidu.com dirs显示目录记录dirs du显示每个文件和目录的磁盘使用空间du -sh ./* echo输出指定的字符串或者变量 egrep在文件内查找指定的字符串与grep类似 env显示系统中已存在的环境变量env exec调用并执行指定的命令 exit退出当前的shell export设置或显示系统环境变量export -p fc修改历史命令并执行fc -l -10 find在指定目录下查找文件find / 'nginx.conf' grep强大的文本搜索工具grep &amp;quot;match_pattern&amp;quot; file_1 file_2 gunzip用来解压缩文件gunzip /opt/etc.zip.gz gzip用来压缩文件gzip -9v ./1.html head在屏幕上显示指定文件的开头若干行head -n 10 CHANGELOG history用于显示历史命令history 100 host常用的分析域名查询工具host chenkai.life htop[非内部命令]一个互动的进程查看器，可以动态观察系统进程状况 iconv转换文件的编码方式iconv file1 -f EUC-JP-MS -t UTF-8 -o file2 ifconfig配置和显示Linux系统网卡的网络参数 kill删除执行中的程序或工作 last列出目前与过去登入系统的用户相关信息 locate文件查找工具,将硬盘中的所有档案和目录资料先建立一个索引数据库locate nginx login登录系统或切换用户身份 logname用来显示用户名称 ls显示目录内容列表ls -alh lsof用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)lsof -i:5577 mkdir用来创建目录mkdir -m 700 /usr/meng/test more显示文件内容，每次显示一屏more -c -10 file mv用来对文件或目录重新命名mv file_1.</description></item><item><title>如何优雅的提示用户需要升级npm依赖包版本？</title><link>https://chenkai.life/posts/npm-deprecate-version/</link><pubDate>Thu, 21 Oct 2021 19:31:14 +0800</pubDate><guid>https://chenkai.life/posts/npm-deprecate-version/</guid><description>背景 某次更新@ckpack/vue-color时引入了严重bug，影响的版本是&amp;gt;=1.0.0,&amp;lt;=1.1.3，并在1.1.4中修复了该问题，问题来了，如何优雅的提示安装该包的人需要升级1.1.4版本呢？
解决办法 首先想到的是百度、谷歌没有，但是找到🤷‍♂️ 哪就看看npm有哪些命令吧npm help access, adduser, audit, bin, bugs, cache, ci, completion, config, dedupe, deprecate, diff, dist-tag, docs, doctor, edit, exec, explain, explore, find-dupes, fund, get, help, hook, init, install, install-ci-test, install-test, link, ll, login, logout, ls, org, outdated, owner, pack, ping, pkg, prefix, profile, prune, publish, rebuild, repo, restart, root, run-script, search, set, set-script, shrinkwrap, star, stars, start, stop, team, test, token, uninstall, unpublish, unstar, update, version, view, whoami 直觉告诉我用unpublish，npm help unpublish 试试, 帮助信息中有一句 Warning Consider using the npm help deprecate command instead, if your intent is to encourage users to upgrade, or if you no longer want to maintain a package.</description></item><item><title>你不知道的package.json</title><link>https://chenkai.life/posts/you-dont-konw-package-json/</link><pubDate>Fri, 15 Oct 2021 13:41:53 +0800</pubDate><guid>https://chenkai.life/posts/you-dont-konw-package-json/</guid><description>engines 描述模块的兼容性如:
指定模块运行的node版本
{ &amp;#34;engines&amp;#34;: { &amp;#34;node&amp;#34;: &amp;#34;&amp;gt;=0.10.3 &amp;lt;15&amp;#34; } } 指定模块运行的npm版本
{ &amp;#34;engines&amp;#34;: { &amp;#34;npm&amp;#34;: &amp;#34;~1.0.20&amp;#34; } } 禁止使用yarn
{ &amp;#34;engines&amp;#34;: { &amp;#34;yarn&amp;#34;: &amp;#34;please use npm&amp;#34; } } files 指定发布到npm中的文件,默认是所有文件[&amp;quot;*&amp;quot;] 你也可以通过.npmignore防止某些文件被包含在内，它不会覆盖files字段，但会覆盖其子目录。 如果不存在.npmignore将使用.gitignore替代
一般来说npm上我们只需要发布打包好的文件，对于git则恰好相反我们只需要提交源代码
bin 安装可执行文件 如果你的包都有一个或多个想要安装到 PATH 中的可执行文件，请在package.json中提供一个bin字段，它是命令名到本地文件名的映射。当这个包被全局安装时，该文件将被链接到全局bin所在的位置，因此它可以按名称运行。当这个包作为另一个包的依赖项安装时，该文件将被链接到该包可以直接通过 npm exec 或通过 npm run-script 调用它们时在其他脚本中的名称, 以typescript举例，在package.json文件中存在
{ &amp;#34;bin&amp;#34;: { &amp;#34;tsc&amp;#34;: &amp;#34;./bin/tsc&amp;#34;, &amp;#34;tsserver&amp;#34;: &amp;#34;./bin/tsserver&amp;#34; }, } 全局安装 所以通过全局安装npm install -g typescript 我们可以在命令行中使用tsc命令, 通过which tsc 我们可以查看可执行文件在/Users/chenkai/.</description></item><item><title>记录一些实用、有趣的工具</title><link>https://chenkai.life/posts/some-useful-interesting-tools/</link><pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/some-useful-interesting-tools/</guid><description>博客 文件类型转换 https://editor.method.ac/制作svg Web caniuse查询浏览器对Web标准的支持性 应用 typora markdown编辑器，可以复制html转成markdown Unsplash 通过api获取随机图片 Weekly Visitor Report 获取访问您网站的公司的每周报告 responsively 更快的进行响应式Web开发 在线代码编辑器，更快地创建和共享 Web 应用程序 codesandbox https://codepen.io/ jsfiddle 需要VPN访问 figma Web端的UI设计工具。 学习 the-way-to-go 学习 Go 语言 javascript-info JavaScript 教程学习网站 You-Dont-Know-JS深入研究 JavaScript 语言核心机制的书籍 the-way-to-go_ZH_CNGo入门指南 awesome-interview 剑指前端 Offer</description></item><item><title>记录一些npm库和应用</title><link>https://chenkai.life/posts/npm_packages/</link><pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/npm_packages/</guid><description>记录一些npm库
npm工具库 nodeppt: markdown 生成web ppt
artillery: 负载接口测试
jsdoc,esdoc,documentation:构建js帮助文档
standard-version:使用semver和常规提交消息自动进行版本控制和CHANGELOG生成
Marked:markdown解析成html
markdown-it: markdown解析成html
dockerode: Docker远程API模块. nodemon: 文件更改时重新启动node服务. pm2: 具有内置负载平衡器的 Node.JS 应用程序的生产流程管理器. cypress: 端到端测试框架. eslint:eslint是一个javascript代码检测工具
ngrok: 内网穿透工具
vconsole 可以用于手机端调试查看控制台、网络请求、存储等信息 jsoneditor 基于 Web 查看、编辑、格式化和验证 JSON 的工具. autocannon 用 node 编写的 HTTP 基准测试工具.
axios: 基于Promise的HTTP客户端，用于浏览器和node.js
ws: 简单易用，为Node.js开辟了快速且经过全面测试的Websocket客户端和服务器
nuxtjs: 一个基于 Vue.js 的服务端渲染应用框架
fake-progress: 一个生成假进度的库
diff.js: 一个JavaScript文本diff实现
GraphQL.js:GraphQL的JavaScript参考实现，GraphQL是Facebook创建的API的查询语言。
JSONStream：流读取josn解析
http-proxy-middleware:node.js代理中间件，用于连接，表达和浏览器同步
iconv-lite: 文件编码转换
workerpool: workerpool提供了一种简单的方法来创建工作池，以动态卸载计算并管理专用工作池,runs on node.js, Chrome, Firefox, Opera, Safari, and IE10+.</description></item><item><title>centos安装常用的软件</title><link>https://chenkai.life/posts/yum_install_-software/</link><pubDate>Fri, 09 Jul 2021 16:21:38 +0800</pubDate><guid>https://chenkai.life/posts/yum_install_-software/</guid><description>安装pg 参考官网;
Install the repository RPM: yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm Install the client packages: yum install postgresql11 Optionally install the server packages: yum install postgresql11-server Optionally initialize the database and enable automatic start: /usr/pgsql-11/bin/postgresql-11-setup initdb systemctl enable postgresql-11 systemctl stop postgresql-11 systemctl start postgresql-11 systemctl restart postgresql-11 systemctl status postgresql-11 修改配置允许外部ip访问数据库 修改/var/lib/pgsql/11/data/postgresql.conf #listen_addresses = 'localhost' # what IP address(es) to listen on; 改为 listen_addresses = '*' 修改/var/lib/pgsql/11/data/pg_hba.</description></item><item><title>Base64原理及实现</title><link>https://chenkai.life/posts/base64_yuanli_and_shijian/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/base64_yuanli_and_shijian/</guid><description>base64 Base64是用64个字符来表示数据的方法。Base64要求把每三个8Bit的字节转换为四个6Bit的字节，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。如果要转码数据字节不是3的倍数，最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。 转换后，我们每个字节范围为[00000000-00111111],所以我们可以用一个64码表来得到我们想要的字符串（也就是最终的Base64编码）标准的Base64用[A-Z,a-z,0-9,+,/]64个字符编码。
编码 深入了解base64前，我们需要先了解编码。编码是信息从一种形式或格式转换为另一种形式的过程。计算机中，所有的数据在存储和运算时都使用二进制示，n位二进制组合成2的n次方个不同的信息，给每个信息规定一个具体码组，这种过程叫编码。而具体用哪些二进制数字表示哪个符号，每个人都可以约定自己的一套编码。
如常用的ASCII是由美国国家标准学会制定的一种单字节字符编码，标准ASCII码使用7位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0到9、标点符号。在有的语言中128个符号是不够的，有些编码方案利用字节中闲置的最高位编入新的符号，有的利用两个（GBK等）或更多字节（utf-32等）表示一个符号（汉字）
Base64编码 base64编码过程：
ascii码s133对应的编码115 49 51 51 在内存2进制表示： 01110011 00110001 00110011 00110011 每三组分为6Bit四组 011100 110011 000100 110011 001100 110000 000000 000000 高位补0得到 00011100 00110011 00000100 00110011 00001100 00110000 00000000 00000000 对应十进制 28 51 4 51 12 48 0 0 查对照表 生成base64码czEzMw== base64解码过程：
base64编码过程逆向即为解码
javascript代码实现 Base64 = { _table: [ &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;F&amp;#39;, &amp;#39;G&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;K&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;N&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;P&amp;#39;, &amp;#39;Q&amp;#39;, &amp;#39;R&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;, &amp;#39;g&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;j&amp;#39;, &amp;#39;k&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;q&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;v&amp;#39;, &amp;#39;w&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;z&amp;#39;, &amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;+&amp;#39;, &amp;#39;/&amp;#39; ], _getReg: function () { return RegExp(`^[${this.</description></item><item><title>glob表达式</title><link>https://chenkai.life/posts/glob_expression/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/glob_expression/</guid><description>glob表达式是匹配文件路径的表达式。
glob表达式规则 Matches 0 or more characters in a single path portion ? Matches 1 character [&amp;hellip;] Matches a range of characters, similar to a RegExp range. If the first character of the range is ! or + ^ then it matches any character not in the range. !(pattern|pattern|pattern) Matches anything that does not match any of the patterns provided. ?(pattern|pattern|pattern) Matches zero or one occurrence of the patterns provided.</description></item><item><title>HTTP API 认证授权术</title><link>https://chenkai.life/posts/http-api-renzhengshouquan/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/http-api-renzhengshouquan/</guid><description>转载自https://coolshell.cn/articles/19395.html#coolshell-2
我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公司内去到哪都用这个访客卡来开门，而不再校验你是哪一个人。在计算机的世界里，这个登录凭证的相关数据会放在两种地方，一个地方在用户端，以Cookie的方式（一般不会放在浏览器的Local Storage，因为这很容易出现登录凭证被XSS攻击），另一个地方是放在服务器端，又叫Session的方式（SessonID存于Cookie）。
但是，这个世界还是比较复杂的，除了用户访问，还有用户委托的第三方的应用，还有企业和企业间的调用，这里，我想把业内常用的一些 API认证技术相对系统地总结归纳一下，这样可以让大家更为全面的了解这些技术。注意，这是一篇长文！
本篇文章会覆盖如下技术：
HTTP Basic Digest Access App Secret Key + HMAC JWT – JSON Web Tokens OAuth 1.0 – 3 legged &amp;amp; 2 legged OAuth 2.0 – Authentication Code &amp;amp; Client Credential 目录
HTTP BasicDigest AccessApp Secret Key + HMACJWT – JSON Web TokensOAuth 1.0OAuth 2.0Authorization Code FlowClient Credential Flow小结两个概念和三个术语明白一些初衷相关的注意事项
HTTP Basic HTTP Basic 是一个非常传统的API认证技术，也是一个比较简单的技术。这个技术也就是使用 username和 password 来进行登录。整个过程被定义在了 RFC 2617 中，也被描述在了 Wikipedia: Basic Access Authentication 词条中，同时也可以参看 MDN HTTP Authentication</description></item><item><title>HTTP的前世今生</title><link>https://chenkai.life/posts/http/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/http/</guid><description>转载自https://coolshell.cn/articles/19840.html
HTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会CERN的英国工程师 Tim Berners-Lee v发明的，同时，他也是WWW的发明人，最初的主要是用于传递通过HTML封装过的数据。在1991年发布了HTTP 0.9版，在1996年发布1.0版，1997年是1.1版，1.1版也是到今天为止传输最广泛的版本（初始RFC 2068 在1997年发布， 然后在1999年被 RFC 2616 取代，再在2014年被 RFC 7230 /7231/7232/7233/7234/7235取代），2015年发布了2.0版，其极大的优化了HTTP/1.1的性能和安全性，而2018年发布的3.0版，继续优化HTTP/2，激进地使用UDP取代TCP协议，目前，HTTP/3 在2019年9月26日 被 Chrome，Firefox，和Cloudflare支持，所以我想写下这篇文章，简单地说一下HTTP的前世今生，让大家学到一些知识，并希望可以在推动一下HTTP标准协议的发展。
HTTP 0.9 / 1.0 0.9和1.0这两个版本，就是最传统的 request – response的模式了，HTTP 0.9版本的协议简单到极点，请求时，不支持请求头，只支持 GET 方法，没了。HTTP 1.0 扩展了0.9版，其中主要增加了几个变化：
在请求中加入了HTTP版本号，如：GET /coolshell/index.html HTTP/1.0 HTTP 开始有 header了，不管是request还是response 都有header了。 增加了HTTP Status Code 标识相关的状态码。 还有 Content-Type 可以传输其它的文件了。 我们可以看到，HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：
一个协议有没有版本管理，是一个工程化的象征。 header是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。 Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。 （注：国内很多公司HTTP无论对错只返回200，这种把HTTP Status Code 全部抹掉完全是一种工程界的倒退）</description></item><item><title>redis的五种数据结构及其使用场景</title><link>https://chenkai.life/posts/redis_use_scene/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/redis_use_scene/</guid><description>from https://www.cnblogs.com/ottll/p/9470480.html
String 常用命令：
get、set、incr、decr、mget等
应用场景：
String是最常用的数据类型，普通的key/value都可以归为此类，value其实不仅是String，也可以是数字。
比如想知道什么时候封锁一个IP地址(访问超过几次)。INCRBY命令让这些变得很容易，通过原子递增保持计数。
实现方式：
m,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。
2.Hash
常用命令：
hget、hset、hgetall等
应用场景：
比如我们要存储一个用户的信息，包含以下信息：
用户ID，为查找的key
存储的value用户对象包含姓名name，年龄age，生日birthday 等信息
如果以普通的key/value结构存储，主要有以下两种存储方式：
第一种方式将用户id作为key，其他信息封装成对象以序列化的方式存储，如
set u001 &amp;ldquo;李三,18,20010101&amp;rdquo;
这种方式的缺点，增加了序列化/反序列化的开销；需要修改其中一项信息时，需要把整个对象取回，修改操作需要对并发进行保护，引入CAS等复杂问题。
第二种方式是这个用户信息有多少成员就存成多少个key-value对，用用户id+对应属性名称作为唯一的标识来取得对应属性的值，如：
mset user:001:name &amp;ldquo;李三 &amp;ldquo;user:001:age18 user:001:birthday &amp;ldquo;20010101&amp;rdquo;
虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费较大。
redis提供的hash很好的解决了这个问题，redis的hash实际是内部存储的value为一个HashMap，并且提供了直接存取这个map的成员接口。如
hmset user:001 name &amp;ldquo;李三&amp;rdquo; age 18 birthday &amp;ldquo;20010101&amp;rdquo;
也就是说，key仍然是用户id，value是一个map，这个map的key是成员的属性名，value是属性值。
这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。
实现方式：
Redis的Hash对应的Value内部实际就是一个HashMap，实际有两种不同的实现，如果成员较少时，Redis为了节省内存会采用类似一维数组方式存储，对应的value RedisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap，此时encoding为ht。
3.List
常用命令：
lpush,rpush,lpop,rpop,lrange,BLPOP(阻塞版)等。
应用场景：
最新消息排行。
消息队列。利用Lists的push的操作，将任务存储在list中，然后工作线程再用pop操作将任务取出进行执行。
实现方式：
redis list的实现是一个双向链表，可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，redis内部的很多实现，包括发送缓冲队列等也都用的是这个数据结构。
Set 常用命令：
sadd,srem,spop,sdiff ,smembers,sunion 等。
应用场景：
set类似list，特殊之处是set可以自动排重。
set还提供了某个成员是否在一个set内的接口，这个也是list没有的。
比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。
Redis还为集合提供了求交集、并集、差集等操作。
实现方式：
set内部实现是一个value永远为null的HashMap，实际就是通过hash的方式快速排重的。</description></item><item><title>rewire库</title><link>https://chenkai.life/posts/package_rewire/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/package_rewire/</guid><description>如果模块未导出一些函数，则模块外部的测试代码无法调用该功能。那是由于JavaScript的工作方式，有时我们希望测试局部函数。 rewire库在模块中添加了一个特殊的setter和getter，因此您可以修改它们的行为以进行更好的单元测试 rewire库功能：
为其他模块或全局变量（如进程）注入模拟 测试私有变量 覆盖模块中的变量 rewire接口 rewire(filename: String): rewiredModule Returns a rewired version of the module found at filename. Use rewire() exactly like require().
rewiredModule.__set__(name: String, value: *): Function Sets the internal variable name to the given value. Returns a function which can be called to revert the change.
rewiredModule.__set__(obj: Object): Function Takes all enumerable keys of obj as variable names and sets the values respectively.</description></item><item><title>WebAssembly上手</title><link>https://chenkai.life/posts/webassembly/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/webassembly/</guid><description>WebAssembly是什么 WebAssembly是为高效执行和紧凑表示而设计的运行在现代处理器（包括浏览器）中的一种快速、安全、可移植的底层代码格式，具有紧凑的二进制格式，可以以接近本机的性能运行。2019年12月5日W3C宣布WebAssembly核心规范成为正式标准。名字上可以知道是给Web使用的汇编语言。但是WebAssembly并不是直接用汇编语言，而提供了转换机制（LLVM IR），把高级别的语言（AssemblyScript、go、C、C++、Rust等）编译为WebAssembly，以便有机会通过Web浏览器执行低级二进制语法 。
WebAssembl的特点 WebAssembly是一门不同于JavaScript的语言，它不是用来取代JavaScript的。相反，它被设计为和JavaScript一起协同工作，从而使得网络开发者能够利用两种语言的优势，通过使用WebAssembly的JavaScriptAPI，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。
快速：大幅度提高 Javascript 的性能，以接近本机的代码性能执行。 安全：代码经过验证并在内存安全沙盒环境中执行，可防止数据损坏或安全漏洞。 与语言无关：允许任何语言编译到WebAssembly， 可以用其他高级语言写网页。 与硬件无关：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。 与平台无关：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。 紧凑：具有比典型的文本或本机代码格式小的传输速度快的二进制格式。 模块化：程序可以分成较小的部分，可以分别传输，缓存和使用。 高效：可以通过快速一次通过来解码，验证和编译，等同于实时（JIT）或提前（AOT）编译。 Streamable：允许在看到所有数据之前尽快开始解码，验证和编译。 为什么WebAssembly比JavaScript 执行效率更高 WebAssembly最吸引人的特点便是它的执行效率，比JavaScript执行效率更高主要有以下原因：
文件获取阶段：WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小； 解析阶段：WebAssembly 的解码时间比 JavaScript 的解析时间更短； 编译和优化阶段：WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。 重优化阶段：WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码&amp;lt;-&amp;gt;重优化”现象。 执行阶段：WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。 垃圾回收阶段：WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。 如何使用WebAssembly 高级语言编译到 .wasm 文件 WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行， 但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。 想要编译成WebAssembly，你首先需要先编译 LLVM，参考webassembly.</description></item><item><title>webpack总结</title><link>https://chenkai.life/posts/webpack/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/webpack/</guid><description>loader webpack 可以使用 loader 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。你可以使用 Node.js 来很简单地编写自己的 loader。loader 通过在 require() 语句中使用 loadername! 前缀来激活，或者通过 webpack 配置中的正则表达式来自动应用;
import Worker from &amp;#39;worker-loader!./Worker.js&amp;#39;; // 或者 { module: { rules: [ { test: /\.worker\.js$/, use: { loader: &amp;#39;worker-loader&amp;#39; } } ] } } 懒加载 代码分离 shimming 一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 $）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 shimming 发挥作用的地方。 使用 ProvidePlugin 后，能够在通过 webpack 编译的每个模块中，通过访问一个变量来获取到 package 包。如果 webpack 知道这个变量在某个模块中被使用了，那么 webpack 将在最终 bundle 中引入我们给定的 package。 本质上，我们所做的，就是告诉 webpack……</description></item><item><title>一个关于Promise的问题</title><link>https://chenkai.life/posts/one_question_about_promise/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/one_question_about_promise/</guid><description>一道题带来的疑问 掘金上的一道题： JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个，一个解法如下：
const timeout = (time) =&amp;gt; new Promise(resolve =&amp;gt; { setTimeout(resolve, time) }); class Scheduler { constructor() { this.awaitArr = []; this.count = 0; } async add(promiseCreator) { if (this.count &amp;gt;= 2) { await new Promise(resolve =&amp;gt; { this.awaitArr.push(resolve); }); } this.count++; const res = await promiseCreator(); this.count--; if (this.awaitArr.length) { this.awaitArr.shift()(); } return res; } } const scheduler = new Scheduler() const addTask = (time, order) =&amp;gt; { scheduler.</description></item><item><title>前后端通过切片上传文件</title><link>https://chenkai.life/posts/web_upload_file/</link><pubDate>Fri, 09 Jul 2021 15:37:56 +0800</pubDate><guid>https://chenkai.life/posts/web_upload_file/</guid><description>最近在做前端上传文件，主要包括选择单个｜多个文件、单个｜多个文件夹、拖拽文件｜文件夹方式上传文件，上传时通过分片计算文件hash值实现断点续传、秒传功能，简要介绍下具体实行思路
获取用户选择文件 注意这种方式用到的部分特性是非标准的
拖拽上传 从可拖拽区域中获取过滤获取拖拽的文件的FileSystemEntry
async drop(e) { e.stopPropagation(); e.preventDefault(); let items = e.dataTransfer.items; let dropFilesEntrys = []; for (let item of items) { if (!item || !item.webkitGetAsEntry) continue; item = item.webkitGetAsEntry(); if (!item) continue; let filesEntrys = await this.getFilesEntrys(item); dropFilesEntrys.push(...filesEntrys); } let files = await this.transformFilesEntrys(dropFilesEntrys); this.handerFiles(files); }, 获取FileSystemEntry包含的FilesEntrys，FileSystemEntry可能代表文件系统中的文件或者目录
/** * 获取drop区域的文件 * @returns FilesEntrys */ async getFilesEntrys(item) { let filesEntrys = []; let scanFiles = async (item) =&amp;gt; { return new Promise((resolve) =&amp;gt; { if (item.</description></item></channel></rss>