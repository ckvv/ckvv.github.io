<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on CK's Blog</title><link>https://chenkai.life/posts/</link><description>Recent content in Posts on CK's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 21 Jul 2024 22:39:20 +0800</lastBuildDate><atom:link href="https://chenkai.life/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>CentOS安装常用的软件</title><link>https://chenkai.life/posts/yum-install-software/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/yum-install-software/</guid><description>安装 pg 参考官网;
Install the repository RPM: yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm Install the client packages: yum install postgresql11 Optionally install the server packages: yum install postgresql11-server Optionally initialize the Database and enable automatic start: /usr/pgsql-11/bin/postgresql-11-setup initdb systemctl enable postgresql-11 systemctl stop postgresql-11 systemctl start postgresql-11 systemctl restart postgresql-11 systemctl status postgresql-11 修改配置允许外部 ip 访问数据库 修改/var/lib/pgsql/11/data/postgresql.conf #listen_addresses = &amp;#39;localhost&amp;#39; # what IP address(es) to listen on; 改为 listen_addresses = &amp;#39;*&amp;#39; 修改/var/lib/pgsql/11/data/pg_hba.conf</description></item><item><title>JavaScript脚手架</title><link>https://chenkai.life/posts/js-cli-jiaoshoujia/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/js-cli-jiaoshoujia/</guid><description>什么是脚手架 脚手架是为了保证各施工过程顺利进行而搭设的工作平台。在项目开发中我们把创建项目结构模版的工具也称之为脚手架。如vue-cli，create-react-app等。这些脚手架等原理都一样，即用Node.js命令行程序生成项目模版。
第一个Node.js命令行脚本 编写脚手架其实就是Node.js命令行开发,和写shell脚本类似，使用JavaScript语言，写一个可执行脚本 hello wold过程如下： 新建一个hello文件，其中#!/usr/bin/env node不可少，其作用是它告诉系统这个脚本需要用node解释器来执行，语法与node一样。
#!/usr/bin/env node console.log(&amp;#39;hello world&amp;#39;); 然后,修改的权限
chmod 755 hello 执行脚本
./hello 如果想把 hello 前面的路径去除，可以将 hello 的路径加入环境变量 PATH。但是，另一种更好的做法，是在当前目录下新建 package.json ，写入下面的内容。
{ &amp;#34;name&amp;#34;: &amp;#34;hello&amp;#34;, &amp;#34;bin&amp;#34;: { &amp;#34;hello&amp;#34;: &amp;#34;hello&amp;#34; } } 然后执行 npm link 命令。
npm link 执行脚本
hello 写一个脚手架 脚手架开发与上面过程类似，有一些npm库可以帮助我们开发命令行工具如shelljs、commander，它们封装了node命令行命令可以更方便命令行开发。 文件目录结构
. ├── bin │ └── ckoa.js ├── package-lock.json ├── package.json └── utils └── download.js ckoa.js Node.js命令行
#!/usr/bin/env node const program = require(&amp;#39;commander&amp;#39;) const chalk = require(&amp;#39;chalk&amp;#39;) const downLoad = require(&amp;#39;.</description></item><item><title>了解什么是Polyfill</title><link>https://chenkai.life/posts/polyfill/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/polyfill/</guid><description>什么是 polyfill 初次了解 polyfill 这个词,是在一次面试中，题目是使用数组的reduse方式实现map方法，全世界使用着许多不同的浏览器和版本的浏览器，每个浏览器都具有与其他浏览器完全不同的功能集。这会使浏览器开发成为一项艰巨的任务。流行浏览器的最新版本可以完成许多旧浏览器无法完成的任务-但您可能仍必须支持旧浏览器。通过尝试使用 polyfills 重新创建缺少的功能，Polyfill.io 使支持不同的浏览器变得更简单：您可以在支持或不支持的浏览器中利用最新和最强大的功能。
如 vue 中对 bind 的 polyfill 代码如下
function polyfillBind(fn, ctx) { function boundFn(a) { var l = arguments.length; return l ? l &amp;gt; 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx); } boundFn._length = fn.length; return boundFn; } function nativeBind(fn, ctx) { return fn.bind(ctx); } var bind = Function.prototype.bind ? nativeBind : polyfillBind; 常用对 polyfill 方法 babel-polyfill 提供完整的 ES2015+环境
polyfill.io polyfill.</description></item><item><title>你不知道的package.json</title><link>https://chenkai.life/posts/you-dont-konw-package-json/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/you-dont-konw-package-json/</guid><description>engines 描述模块的兼容性如:
指定模块运行的 node 版本
{ &amp;#34;engines&amp;#34;: { &amp;#34;Node.js&amp;#34;: &amp;#34;&amp;gt;=0.10.3 &amp;lt;15&amp;#34; } } 指定模块运行的 npm 版本
{ &amp;#34;engines&amp;#34;: { &amp;#34;npm&amp;#34;: &amp;#34;~1.0.20&amp;#34; } } 禁止使用 yarn
{ &amp;#34;engines&amp;#34;: { &amp;#34;yarn&amp;#34;: &amp;#34;please use npm&amp;#34; } } files 指定发布到 npm 中的文件,默认是所有文件[&amp;quot;*&amp;quot;] 你也可以通过.npmignore防止某些文件被包含在内，它不会覆盖files字段，但会覆盖其子目录。 如果不存在.npmignore将使用.gitignore替代
一般来说npm上我们只需要发布打包好的文件，对于git则恰好相反我们只需要提交源代码
bin 安装可执行文件 如果你的包都有一个或多个想要安装到 PATH 中的可执行文件，请在package.json中提供一个bin字段，它是命令名到本地文件名的映射。当这个包被全局安装时，该文件将被链接到全局bin所在的位置，因此它可以按名称运行。当这个包作为另一个包的依赖项安装时，该文件将被链接到该包可以直接通过 npm exec 或通过 npm run-script 调用它们时在其他脚本中的名称, 以typescript举例，在package.json文件中存在
{ &amp;#34;bin&amp;#34;: { &amp;#34;tsc&amp;#34;: &amp;#34;./bin/tsc&amp;#34;, &amp;#34;tsserver&amp;#34;: &amp;#34;./bin/tsserver&amp;#34; } } 全局安装 所以通过全局安装npm install -g typescript 我们可以在命令行中使用tsc命令, 通过which tsc 我们可以查看可执行文件在/Users/chenkai/.</description></item><item><title>如何优雅的提示用户需要升级npm依赖包版本？</title><link>https://chenkai.life/posts/npm-deprecate-version/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/npm-deprecate-version/</guid><description>背景 某次更新@ckpack/vue-color时引入了严重bug，影响的版本是&amp;gt;=1.0.0,&amp;lt;=1.1.3，并在1.1.4中修复了该问题，问题来了，如何优雅的提示安装该包的人需要升级1.1.4版本呢？
解决办法 首先想到的是百度、谷歌没有，但是找到🤷‍♂️ 哪就看看npm有哪些命令吧npm help access, adduser, audit, bin, bugs, cache, ci, completion, config, dedupe, deprecate, diff, dist-tag, docs, doctor, edit, exec, explain, explore, find-dupes, fund, get, help, hook, init, install, install-ci-test, install-test, link, ll, login, logout, ls, org, outdated, owner, pack, ping, pkg, prefix, profile, prune, publish, rebuild, repo, restart, root, run-script, search, set, set-script, shrinkwrap, star, stars, start, stop, team, test, token, uninstall, unpublish, unstar, update, version, view, whoami 直觉告诉我用unpublish，npm help unpublish 试试, 帮助信息中有一句 Warning Consider using the npm help deprecate command instead, if your intent is to encourage users to upgrade, or if you no longer want to maintain a package.</description></item><item><title>常用的shell命令总结</title><link>https://chenkai.life/posts/commonly-used-shel-command/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/commonly-used-shel-command/</guid><description>常用的shell命令
alias用来设置指令的别名 apkAlpine Linux下的包管理工具apk install xxx awk文本和数据进行处理的编程语言 cat连接文件并打印到标准输出设备上 cd切换用户当前工作目录 chmod用来变更文件或目录的权限 chsh用来更换登录系统时使用的shellchsh -s /bin/zsh command调用并执行指定的命令command echo Linux cp将源文件或目录复制到目标文件或目录中cp -r /usr/men /usr/zh crontab提交和管理用户的需要周期性执行的任务 curl利用URL规则在命令行下工作的文件传输工具curl baidu.com -o baidu.html --progress df显示磁盘的相关信息df -ah diff比较给定的两个文件的不同diff /usr/li test.txt dig域名查询工具dig baidu.com dirs显示目录记录dirs du显示每个文件和目录的磁盘使用空间du -sh ./* echo输出指定的字符串或者变量 egrep在文件内查找指定的字符串与grep类似 env显示系统中已存在的环境变量env exec调用并执行指定的命令 exit退出当前的shell export设置或显示系统环境变量export -p fc修改历史命令并执行fc -l -10 find在指定目录下查找文件find / 'nginx.conf' grep强大的文本搜索工具grep &amp;quot;match_pattern&amp;quot; file_1 file_2 gunzip用来解压缩文件gunzip /opt/etc.zip.gz gzip用来压缩文件gzip -9v ./1.html head在屏幕上显示指定文件的开头若干行head -n 10 CHANGELOG history用于显示历史命令history 100 host常用的分析域名查询工具host chenkai.life htop一个互动的进程查看器，可以动态观察系统进程状况 iconv转换文件的编码方式iconv file1 -f EUC-JP-MS -t UTF-8 -o file2 ifconfig配置和显示Linux系统网卡的网络参数 kill删除执行中的程序或工作 last列出目前与过去登入系统的用户相关信息 locate文件查找工具,将硬盘中的所有档案和目录资料先建立一个索引数据库locate nginx login登录系统或切换用户身份 logname用来显示用户名称 ls显示目录内容列表ls -alh ln用来为文件创建软硬连接 创建硬链接ln 源文件 目标文件，软链接ln -s 源文文件或目录 目标文件或目录 lsof用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)lsof -i:5577 mkdir用来创建目录mkdir -m 700 /usr/meng/test more显示文件内容，每次显示一屏more -c -10 file mv用来对文件或目录重新命名mv file_1.</description></item><item><title>深入理解UUID</title><link>https://chenkai.life/posts/uuid-understand/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/uuid-understand/</guid><description>UUID是什么 UUIDUniversally unique identifier 是一种唯一的字符串，用来标识一个设备或一个应用程序的唯一性。根据标准方法生成时，UUID 出于实用目的是唯一的。与大多数其他编号方案不同，它们的唯一性不依赖于中央注册机构或生成它们的各方之间的协调。虽然UUID 被复制的概率不是零，但它足够接近零，可以忽略不计.
UUID是固定长度128位，表示为 32 个十六进制（base-16）数字，显示在由连字符分隔的五组中，格式为 8-4-4-4-12 总共 36 个字符（32 个十六进制字符和 4 个连字符）例如：
123e4567-e89b-12d3-a456-426614174000 xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
数字的四位M是 UUID 版本（version），数字的 1 到 3 位最高有效位是NUUID的变体（variant），在示例中，M是1，N是a(10xx 2 )，这意味着这是一个version-1、variant-1 的 UUID。
变体（variant） UUID的变体（variant）字段，占1或2或3比特。RFC 4122定义了4种变体：
变体 0 (形如0xxx), 用于向后兼容已经过时的1988年开发的 Apollo 网络计算系统（NCS）1.5 UUID 格式. 变体 1 (形如10xx), 它是按照大端序作为二进制存储与传输 变体 2 (形如110x), 它是按照小端序作为二进制存储与传输 变体 3 (形如111x), 保留未使用 UUID的编码有很多种下面我只介绍Version 4 (random)，
版本（version） 对于“变体（variants）1、2，标准中定义了五个版本（versions），在特定用例中每个版本可能比其他版本更合适。版本由 M 字符串中指示。
版本1 - UUID 是根据时间和 节点ID（通常是MAC地址）生成； 版本2 - UUID是根据标识符（通常是组或用户ID）、时间和节点ID生成； 版本3、版本5 - 确定性UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成； 版本4 - UUID 使用随机性或伪随机性生成。 UUID的实现 浏览器提供了(crypto.</description></item><item><title>计算广告-基本概念</title><link>https://chenkai.life/posts/computing-advertising/</link><pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/computing-advertising/</guid><description>广告市场的参与者 Demand 需求方,这里的需求方包括广告主，代表广告主利益的代理商或其他技术形态的采买方，概括来说，就是想要投放广告的一方。
Supply 供给方,这里的供给方可以是媒体，也可以是其他技术形态的变现平台。在移动互联网时代，媒体指一切拥有流量的电视媒体、报纸、Web网站、移动APP、H5页面等等。概括来说就是给想要投放广告的需求方提供广告位的一方。
受众 受众就是我们这群看广告的人啦，之所以说是被动的，因为给我们看什么广告并不是我们决定的，而是由需求方和供给方来决定的。
SSP(supply side platform) 供给方平台, 它是为媒体方服务的，负责和ADX对接。接入SSP的媒体，在广告位有单个流量到来时，可发起广告请求，向ADX询问是否有合适的广告可展现。
DSP(demand side platform) 需求方平台, 它是为广告主服务的，负责和ADX对接。若干广告主将预算、创意、出价、流量要求等提交给DSP，DSP负责具体投放决策。
ADX(ad exchange) 它是为DSP和SSP服务的，起到衔接、匹配的作用。它接收到SSP的请求后，将广告流量信息传递给DSP，询问它们的出价。DSP响应后返回相应的广告创意及出价。
DMP(Data Management Platform) DMP能够为广告投放提供人群标签进行受众精准定向，并通过投放数据建立用户画像，进行人群标签的管理以及再投放。
Advertiser 广告主, 广告主手握预算，他们有展示自己产品的需求，需要优质的广告
Publisher 媒体方, 媒体拥有广告展示资源，他们有将广告位和流量变现的需求
广告市场的收费方式 广告这一商业行为，对于需求方来说，其目的主要有两个：一是吸引用户消费，二是塑造品牌形象；对于供给方来说，那当然是赚钱了。需求方想要在供给方这里放广告，当然是要付钱的。那么本节所介绍的，就是需求方如何向供给方付钱的。
CPM（Cost Per Mille） 千次展示计费 = (消费量/展现量)*1000), 即每展示1000次需求方的广告，需求方需要支付给供给方的钱。假设约定是1000元，那么广告展示5000次的话，需求方需要支付供给方5000元。
它受到越来越多的审查，因为无论消费者是否真正看到它，客户都要为印象付费。例如，在网络上，如果广告出现在浏览器窗口下方并且用户从不向下滚动，则广告商仍需付费。在移动端，同样如此。这很容易受到欺诈，典型情况是欺诈者在同一空间中加载 5、10 或 15 个广告，彼此堆叠。
CPC(Cost per Click) 按点击计费 = 消费量/点击量, 即广告每被受众点击一次，需求方需要支付给供给方的钱。假设约定的是一次3块，如果广告展示了1000次，共被点击20次，那么需求方需要支付给供给方60元。
一些广告客户更喜欢购买 CPC 而不是 CPM，因为他们认为只有在有人对消息足够感兴趣并想要更多信息时才会付费。这很可能是真的。一些 CPC 计划非常有效，但如果公司故意使用机器人或其他技术来驱动不是由真人发起的点击，则存在欺诈的可能性。
CPA(Cost per Action) 按转化付费 = 消费量/转化量 = (CPC*点击量)/(CVR*点击量) = CPC/CVR, 这里的转化形式可以很多，比如我们推送了一个公众号的广告，用户点击并关注公众号算是一种转化，推送了一个商品广告，用户购买或者加入购物车算是一种转化。假设需求方通过广告展示获得了200个用户的关注，每一个关注支付给供给方5元，那么供给方的收入共1000元。
CPS(Cost per Sale) 按销售额付费, CPS是CPA支付模式的一个具体案例，主要按照需求方的收入来决定的。假设需求方通过广告展示获得了1000元的销售额，按照20%的比例支付给供给方，那么供给方的收入便是200元。</description></item><item><title>Base64原理及实现</title><link>https://chenkai.life/posts/base64/</link><pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate><guid>https://chenkai.life/posts/base64/</guid><description>base64 Base64是用64个字符来表示数据的方法。Base64要求把每三个8Bit的字节转换为四个6Bit的字节，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。如果要转码数据字节不是3的倍数，最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。 转换后，我们每个字节范围为[00000000-00111111],所以我们可以用一个64码表来得到我们想要的字符串（也就是最终的Base64编码）标准的Base64用[A-Z,a-z,0-9,+,/]64个字符编码。
编码 深入了解base64前，我们需要先了解编码。编码是信息从一种形式或格式转换为另一种形式的过程。计算机中，所有的数据在存储和运算时都使用二进制示，n位二进制组合成2的n次方个不同的信息，给每个信息规定一个具体码组，这种过程叫编码。而具体用哪些二进制数字表示哪个符号，每个人都可以约定自己的一套编码。
如常用的ASCII是由美国国家标准学会制定的一种单字节字符编码，标准ASCII码使用7位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0到9、标点符号。在有的语言中128个符号是不够的，有些编码方案利用字节中闲置的最高位编入新的符号，有的利用两个（GBK等）或更多字节（utf-32等）表示一个符号（汉字）
Base64编码 base64编码过程：
ascii码s133对应的编码115 49 51 51 在内存2进制表示： 01110011 00110001 00110011 00110011 每三组分为6Bit四组011100 110011 000100 110011 001100 110000 000000 000000 高位补0得到 00011100 00110011 00000100 00110011 00001100 00110000 00000000 00000000 对应十进制 28 51 4 51 12 48 0 0 查对照表 生成base64码czEzMw== base64解码过程：
base64编码过程逆向即为解码
javascript代码实现 Base64 = { _table: [ &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;F&amp;#39;, &amp;#39;G&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;K&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;N&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;P&amp;#39;, &amp;#39;Q&amp;#39;, &amp;#39;R&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;, &amp;#39;g&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;j&amp;#39;, &amp;#39;k&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;q&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;v&amp;#39;, &amp;#39;w&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;z&amp;#39;, &amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;+&amp;#39;, &amp;#39;/&amp;#39; ], _getReg: function () { return RegExp(`^[${this.</description></item></channel></rss>